---
title: 微服务设计笔记04
tags: [微服务]
---
# 微服务设计笔记04
本篇笔记为微服务设计系列读书笔记的第四篇，主要记录微服务集成。  
## 寻找理想的集成技术
SOAP，XMLRPC，REST，Protocol Buffers？   
### 避免破坏性修改
对某个服务的一些修改导致服务消费方也随之发生改变，应该着力避免此种情况。  
### 保证API的技术无关性  
新技术、新工具层出不穷，这样我们的工作更高效。所以保证微服务之间通信方式的技术无关性非常重要。
### 使你的服务易于消费方使用
理想情况下，消费方可以使用任何技术实现。
### 隐藏内部实现细节
不希望消费方与服务的内部实现细节绑定在一起，因为这会增加耦合。所有倾向于暴露内部实现细节的技术都不应该被采用。
## 数据库集成
其他服务想从一个服务获取信息，可以直接访问数据库。非常直接，所以是最快的集成方式。缺点如下：
1. 外部系统能够查看实现细节，并与其绑定。如果修改表结构，则会影响其他服务。
2. 消费方与特定的技术绑定在一起，比如使用一段时间的关系型数据库后，发现NOSQL才是更合适的。但是因为消费方与客户服务紧密地绑定在了一起，所以不能轻易替换。  
3. 对数据库操作的服务有很多，如果修复一个bug，可能会修复多个地方。  

## 同步与异步
同步：发起一个远程服务调用后，调用方会阻塞自己并等待整个操作完成。异步：调用方不需要等待操作完成就可以返回，甚至可能不需要关系这个操作是否完成。  
### 基于事件协作方式
客户端不是发起请求，二是发布一个事件，期待其他的协作者接收消息。基于事件的系统天生就是异步的。整个系统都很聪明，业务逻辑并非集中存在于某个核心大脑，二是平均分布在不同的协作者中，所以耦合性低。一些跨服务边界的流程，这些流程可能会运行很长时间，所以会涉及到同步和异步的选择。

## 编排与协同
### 编排实例
![编排图例](/images/bpxt.png)<br/>
所谓编排(orchestration)，我们会依赖某个中心大脑来指导并驱动整个流程。上述流程编排的做法是：让客户服务作为中心大脑，创建客户时，他会跟积分账户、电子邮件服务、邮政服务通过请求响应的方式进行通信。    
编排方式的缺点：客户服务作为中心控制点承担了太多的职责。其他与他交互的服务变为贫血的，基于CRUD的服务。   
### 协同实例
从客户服务中使用异步的方式触发一个事件。电子邮件服务、邮政服务、积分账户简单订阅这些事件并做相应处理。  
![协同图例](/images/xt.png)<br/>
这就意味着需要一些额外的工作监控流程，以保证正确执行。   
协同方式耦合性小，而且对系统的改动更加灵活，所以建议使用协同方式。针对请求/响应方式，可以考虑使用两种技术：RPC和REST。  

## 远程过程调用
远程调用允许进行一个本地调用，但是实际上结果是某个远程服务器产生的。比如SOAP,Thrift，protocl buffers。技术核心特点：使用本地调用的方式和远程进行交互。  
JAVA RMI ，Thrift,protocol buffers 使用二进制，而SOAP使用XML作为消息格式。RPC实现会自动实现服务端和客户端的桩代码，基本不用花时间，就可以在服务之间进行内容交互了。但是RPC存在以下缺点：
### 技术的耦合
RMI与特定的平台紧密绑定，对服务端和客户端的技术选型造成一定的限制(RMI的服务端和客户端都绑定在JVM上了)。Thrfits和protocol buffers对不同语言支持较好。  
### 本地调用和远程调用并不相同
RPC隐藏了远程调用的复杂性，RPC会花大量时间对负荷进行封装和解封装，还有网络通信需要的时间。网络是不可靠的。
### 脆弱性
针对JAVA RMI若是修改远程调用接口或者修改实例对象的字段，则服务端和客户端都必须修改，即使修改的实例对象的字段生产环境不使用。
### RPC 很糟糕吗
JAVA RMI 避免使用。但是一些更现代的RPC机制，protocol buffers Thrift可以使用。
1. 不要对远程调用过度抽象，以至于网络因素被隐藏起来。
2. 可以独立升级服务端，而不是强迫客户端升级。
3. 相对数据库集成，RPC是一个巨大的进步。
## REST
REST 并不限制底层协议，事实上最常用HTTP。

## REST
HTTP本身提供很多功能，功能对REST风格非常有用。
JSON、XML还是其他。
有些框架直接将数据库对象反序列化成进程内的对象，然后直接暴露给外部，这样的设计耦合性较高。

## 实现基于事件的异步协作方式
### 技术选择
1. RabbitMQ消息代理，尽量让中间件保持简单，业务逻辑放在自己的服务中。
2. ATOM HTTP传播事件。

### 异步架构的复杂性
短生命周期的异步操作比较容易管理。
设计最大重试次数和消息医院（死信队列）。

## 微服务中的DRY和代码重用的风险
DRY: DoNot Repeat yourself，避免重复代码的意思。
在微服务内部不要违反DRY，但是在跨服务的情况下可以适当违反DRY。

## 版本管理
服务接口改变，如何管理这些改变。
1. 尽可能推迟或不做这种修改。
2. 及早发现破坏性修改。
3. 使用语义化的版本管理。MAJOR MINOR PATCH。MAJOR改变意味着其中包含向后不兼容的修改。MINOR 有新功能产生，但是向后兼容。PATCH对已有功能的缺陷修复。
4. 不同的接口共存。在同一个服务上，新老接口同时存在。一旦消费者不再访问老接口，则可以删除老接口。
![新老接口同时存在](/images/wfw04_01.png)<br/>
内部对所有V1的请求，转换为请求V2，使用这种方式，删除哪些代码会比较清楚。可以在请求中添加版本信息。/v1/customer ，/v2/customer。  

## 用户界面
1. 走向数字化。
2. 约束。PC 手机 平板使用方式不同。移动情况下网络不同。
3. API组合。gateway(API入口)多个底层调用会被聚合成为一个调用。
4. UI片段的组合。服务直接暴露出一部分UI，简单把这部分UI组合在一起就可以创建出整体UI。
5. 为前端服务的后端。与后端交互比较频繁的界面或者需要给不同设备提供不同内容的界面，常见解决方案，使用服务端的聚合接口或API入口。
![前后端交互](/images/wfw04_yhjm.png)<br/>
这样会得到一个聚合所有服务的巨大的层。所有东西放在一起，失去了不同用户界面之间的隔离性，限制了彼此独立发布的能力。作者推荐的模式如下：
![前后端交互推荐图](/images/wfw04_qhdjhtjt.png)<br/>   这种模式有时也叫做BFF(Backends for frontends)。

## 小结
1. 无论如何避免数据库集成
2. 理解REST和RPC之间的取舍。但是总是使用REST作为请求/响应模式的起点。
3. 相比编排，优先选择协同。
4. 避免破坏性修改，理解POstel 使用容错性读取器。
5. 将用户界面看做一个组合层。

## 参考
《微服务设计》