{"meta":{"title":"学习之路","subtitle":"做只笨鸟","description":"记录技术学习以及读书心得","author":"DuMing","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-04-14T13:26:37.000Z","updated":"2018-04-14T13:26:37.678Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"指数基金投资指南-银行螺丝钉","slug":"2018-04-29-指数基金投资指南","date":"2018-04-29T03:22:55.290Z","updated":"2018-04-29T03:36:10.933Z","comments":true,"path":"2018/04/29/2018-04-29-指数基金投资指南/","link":"","permalink":"http://yoursite.com/2018/04/29/2018-04-29-指数基金投资指南/","excerpt":"","text":"指数基金投资指南-银行螺丝钉利用一天时间翻了下螺丝钉写的《指数基金投资指南》，还是挺有收获的，下面重点写下这本书提到的指数估值方法。 指数估值-盈利收益率法该方法是格林厄姆提出的，在盈利收益率高的时候开始定投，在盈利收益率低的时候结束甚至止盈。盈利收益率多高算高？格林厄姆认为满足如下两个条件即为高。 盈利收益率要大于10 盈利收益率要大幅高于同期无风险利率 回到中国市场，当盈利收益率大于10坚持定投，盈利收益率小于6.4%时，结束定投（或者止盈分批卖出）。为何是6.4%，因为6.4%是中国债券基金的长期收益率，低于6.4%了不如投资债券了。 盈利收益率法使用条件 成分股流通性好 成分股盈利稳定盈利收益率法适用的指数 上证红利、中证红利、 上证50、基本面50、上证50AH优选、央视50 恒生指数、国企指数 指数估值-博格公式法影响指数基金收益的三大因素 初始投资时刻的股息率 投资期内的市盈率变化 投资期内的盈利增长率 指数基金未来的年复合收益率等于投资初期股息率+指数基金每年的市盈率变化率（可正可负）+指数基金每年的盈利变化率。注：平均到每年的变化率和收益率。 博格公式法如何实践三个因素中，可以确定的因素有两个：（1）股息率（2）当前市盈率所处历史波动中的位置。无法确定的只有一个：未来盈利的增速。根据已知因素，可以做到如下三点： 股息率高的时候买入 市盈率处于较低位置处买入 买入之后，耐心等待均值回归，等待市盈率从低到高。 博格公式法适用指数 沪深300、中证500、创业板 红利机会、消费行业、医药、养老产业指数 指数估值-博格公式变种针对周期行业，盈利E的变化很大已经失去了比较意义，此时我们引入PB对指数进行分析。指数基金未来的年复合收益率 = 指数基金每年市净率的变化率 + 指数基金每年净资产的变化率 博格公式变种适合指数 证券行业、金融行业、非银金融行业、地产行业 定期不定额定投作为一个老韭菜，自认为心理抗波动能力还可以，所以重点记录下定期不定额定投。简单地说，就是跌的多买的多，跌的少买的少。 每期定投资金 = 1000元 【n （当期盈利收益率） / （基准盈利收益率 10%）】。n相当于一个放大器，根据自身随意调节。举例子，比如当前盈利收益率是11.2% ， n=1，则本月投入资金为：1000 1（11.2/10）=1120元。 上面这个公司对博格公式法也适用，博格公式变种法用PB代替PE。 思维导图总结","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"docker学习笔记02-镜像","slug":"2018-04-28-docker学习笔记02","date":"2018-04-28T13:26:42.885Z","updated":"2018-04-29T02:15:42.527Z","comments":true,"path":"2018/04/28/2018-04-28-docker学习笔记02/","link":"","permalink":"http://yoursite.com/2018/04/28/2018-04-28-docker学习笔记02/","excerpt":"","text":"docker学习笔记02-镜像Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。 获取镜像从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 DockerHub。仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt; 。对于 DockerHub，如果不给出用户名，则默认为 library ，也就是官方镜像。123456789docker pull ubuntu:16.0416.04: Pulling from library/ubuntu297061f60c36: Pull complete e9ccef17b516: Pull complete dbc33716854d: Pull complete 8fe36b178d25: Pull complete 686596545a94: Pull complete Digest: sha256:15f721c027e007887ba6cb071a65628c81122cb2b406e341d07cf2c180f7d759Status: Downloaded newer image for ubuntu:16.04 从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的sha256的摘要，以确保下载一致性。 运行image有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的ubuntu:16.04为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。123456789101112131415161718docker run -it --rm \\ubuntu:16.04 \\bash[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker run -it --rm \\&gt; ubuntu:16.04 \\&gt; bashroot@aee0271f7ebc:/# cat /etc/os-releaseNAME=&quot;Ubuntu&quot;VERSION=&quot;16.04.4 LTS (Xenial Xerus)&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 16.04.4 LTS&quot;VERSION_ID=&quot;16.04&quot;HOME_URL=&quot;http://www.ubuntu.com/&quot;SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;VERSION_CODENAME=xenialUBUNTU_CODENAME=xenial docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。 -it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们这里打算进入bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 –rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。 ubuntu:16.04 ：这是指用 ubuntu:16.04 镜像为基础来启动容器。 bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 。 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release ，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。最后我们通过 exit 退出了这个容器。 列出镜像要想列出已经下载下来的镜像，可以使用 docker image ls 命令。1234[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 16.04 0b1edfbffd27 4 hours ago 113MBhello-world latest e38bc07ac18e 2 weeks ago 1.85kB 可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间123456[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker system dfTYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 2 1 113MB 113MB (99%)Containers 1 0 0B 0BLocal Volumes 0 0 0B 0BBuild Cache 0B 0B 中间层镜像为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 删除本地镜像如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：12345678910[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker image rm 0b1edfbffd27Untagged: ubuntu:16.04Untagged: ubuntu@sha256:15f721c027e007887ba6cb071a65628c81122cb2b406e341d07cf2c180f7d759Deleted: sha256:0b1edfbffd27c935a666e233a0042ed634205f6f754dbe20769a60369c614f85Deleted: sha256:a606d2db36205a11036adff8d9556e7180c26639eede2466a128d0de9b3e1b2dDeleted: sha256:fc07fc8491e0f830ebdd30de1c1b683cb2456051d17401351948ed34fe64d4afDeleted: sha256:9ddf57d8cd7fe42a9c547584549ede3dac5990b4c78ddec319ffae2cde20a496Deleted: sha256:349f8ed4d525976a9549088aa1979bc36a79f8209f89024c3cd127399914f46bDeleted: sha256:c8aa3ff3c3d351787cc5f84d960870fad16c9615aab7aa47ab343906fc8cfc24[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ 用 docker image ls 命令来配合删除所有仓库名为 redis 的镜像1docker image rm $(docker image ls -q redis) 使用docker file定制镜像镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。这个脚本就叫做Dockerfile。 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为 Dockerfile ：123$ mkdir mynginx$ cd mynginx$ touch Dockerfile 其内容为:12FROM nginxRUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令， FROM 和 RUN 。 FROM 指定基础镜像所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如nginx 、 redis 、 mongo 、 mysql 、 httpd 、 php 、 tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node 、 openjdk 、 python 、 ruby 、 golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如ubuntu 、 debian 、 centos 、 fedora 、 alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch 。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。使用 Dockerfile 定制镜像。 RUN 执行命令RUN 指令是用来执行命令行命令的。由于命令行的强大能力， RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式： RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 exec 格式： RUN [“可执行文件”, “参数1”, “参数2”] ，这更像是函数调用中的格式。既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：12345678FROM debian:jessieRUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install 上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。正确的写法应该是这样：12345678910111213FROM debian:jessieRUN buildDeps=&apos;gcc libc6-dev make&apos; \\&amp;&amp; apt-get update \\&amp;&amp; apt-get install -y $buildDeps \\&amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \\&amp;&amp; mkdir -p /usr/src/redis \\&amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\&amp;&amp; make -C /usr/src/redis \\&amp;&amp; make -C /usr/src/redis install \\&amp;&amp; rm -rf /var/lib/apt/lists/* \\&amp;&amp; rm redis.tar.gz \\&amp;&amp; rm -r /usr/src/redis \\&amp;&amp; apt-get purge -y --auto-remove $buildDeps 构建镜像进入之前创建的 Dockerfile所在目录 12345678910111213141516[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048kBStep 1/2 : FROM nginxlatest: Pulling from library/nginx2a72cbf407d6: Pull complete 04b2d3302d48: Pull complete e7f619103861: Pull complete Digest: sha256:18156dcd747677b03968621b2729d46021ce83a5bc15118e5bcced925fb4ebb9Status: Downloaded newer image for nginx:latest ---&gt; b175e7467d66Step 2/2 : RUN echo Hello, Docker! &gt; /usr/share/nginx/html/index.html ---&gt; Running in 332935fd6a32Removing intermediate container 332935fd6a32 ---&gt; c08e23705638Successfully built c08e23705638Successfully tagged nginx:v3 运行nginx:v3镜像 12345678910111213141516171819202122232425262728docker run --name web2 -d -p 81:80 nginx:v3[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker run --name web2 -d -p 81:80 nginx:v372a659ee4374df18579dbe2a662ddc1927cfce5b507fe79a158409934e851aad 在shell中运行 links 127.0.0.1:81``` #### 镜像构建上下文（Context） 如果注意，会看到 docker build 命令最后有一个 . 。 . 表示当前目录，而 Dockerfile就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？ 首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 DockerRemote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当构建的时候，用户会指定构建镜像上下文的路径， dockerbuild 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： COPY ./package.json /app/`这并不是要复制执行 docker build 命令所在的目录下的 package.json ，也不是复制Dockerfile 所在目录下的 package.json ，而是复制 上下文（context） 目录下的package.json 。 因此， COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore ，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 参考链接github yeasy/docker_practice","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"docker学习笔记01-docker介绍与安装","slug":"2018-04-28-docker学习笔记01","date":"2018-04-28T13:19:05.569Z","updated":"2018-04-28T13:20:43.716Z","comments":true,"path":"2018/04/28/2018-04-28-docker学习笔记01/","link":"","permalink":"http://yoursite.com/2018/04/28/2018-04-28-docker学习笔记01/","excerpt":"","text":"docker学习笔记01-docker介绍与安装docker与VM区别首先上两张图，第一张是传统vm，第二张是docker。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于 系统支持量 单机上千容器 一般几十个 基本概念镜像ImageDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器Container镜像（ Image ）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学Docker时常常会混淆容器和虚拟机。前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 仓库Repository镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，DockerRegistry就是这样的服务。一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 以 Ubuntu 镜像为例，ubuntu是仓库的名字，其内包含有不同的版本标签，如，14.04,16.04。我们可以通过ubuntu:14.04 ，或者 ubuntu:16.04来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu ，那将视为 ubuntu:latest 。仓库名经常以 两段式路径形式出现，比如jwilder/nginx-proxy ，前者往往意味着DockerRegistry多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。 centos安装docker engine卸载旧版本12345678910yum remove docker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-selinux \\docker-engine-selinux \\docker-engine 使用脚本自动安装12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。 启动 Docker CE12345678910111213141516171819202122$ sudo systemctl enable docker$ sudo systemctl start docker[root@iz2ze1fd7d8ota0f9ysaazz ~]# docker versionClient: Version: 18.04.0-ce API version: 1.37 Go version: go1.9.4 Git commit: 3d479c0 Built: Tue Apr 10 18:21:36 2018 OS/Arch: linux/amd64 Experimental: false Orchestrator: swarmServer: Engine: Version: 18.04.0-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.4 Git commit: 3d479c0 Built: Tue Apr 10 18:25:25 2018 OS/Arch: linux/amd64 Experimental: false 建立 docker 用户组默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用root用户。因此，更好地做法是将需要使用 docker 的用户加入 docker用户组。 建立 docker 组用户groupadd dockeruseradd docker -g docker 将docker用户加入 docker 组usermod -aG docker docker 测试 Docker 是否安装正确1234567891011121314151617181920212223242526272829docker run hello-world[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-world9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 添加内核参数默认配置下，如果在CentOS使用DockerCE看到下面的这些警告信息：12WARNING: bridge-nf-call-iptables is disabledWARNING: bridge-nf-call-ip6tables is disabled 请添加内核配置参数以启用这些功能。1234$ sudo tee -a /etc/sysctl.conf &lt;&lt;-EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF 然后重新加载 sysctl.conf 即可sysctl -p重新执行docker info命令， 没有warning信息即可。 镜像加速鉴于国内网络问题，后续拉取Docker镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。对于centos7，请在/etc/docker/daemon.json中写入如下内容（如果文件不存在请新建该文件）。12345&#123;&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; 修改完毕后重启docker服务12$ sudo systemctl daemon-reload$ sudo systemctl restart docker 检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info ，如果从结果中看到了如下内容，说明配置成功。12Registry Mirrors: https://registry.docker-cn.com/ 参考链接github yeasy/docker_practice","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"我的常用git命令","slug":"2018-04-26-我的常用git命令","date":"2018-04-26T00:47:19.130Z","updated":"2018-04-28T01:21:29.948Z","comments":true,"path":"2018/04/26/2018-04-26-我的常用git命令/","link":"","permalink":"http://yoursite.com/2018/04/26/2018-04-26-我的常用git命令/","excerpt":"","text":"常用git命令回退到某次提交git reset –hard xxxxxxx好吧，这个如此rude的操作，放在第一条有点不协调。 push/pull 远程git clone xxx.git (本地目录)git push [远程名] [本地分支]:[远程分支]git pull [远程名] [本地分支]:[远程分支]从remote拉取一个新分支git checkout -b [本地分支] [远程名]/[远程分支]checkout的本地分支和远程分支名可以不一样 git loggit log –oneline –graph –decorate使用上面命令打印出来的日志，比较美观直观。 git rebase 需要注意的第一点，如果是执行git rebase master，此处的master实际上是本地的master 。 所以在执行git rebase 。 master之前，最好保证本地的master是最新的。 rebase适用的黄金法则：最好是本地的feature，不需要同步到remote的，这样安全性是最高的，不会对他人的commit造成混乱。因为rebase实际上是将master分支的commit，压到最前面。 rebase fix conflictrebase提示有冲突，可以按以下顺序解决： 修改程序代码，解决冲突。 git add fix后的代码文件 git rebase –continue 如果仍然有冲突继续解决，即重复1-3步骤，直至结束。 rebase –skip –abortgit rebase –skip 高风险操作，是将本次提交的代码删除掉（慎用）。git rebase –abort 将代码回退到 执行rebase之前的操作 查看远端分支git branch -a 冷冻当前dev分支修复bug软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交 12345678910111213$ git stash //冷冻现在在dev分支上的工作状态 冻结吧！ $ git checkout master //这个bug发生在master主分支上,我们切回master分支$ git checkout -b issue-101 //创建代号101的修复bug分支修改你的bug$ git add readme.txt //提交到暂存区$ git commit -m &quot;fix bug 101&quot; //注意填写信息，以免日后查证$ git checkout master //切换回master分支$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 //合并分支，注意不使用fast forward模式$ git branch -d issue-101 //删除issue-101分支$ git checkout dev //bug 改完了，是时候回到dev继续写bug了$ git stash list //查看刚刚的冻结现场$ git stash pop //git stash pop，恢复的同时把stash内容也删了：//一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 github上定期从目标仓库更新个人仓库1234git remote add upstream https://github.com/目标仓库/docker_practice$ git fetch upstream$ git rebase upstream/master$ git push -f origin master 参考链接掘金—bibi94","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"ES6学习之路-03","slug":"2018-04-25-ES6学习之路03","date":"2018-04-25T00:58:53.457Z","updated":"2018-04-25T00:59:32.052Z","comments":true,"path":"2018/04/25/2018-04-25-ES6学习之路03/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-25-ES6学习之路03/","excerpt":"","text":"ES6学习之路-03数组JSON数组格式转换JSON的数组格式就是为了前端快速的把JSON转换成数组的一种格式。1234567891011let json = &#123; &apos;0&apos;: &apos;test1&apos;, &apos;1&apos;: &apos;test2&apos;, &apos;2&apos;: &apos;test3&apos;, length: 3&#125;let arr = Array.from(json)console.log(arr)output:[&quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot;] 这就是一个标准的JSON数组格式，跟普通的JSON对比是在最后多了一个length属性。只要是这种特殊的json格式都可以轻松使用ES6的语法转变成数组。在ES6中绝大部分的Array操作都存在于Array对象里。我们就用Array.from(xxx)来进行转换。我们把上边的JSON代码转换成数组，并打印在控制台。 Array.of()方法它负责把一堆文本或者变量转换成数组。在开发中我们经常拿到了一个类似数组的字符串，需要使用eval来进行转换，d但是eval的效率是很低的，它会拖慢我们的程序。这时候我们就可以使用Array.of方法。我们看下边的代码把一堆数字转换成数组并打印在控制台上：12345678let arr2 = Array.of(3, 4, 5, 6)console.log(arr2)let arr3 = Array.of(&quot;1test&quot;, &quot;2test&quot;, &quot;3test&quot;)console.log(arr3)[3, 4, 5, 6][&quot;1test&quot;, &quot;2test&quot;, &quot;3test&quot;] find( )实例方法这里的find方法是从数组中查找。在find方法中我们需要传入一个匿名函数，函数需要传入三个参数： value：表示当前查找的值。 index：表示当前查找的数组索引。 arr：表示当前数组。在函数中如果找到符合条件的数组元素就进行return，并停止查找。你可以拷贝下边的代码进行测试，就会知道find作用。1234let arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr4.find(function(value, index, arr) &#123; return value &gt; 6;&#125;)) fill( )实例方法fill()也是一个实例方法，它的作用是把数组进行填充，它接收三个参数，第一个参数是填充的变量，第二个是开始填充的位置，第三个是填充到的位置。12345678let arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr4.find(function(value, index, arr) &#123; return value &gt; 6;&#125;))arr4.fill(&quot;es6&quot;, 3, 5)[1, 2, 3, &quot;es6&quot;, &quot;es6&quot;, 6, 7, 8, 9] 数组的遍历for…of循环先来一个最简单的for of循环1234let arr5 = [1, 2, 3, 4, 5, 6, 7, 8, 9];for (let item of arr5) &#123; console.log(item)&#125; for…of数组索引1234let arr5 = [1, 2, 3, 4, 5, 6, 7, 8, 9]for (let index of arr5.keys()) &#123; console.log(index)&#125; for…of 值和索引同时访问用entries()这个实例方法，配合我们的for…of循环就可以同时输出内容和索引了。123for (let [index, value] of arr4.entries()) &#123; console.log(index + &apos;:&apos; + value)&#125; entries()实例方式生成的是Iterator形式的数组，那这种形式的好处就是可以让我们在需要时用next()手动跳转到下一个值。 箭头函数和扩展默认值1234function add(a, b = 1) &#123; return a + b;&#125;console.log(add(1)); 主动抛出错误ES6中我们直接用throw new Error( xxxx ),就可以抛出错误。123456789/**函数抛出异常 */function addExp(a, b = 1) &#123; if (a == 0) &#123; throw new Error(&apos;This is error&apos;) &#125; return a + b;&#125;console.log(addExp(0));console.log(addExp.length); 注意上面代码最后一行，可以打印出函数的参数（必传参数）个数。 箭头函数感觉有点像java的lambda表达式，语言果然像融合的方向发展。12let add1 = (a, b = 1) =&gt; a + bconsole.log(add1(3, 4)) {}的使用括号右侧如果是两句话，就需要使用{}。12345let add2 = (a, b = 1) =&gt; &#123; console.log(&quot;function&quot;) return a + b&#125;console.log(add2(6, 7)) 箭头函数中不可加new，也就是说箭头函数不能当构造函数进行使用。 对象的函数解构在前后端分离时，后端经常返回来JSON格式的数据，前端的美好愿望是直接把这个JSON格式数据当作参数，传递到函数内部进行处理。ES6就为我们提供了这样的解构赋值。123456let json = &#123; a: &apos;es6&apos;, b: &apos;study&apos;&#125;let foo = (&#123; a, b = &apos;study&apos; &#125;) =&gt; console.log(a, b)foo(json) in的用法in是用来判断对象或者数组中是否存在某个值的。我们先来看一下用in如何判断对象里是否有某个值。 对象判断12345let ajson = &#123; a: &apos;es6&apos;, b: &apos;study&apos;&#125;console.log(&apos;a&apos; in ajson); //true 数组判断先来看一下ES5判断的弊端，以前会使用length属性进行判断，为0表示没有数组元素。但是这并不准确，或者说真实开发中有弊端。1234/**in的用法 判断数组是否为空 */let arr11 = [, , , , , ];console.log(arr11.length); //5console.log(0 in arr11); //false 数组的遍历方法下面的代码包含了forEach，filter,some，map，这四个方法的参数本质上也是个函数，函数参数使用了匿名箭头函数。1234567891011/**数组循环 */let arrs = [&quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w5&quot;]arrs.forEach((value, index) =&gt; console.log(index + &quot;:&quot; + value))arrs.filter(x =&gt; console.log(x))arrs.some(x =&gt; console.log(x))let arrs1 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]arrs1.map(x =&gt; &#123; &apos;web&apos;; console.log(x)&#125;) 数组转换字符串 join()方法 12let arrs22 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]console.log(arrs22.join(&apos;|&apos;)); toString方法 123let arrs22 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]console.log(arrs22.join(&apos;|&apos;));console.log(arrs22.toString()); 参考链接技术胖老师es6学习blog","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路-02","slug":"2018-04-24-ES6学习之路02","date":"2018-04-25T00:58:08.074Z","updated":"2018-04-25T00:58:47.726Z","comments":true,"path":"2018/04/25/2018-04-24-ES6学习之路02/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-24-ES6学习之路02/","excerpt":"","text":"ES6学习之路-02ES6声明变量的方式var方式var在ES6里是用来升级全局变量的，我们可以先作一个最简单的实例，用var声明一个变量a,然后用console.log进行输出。如何理解它的作用是声明全局变量那？我们用匿名函数给他进行一个包裹，然后在匿名函数中调用这个a变量，看看能不能调用到。12345var a=2;&#123; var a=3;&#125;console.log(a); 上述代码打印出3，可见var 声明变量的范围是全局的。 let方式通过上面简单的例子，我们对var的全局声明有了一定了解。那跟var向对应的是let，它是局部变量声明。还是上面的例子，我们试着在区块里用let声明。1234let a = 2; &#123; let a = 3;&#125;console.log(a); babel转换成es5的文件内容为：1234var a = 2;&#123; var _a = 3;&#125;console.log(a); let的作用范围et声明只在区块内起作用，外部是不可以调用的。下面的代码执行时会报错。1234&#123; let a=3;&#125;console.log(a); let的作用是防止数据污染，在一个大型的项目中，使用let安全性会非常高。 const方式在程序开发中，有些变量是希望声明后在业务层就不再发生变化了，简单来说就是从声明开始，这个变量始终不变，就需要用const进行声明。123const a = &quot;JSPang&quot;;var a = &apos;技术胖&apos;;console.log(a); 上面的代码编译阶段就报错了，原因就是我们const声明的变量是不可以改变的。 变量的解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。解构赋值在实际开发中可以大量减少我们的代码量，并且让我们的程序结构更清晰。 数组的解构赋值简单的数组解构以前，为变量赋值，我们只能直接指定值。比如下面的代码：123let a = 0;let b = 1;let c = 2; 而现在我们可以用数组解构的方式来进行赋值。1let [a,b,c]=[1,2,3]; 上面的代码表示，可以从数组中提取值，按照位置的对象关系对变量赋值。 数组模式和赋值模式统一可以简单的理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。1let [a,[b,c],d]=[1,[2,3],4]; 解构的默认值解构赋值是允许你使用默认值的，先看一个最简单的默认是的例子。12let [foo = true] = [];console.log(foo); //控制台打印出true 上边的例子数组中只有一个值，可能你会多少有些疑惑，我们就来个多个值的数组，并给他一些默认值。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;]console.log(a+b); //控制台显示“技术胖JSPang” 现在我们对默认值有所了解，需要注意的是undefined和null的区别。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;,undefined];console.log(a+b); //控制台显示“技术胖JSPang” undefined相当于什么都没有，b是默认值。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;,null];console.log(a+b); //控制台显示“技术胖null” null相当于有值，但值为null。所以b并没有取默认值，而是解构成了null。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123let &#123; foo, bar &#125; = &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;console.log(foo)console.log(bar) 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 扩展运算符和rest运算符对象扩展运算符（…）当编写一个方法时，我们允许它传入的参数是不确定的。这时候可以使用对象扩展运算符来作参数，看一个简单的列子：12345678function jspang(...arg)&#123; console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]); &#125;jspang(1,2,3); 扩展运算符的用处 先用一个例子说明，我们声明两个数组arr1和arr2，然后我们把arr1赋值给arr2，然后我们改变arr2的值，你会发现arr1的值也改变了，因为我们这是对内存堆栈的引用，而不是真正的赋值。123456789 /**扩展运算符的用处-数组赋值 */let arr1 = [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;]let arr2 = arr1console.log(arr2)arr2.push(&quot;study&quot;)console.log(arr1)输出实例如下：[&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;][&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;, &quot;study&quot;] 利用扩展运算符可以解决数组深度构造的问题。12345678let arr3 = [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;]let arr4 = [...arr3]console.log(arr3)arr4.push(&quot;study&quot;)console.log(arr3)(3) [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;](3) [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;] 可见arr3并没有被改变，与arr4是各自独立占一块内存。 rest运算符 如果你已经很好的掌握了对象扩展运算符，那么理解rest运算符并不困难，它们有很多相似之处，甚至很多时候你不用特意去区分。它也用…（三个点）来表示，我们先来看一个例子。1234567 /**rest运算符 */function restOper(first, ...args) &#123; console.log(args.length)&#125;restOper(0, 1, 2, 3, 4, 5, 6, 7)打印出7 ，说明args中有7个元素。 for…of循环12345function restOperForOf(first, ...args) &#123; for (let val of args) console.log(val)&#125;restOperForOf(0, 1, 2, 3, 4, 5, 6, 7) for…of的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for…of循环。有的小伙伴会说了，反正最后要转换成ES5，没有什么差别，但是至少从代码量上我们少打了一些单词，这就是开发效率的提高。 字符串模板这节主要学习ES6对字符串新增的操作，最重要的就是字符串模版，字符串模版的出现让我们再也不用拼接变量了，而且支持在模板里有简单计算操作。 先看ES5下的字符串拼接实例123let username = &apos;jake1036&apos;let blog = &apos;欢迎大家来到&apos; + username + &apos;博客&apos;document.write(blog) ES5下必须用+username+这样的形式进行拼接，这样很麻烦而且很容易出错。ES6新增了字符串模版，可以很好的解决这个问题。字符串模版不再使用’xxx’这样的单引号，而是换成了xxx这种形式(可以看下面的代码)，也叫连接号。这时我们再引用jspang变量就需要用${username}这种形式了，我们对上边的代码进行改造。12345/**es6改造 */let username_es6 = &apos;jake1036&apos;let blog_es6 = `es6欢迎大家来到 $&#123;username&#125;博客`document.write(blog_es6) 还可以在字符串中增加html样式和代码12345 /**es6字符串添加html代码 */let username_es6_html = &apos;jake1036&apos;let blog_es6_html = `&lt;br/&gt;es6欢迎大家来到&lt;b&gt; $&#123;username&#125;&lt;/b&gt;博客`document.write(blog_es6_html) 对运算的支持 1234 /**对运算符的支持 */let a_es6 = 1let b_es6 = 2document.write(`&lt;br/&gt;a+b:$&#123;a_es6+b_es6&#125;`) 字符串函数 1234 /**字符串函数的应用 */let str_es6 = `测试es6字符串函数查找，支持汉字`console.log(str_es6.includes(&apos;es6&apos;))document.write(&apos;es6|&apos;.repeat(3)); //字符串重复 ES6数字操作二进制和八进制二进制和八进制数字的声明并不是ES6的特性，我们只是做一个常识性的回顾。 二进制声明二进制的英文单词是Binary,二进制的开始是0（零），然后第二个位置是b（注意这里大小写都可以实现），然后跟上二进制的值就可以了。12let binaryVal = 0B0110console.log(binaryVal) 控制台打印出6. 八进制声明八进制的英文单词是Octal，也是以0（零）开始的，然后第二个位置是O（欧），然后跟上八进制的值就可以了。12let b=0o666;console.log(b); 控制台打印出438。 数字判断和转换 数字验证Number.isFinite( xx )可以使用Number.isFinite( )来进行数字验证，只要是数字，不论是浮点型还是整形都会返回true，其他时候会返回false。 12345/**判断是否是数字 */let numberVal = 11 / 4console.log(Number.isFinite(numberVal)) //trueconsole.log(Number.isFinite(0.3434)) //trueconsole.log(Number.isFinite(&apos;test&apos;)) //false NaN验证NaN是特殊的非数字，可以使用Number.isNaN()来进行验证。下边的代码控制台返回了true。 1console.log(Number.isNaN(NaN)); 判断是否为整数Number.isInteger(xx) 1console.log(Number.isInteger(0.3434)) 参考jishupang老师博客","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路-01搭建环境","slug":"2018-04-23-ES6学习之路01","date":"2018-04-25T00:56:56.665Z","updated":"2018-04-25T00:58:01.993Z","comments":true,"path":"2018/04/25/2018-04-23-ES6学习之路01/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-23-ES6学习之路01/","excerpt":"","text":"ES6学习之路-01搭建环境继续跟着技术胖老师学习前端，接下来学习ES6，首先是搭建开发环境。本实例教程github地址：https://github.com/dumingcode/es6.git 搭建开发环境有些低版本的浏览器还是不支持ES6语法，需要我们把ES6的语法自动的转变成ES5的语法。webpack能实现此功能，Babel也可以，本文使用Babel将ES6编译成ES5。 建立工程目录es6，新建两个目录 src : 书写ES6代码的文件夹，写的js程序都放在这里 dist : 利用Babel编译成的ES5代码的文件夹，在HTML页面需要引入的时这里的js文件。 编写index.html页面（在工程根目录下）,html代码我就直接复制了，注意下面js的位置在dist中，我们的js文件写在src下，需要借助babel编译到dist目录下。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;script src=&quot;./dist/index.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello ECMA Script 6 &lt;/body&gt;&lt;/html&gt; 在src目录下编写index.js功能简单只作一个a变量的声明，并用console.log()打印出来。 12let a=1;console.log(a); let是ES6的一种声明方式，接下来我们需要把这个ES6的语法文件自动编程成ES5的语法文件。 初始化项目在安装Babel之前，需要用npm init先初始化我们的项目。npm init -y-y代表全部默认同意，就不用一次次按回车了。命令执行完成后，会在项目根目录下生产package.json文件。 123456789101112&#123; &quot;name&quot;: &quot;es6&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 全局安装Babel-clicnpm install -g babel-cli虽然已经安装了babel-cli，只是这样还不能成功进行转换，尝试输入命令babel src/index.js -o dist/index.js ， 显示结果如下 12let a = 1;console.log(a); 说明编译没有成功。 本地安装babel-preset-es2015 和 babel-clicnpm install --save-dev babel-preset-es2015 babel-cli 提示babel-preset-es2015过期，采用最新包继续安装cnpm install --save-dev babel-preset-env babel-cli。安装完成后打开package.json文件，发现新增配置如下： 12345&quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;&#125; 新建.babelrc在根目录下新建.babelrc文件，并打开录入下面的代码 123456&#123; &quot;presets&quot;:[ &quot;env&quot; ], &quot;plugins&quot;:[]&#125; 然后重新执行编译命令babel src/index.js -o dist/index.js。然后打开编译后的dist/index.js文件，源代码如下：1234&quot;use strict&quot;;var a = 1;console.log(a); 已经成功将ES6的语法编译成ES5。 编写转换script使用npm run build 直接利用webpack进行打包，在这里也希望利用这种方式完成转换。打开package.json文件，把文件修改成下面的样子。1234567891011121314151617&#123; &quot;name&quot;: &quot;es6&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;babel src/index.js -o dist/index.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot; &#125;&#125; 然后就可以使用npm run build打包了。 参考技术胖老师ES6","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"软技能-代码之外的生存指南读书心得","slug":"2018-04-22-软技能 代码之外的生存指南读书心得","date":"2018-04-22T08:44:19.053Z","updated":"2018-04-22T09:02:51.953Z","comments":true,"path":"2018/04/22/2018-04-22-软技能 代码之外的生存指南读书心得/","link":"","permalink":"http://yoursite.com/2018/04/22/2018-04-22-软技能 代码之外的生存指南读书心得/","excerpt":"","text":"软技能-代码之外的生存指南读后感花费半个月读完了John Z. Sonmez写的《软技能 代码之外的生存指南》一书。非常推荐广大程序员看一下此书，越早看受益越早。作者针对程序员职业生涯重点写到了如下几个方面： 如何学习技术 对待工作的态度，一周工作60小时以上是必要前提 程序员如何自我营销 节省时间提供工作效率的方法 建议程序员培养健身+理财的意识用思维导图把作者的主要观点表述如下 读后个人实践读完这本书，我具体实践了以下几个方面（已经在做，不是口号）： 建立了个人blog，养成每周至少发一篇高质量（尽量做到高质量）文章。 每周跑三次步（从14年就开始跑了） 理财意识（17年初开始关注股权投资） 每周工作60小时以上（公司工作） 日常工作使用番茄工作法，主要借助此方法评估每天的工作，每天10个番茄。 微信朋友圈消息提醒关闭。 每天7点前到公司，学习前端技术，vue、es6、nodejs，学习到9点。 作者推荐的书籍看一下，然后发表读书心得","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"hexo使用jenkins自动部署到阿里云","slug":"2018-04-21-hexo使用jenkins自动部署到阿里云","date":"2018-04-21T07:09:38.991Z","updated":"2018-04-21T07:35:34.530Z","comments":true,"path":"2018/04/21/2018-04-21-hexo使用jenkins自动部署到阿里云/","link":"","permalink":"http://yoursite.com/2018/04/21/2018-04-21-hexo使用jenkins自动部署到阿里云/","excerpt":"","text":"hexo使用jenkins自动部署到阿里云本地安装hexo12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 使用github pages服务部署hexo我们用来托管博客的服务叫做 Github Pages，它是 Github 用来提供给个人/组织或者项目的网页服务，只需要部署到你的 Github Repository，推送代码，便可以实时呈现。 首先，你需要有一个 Github 的账号。然后创建一个名称为 .github.io 的仓库来托管网页即可。 以我的 Github 为例，我的用户名是 dumingcode，所以创建一个名为 dumingcode.github.io 的仓库，创建的仓库地址便是：https://github.com/dumingcode/dumingcode.github.io.git 创建完后，我们可以暂时不用管它，不需要往仓库里面 push 任何的东西。 hexo部署配置接着，我们来配置一下本地的 Hexo。 在博客的根目录下有一个名为 _config.yml 的文件，这是博客的主配置文件。前面的其他部分我们先不理会，后文再谈，我们先看最后的 Deployment 配置项：1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 根据官方的文档显示，现在 Hexo 支持 Git、Heroku、Rsync、OpenShift、FTPSync 等部署方式，我们选择 Git 来部署的话，需要首先安装 hexo-deployer-git 插件：cnpm install hexo-deployer-git --save然后编辑上面的配置文件：12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 我们需要把刚才创建的仓库地址添加进来，branch 和 message 项可以不填，默认情况下推送到 master 分支，这里我建议使用 SSH 加密的仓库地址（参看 Github 官方文档配置 SSH 免密操作）。 保存配置文件之后，我们在博客的跟目录键入：hexo g -d便可以把博客部署到 Github 了。现在，所有人都可以通过 http://.github.io 来访问自己的博客。 hexo使用第三方模板找了半天发现hexo-theme-BlueLake主题很简洁，于是使用下面的命令安装（进入blog根目录执行）。 123git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLakecnpm install hexo-renderer-jade@0.3.0 --savecnpm install hexo-renderer-stylus --save 本人搭建好的github个人主页:https://dumingcode.github.io/，欢迎访问。 hexo部署到阿里云虽说利用github pages服务能够对外发布博客，但是作为一个码农还是希望有自己的域名博客，但是我比较懒，不想手动发布博客。我想自动化地既发布到github也能同时发布到个人网站。所以决定采用CICD的方法，CICD工具使用开源的jenkins，jenkins也搭建在阿里云个人服务器上。 下载并运行jenkins注意端口使用的是8081123mkdir /usr/local/jenkinswget http://mirrors.jenkins.io/war-stable/latest/jenkins.warnohup java -jar jenkins.war --ajp13Port=-1 --httpPort=8081 &amp; 安装nginx 安装nginx依赖 1234567891011yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-develwget http://nginx.org/download/nginx-1.13.10.tar.gztar xvf nginx-1.13.10.tar.gz./configure --prefix=/usr/local/nginxmakemake installcd /usr/local/nginx/sbin./nginx -s reloadnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or direc需要设置nginx.conf./nginx -c /usr/local/nginx/conf/nginx.conf nginx.conf配置 12345678910111213141516171819upstream jenkins &#123; server 127.0.0.1:8081; keepalive 64;&#125;server &#123; listen 80; server_name jenkins.buyasset.com; client_max_body_size 60M; client_body_buffer_size 512k; location / &#123; port_in_redirect on; proxy_pass http://jenkins/; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; &#125; 以上通过nginx 反向代理jenkins，在浏览器输入http://jenkins.buyasset.club就能够进入jenkins管理后台。 配置jenkins在jenkins页面提示目录中找到默认密码，输入jenkis域名，登陆jenkins。 安装jenkins社区推荐的插件 配置github获取sercret text登陆github网站，进入 github-&gt;Settings-&gt;Developer settings-&gt; Generate new token，点击生成完毕一定记录下下面的secret text。secret text一定要记住，忘记的话只能重新生成。 GitHub webhooks 设置进入GitHub上指定的项目（hexo 仓库） –&gt; setting –&gt; WebHooks&amp;Services –&gt; add webhook –&gt; 输入刚刚部署jenkins的服务器的IP图片中标红区域是变化的，后缀都是一样的为github-webhook。 jenkins中的github配置配置GitHub Plugin系统管理 –&gt; 系统设置 –&gt; GitHub –&gt; Add GitHub SeverAPI URL 输入 https://api.github.com，Credentials点击Add添加，Kind选择Secret Text,具体如下图所示。设置完成后，点击TestConnection,提示Credentials verified for user UUserName, rate limit: xxx,则表明有效。 创建一个freestyle任务 General 设置填写GitHub project URL, 也就是你的项目主页eg. https://github.com/your_name/your_repo_name 配置源码管理 构建触发器，构建环境 构建 构建脚本将上图的构建脚本替换如下： 1234cd /var/www/blog（hexo目录）git pullhexo cleanhexo g -d 构建后操作 构建前clone hexo将hexo初始代码拉取到/var/www/blog目录中，以后jenkins会监控github的push操作，一旦发现push会自动更新。cd /var/wwwgit clone https://github.com/dumingcode/dumingcode.github.io.git blog nginx反向代理hexohexo为静态网站，所以直接用nginx反向代理即可,nginx脚本如下：注意root指向的是hexo部署目录。12345678910111213141516171819202122232425server&#123; listen 80; server_name blog.buyasset.club; index index.html index.htm index.php default.html default.htm default.php; root /var/www/blog; #error_page 404 /404.html; location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$ &#123; access_log off; expires 1d; &#125; location ~ .*\\.(js|css|txt|xml)?$ &#123; access_log off; expires 12h; &#125; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 测试CICD效果进入本地hexo目录，修改发布的博客，然后执行hexo g -d，登陆jenkins发现jenkins已经获取到了push操作，并且执行了自动构建任务。以下为jenkins的变更记录1234Site updated: 2018-04-21 13:35:51 (commit: 76f3c53) (details)Commit 76f3c530d077782fd66a8ca375afaa17cd188286 by dumingSite updated: 2018-04-21 13:35:51 (commit: 76f3c53) 参考链接手把手教你搭建Jenkins+Github持续集成环境Jenkins+Github持续集成Jenkins最佳实践hexo自动部署基于 Hexo 的全自动博客构建部署系统","categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"}],"keywords":[]},{"title":"2018我的小目标","slug":"2018-04-15-我的小目标","date":"2018-04-15T08:43:27.901Z","updated":"2018-04-25T01:06:05.802Z","comments":true,"path":"2018/04/15/2018-04-15-我的小目标/","link":"","permalink":"http://yoursite.com/2018/04/15/2018-04-15-我的小目标/","excerpt":"","text":"技术方面学习知识 掌握vue框架，能使用vue实现功能。 学习使用ELK日志分析系统。 CICD-学习使用jenkins、Travis。 nginx open resty开发。 mongodb java8新特性比如lambda docker 阿里云部署实践docker java设计模式 nodejs学习并实践 按照前端开发栈学习es6 webpack等基础技术 实践知识学习-实践-教授-再学习，只学习效率会很低，学习技术必须学以致用，实践会加深理解。 大数整体仓位算下加权pb pe roe 股息率。 按申万一级，统计每个各行业符合大数的个股情况。 他山石现金流模型。 建立自己的专用域名blog，github和个人域名都写博客,坚持每周至少一篇blog。 每学习一种技术，写blog，然后录音频视频提供大家培训。 微信、app、都进行尝试 学会造轮子。","categories":[],"tags":[{"name":"规划","slug":"规划","permalink":"http://yoursite.com/tags/规划/"}],"keywords":[]},{"title":"2018北京长跑节半程马拉松","slug":"2018-04-15-北京长跑节半程马拉松","date":"2018-04-15T08:35:12.832Z","updated":"2018-04-15T08:38:56.882Z","comments":true,"path":"2018/04/15/2018-04-15-北京长跑节半程马拉松/","link":"","permalink":"http://yoursite.com/2018/04/15/2018-04-15-北京长跑节半程马拉松/","excerpt":"","text":"2018北京半程马拉松20180415忙里偷闲参加了北京长跑节半程马拉松，2:07跑完全程，创造个人最好成绩了。下面晒一些图，留下纪念。","categories":[],"tags":[{"name":"运动","slug":"运动","permalink":"http://yoursite.com/tags/运动/"}],"keywords":[]}]}