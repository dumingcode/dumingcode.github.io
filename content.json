{"meta":{"title":"学习之路","subtitle":"做只笨鸟","description":"记录技术学习以及读书心得","author":"DuMing","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-04-14T13:26:37.000Z","updated":"2018-04-14T13:26:37.678Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"nodejs学习之路03-express webscoket","slug":"2018-05-07-nodejs学习之路03","date":"2018-05-07T01:00:31.946Z","updated":"2018-05-07T01:01:04.651Z","comments":true,"path":"2018/05/07/2018-05-07-nodejs学习之路03/","link":"","permalink":"http://yoursite.com/2018/05/07/2018-05-07-nodejs学习之路03/","excerpt":"","text":"expressConnect基于http提供了web开发常用的基础功能，express又在Connect基础上提供了构建整个网站和web更为方便的API。通过一个小demo项目熟悉express的用法。demo程序实现的内容： 提供一个表单，接受用户的输入。 输入作为检索关键字，调用tweetAPI，并将返回结果返回给用户。ejs模板文件创建index.ejs和result.ejs12345678index.ejs&lt;h1&gt; Twitter app &lt;/h1&gt;&lt;p&gt;Please enter your search name&lt;/p&gt;&lt;form action=&quot;/search&quot; method=&quot;GET&quot;&gt; name: &lt;input type=&quot;text&quot; name=&quot;q&quot; /&gt; &lt;button&gt;search&lt;/button&gt;&lt;/form&gt; result.ejs实现比较简单，仅仅是回调一下函数12&lt;h1&gt;查询结果：&lt;/h1&gt;&lt;%= results %&gt; nodejs webserver代码注意下面的express代码使用的是最新的express库，《了不起的nodejs》书中的API已经严重老化了。123456789101112131415161718192021222324var express = require(&apos;express&apos;)var app = express();app.set(&apos;view engine&apos;, &apos;ejs&apos;)app.set(&apos;views&apos;, __dirname + &apos;/views&apos;)app.set(&apos;view options&apos;, &#123; layout: false &#125;)app.get(&apos;/&apos;, function(req, res) &#123; res.render(&apos;index&apos;)&#125;);app.get(&apos;/search&apos;, function(req, res, next) &#123; console.log(&apos;Accessing the secret section ...&apos;); res.render(&apos;result&apos;, &#123; results: req.param(&apos;q&apos;) &#125;)&#125;);var server = app.listen(3000, function() &#123; var host = server.address().address; var port = server.address().port; console.log(&apos;Example app listening at http://%s:%s&apos;, host, port);&#125;); package.json文件123456789101112131415&#123; &quot;name&quot;: &quot;express-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;express demo&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;duming&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;ejs&quot;: &quot;^2.6.1&quot;, &quot;express&quot;: &quot;^4.16.3&quot; &#125;&#125; 代码组织策略一个项目可能会有非常多的路由，这时良好的代码组织策略非常必要。比如一个应用包含三个模块，\\blog、\\tags、\\pages，每个版块都包含各自的路由，例如：/blog/search,/tags/new,/pages/del。 好的代码组织方式，就是维护一个server.js，该文件包含了路由表。同时将每一个部分的路由处理器通过模块化的方式引入，如blog.js，tags.js，pages.js，首先定义依赖的模块，并初始化app定义中间件。1234567891011121314151617var express = require(&apos;express&apos;), blog = require(&apos;/blog&apos;), tags = require(&apos;/tags&apos;), pages = require(&apos;/pages&apos;)var app = express();//blog routesapp.get(&apos;/blog&apos;,blog.home)app.get(&apos;/blog/search&apos;,blog.search)//tags routesapp.get(&apos;/tags&apos;,tags.home)app.get(&apos;/tags/search&apos;,tags.search)//pages routesapp.get(&apos;/pages&apos;,pages.home)app.get(&apos;/pages/search&apos;,pages.search) 以blog.js为例，针对每个路由函数使用exports123exports.home = function(res,rep,next)&#123; &#125; websocketwebsocket是web下的TCP， 一个底层的双向socket， 允许用户对消息传递进行控制。websocket包含两个部分：一个是前端浏览器实现的WebSocket API，另一个是服务器端实现的WebSocket协议，websocket还是建立在http之上。websocket是双向的，这样server可以向客户端主动推送数据，而之前的http协议交互是单向的，只能是客户端请求server。 （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 代码实例本文采用ws包实现server端的web service协议。server端代码如下：12345678910const WebSocket = require(&apos;ws&apos;);const wss = new WebSocket.Server(&#123; port: 8181 &#125;);wss.on(&apos;connection&apos;, function connection(ws) &#123; ws.on(&apos;message&apos;, function incoming(message) &#123; console.log(&apos;received: %s&apos;, message); &#125;); ws.send(&apos;something&apos;);&#125;); frontend代码如下：123456789101112131415&lt;h1&gt; Twitter app &lt;/h1&gt;&lt;p&gt;Please enter your search name&lt;/p&gt;&lt;input type=&quot;text&quot; name=&quot;message&quot; id=&quot;message&quot; placeholder=&quot;Type text to echo in here&quot; value=&quot;&quot; /&gt;&lt;button onclick=&quot;sendMessage();&quot;&gt;提交&lt;/button&gt;&lt;script&gt; var ws = new WebSocket(&quot;ws://localhost:8181&quot;); ws.onopen = function(e) &#123; console.log(&apos;Connection to server opened&apos;); &#125; function sendMessage() &#123; ws.send(&quot;test&quot;); &#125;&lt;/script&gt; 参考《了不起的nodejs》express官方网站阮一峰老师blog","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"nodejs学习之路02","slug":"2018-05-06-nodejs学习之路02","date":"2018-05-06T04:03:34.769Z","updated":"2018-05-06T04:10:07.225Z","comments":true,"path":"2018/05/06/2018-05-06-nodejs学习之路02/","link":"","permalink":"http://yoursite.com/2018/05/06/2018-05-06-nodejs学习之路02/","excerpt":"","text":"nodejs学习之路02简单http代码实例1234567var http = require(&apos;http&apos;)http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;text/html&apos; &#125;) res.end(&apos;Hello &lt;b&gt;World&lt;/b&gt;&apos;)&#125;).listen(3000) 下面尝试另一个案例，通过http协议传输png文件，体会png文件传输中对chunk的使用。12345678910111213141516171819var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;iamge/png&apos; &#125;) //创建png视图 let stream = fs.createReadStream(&apos;D:/Workspaces/blog/source/images/docker_vm.png&apos;) stream.on(&apos;data&apos;, (data) =&gt; &#123; res.write(data) &#125;) stream.on(&apos;end&apos;, () =&gt; &#123; res.end() &#125;) stream.on(&apos;error&apos;, (err) =&gt; &#123; console.log(err) &#125;)&#125;).listen(3000) http实战demo通过nodejs http API完成一个实际的任务，接收浏览器传来的form数据。首先构建一个发送表单的http服务，代码如下所示：123456var http = require(&apos;http&apos;)http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;text/html&apos; &#125;) res.end([&apos;&lt;form method=&quot;post&quot; action=&quot;/url&quot;&gt;&apos;, &apos;&lt;h1&gt;My Form&lt;/h1&gt;&apos;, &apos;&lt;fieldset&gt;&apos;, &apos;&lt;label&gt;Personal information&lt;/label&gt;&apos;, &apos;&lt;p&gt;what is your name?&lt;/p&gt;&apos;, &apos;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/input&gt;&apos;, &apos;&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;&apos;, &apos;&lt;/form&gt;&apos;].join(&apos;&apos;))&#125;).listen(3000) 点击表单中的按钮，因为server端没有/url的具体方法，所以无响应。下面增加提交按钮响应逻辑(接受并将输入的name返回到新的页面中,若访问的url不存在返回404)：12345678910111213141516171819var http = require(&apos;http&apos;)http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;text/html&apos; &#125;) let body = &apos;&apos; if (&apos;/&apos; == req.url) res.end([&apos;&lt;form method=&quot;post&quot; action=&quot;/url&quot;&gt;&apos;, &apos;&lt;h1&gt;My Form&lt;/h1&gt;&apos;, &apos;&lt;fieldset&gt;&apos;, &apos;&lt;label&gt;Personal information&lt;/label&gt;&apos;, &apos;&lt;p&gt;what is your name?&lt;/p&gt;&apos;, &apos;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/input&gt;&apos;, &apos;&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;&apos;, &apos;&lt;/form&gt;&apos;].join(&apos;&apos;)) else if (&apos;/url&apos; == req.url) &#123; req.on(&apos;data&apos;, (chunk) =&gt; &#123; body += chunk &#125;) req.on(&apos;end&apos;, () =&gt; &#123; res.end(`your name is:$&#123;body&#125;`) &#125;) &#125; else &#123; res.writeHead(404) res.end(&apos;not found&apos;) &#125;&#125;).listen(3000) http客户端http包提供了request API，但是本人倾向于使用axios第三方包。axios get请求是一个promise函数，封装了抽象的函数。12345678var axios = require(&apos;axios&apos;)axios.get(&apos;http://www.sse.com.cn/assortment/stock/list/info/company/index.shtml?COMPANY_CODE=600033&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); connect 中间件尝试使用一个demo来熟悉connet中间件，demo功能如下： 托管静态文件 处理错误以及损坏或者不存在的文件 处理不同类型的请求新建package.json文件12345678&#123; &quot;name&quot;: &quot;connect&quot;, &quot;version&quot;: &quot;0.01&quot;, &quot;description&quot;: &quot;a simple connect demo&quot;, &quot;dependencies&quot;: &#123; &quot;connect&quot;: &quot;^3.6.6&quot; &#125;&#125; 了不起的nodejs这本书中提供的例子实在是太老了，所以我按照现在的API重写了下面的代码。12345678910var finalHandler = require(&apos;finalHandler&apos;)var http = require(&apos;http&apos;)var serveStatic = require(&apos;serve-static&apos;)console.log(__dirname)var serve = serveStatic(__dirname, &#123; &apos;index&apos;: [&apos;1.html&apos;] &#125;)var server = http.createServer((req, res) =&gt; &#123; serve(req, res, finalHandler(req, res))&#125;)server.listen(3000) 除了http包，finalHandler和serve-static。在书写大型应用时，每个请求可能会触发多个功能，如果把这些功能代码都放在一个回调函数中，函数逻辑会很复杂。这时候可以考虑使用中间件机制，中间件本质上是函数。中间件函数除了接受req和res，还可以接受一个next函数来做流控制。这样一个大的业务逻辑，可以划分成多个中间件函数，业务逻辑划分就比较清晰了,next函数会按代码编写顺序由上到下执行，直到最后一个没有调用next函数为止。12345678app.use(function middleware1(req, res, next) &#123; // middleware 1 next();&#125;);app.use(function middleware2(req, res, next) &#123; // middleware 2 next();&#125;); 实践代码：12345678910111213141516171819202122232425262728293031var connect = require(&apos;connect&apos;)var http = require(&apos;http&apos;)var app = connect()var serveStatic = require(&apos;serve-static&apos;)var cookieSession = require(&apos;cookie-session&apos;)/**静态服务器 */app.use((req, res, next) =&gt; &#123; serveStatic(__dirname, &#123; &apos;index&apos;: [&apos;1.html&apos;] &#125;) next()&#125;)/**打印访问url */app.use((req, res, next) =&gt; &#123; console.log(req.url) next()&#125;)/**打印访问url */app.use((req, res, next) =&gt; &#123; console.log(req.method)&#125;)http.createServer(app).listen(3000) npm install命令总结一直都是直接输入npm install 直接输入，今天整理下这条命令的相关用法。 npm install 会把X包安装到node_modules目录中 不会修改package.json 之后运行npm install命令时，不会自动安装Xnpm install X –save: 会把X包安装到node_modules目录中 会在package.json的dependencies属性下添加X 之后运行npm install命令时，会自动安装X到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，会自动安装msbuild到node_modules目录中 npm install X –save-dev: 会把X包安装到node_modules目录中 会在package.json的devDependencies属性下添加X 之后运行npm install命令时，会自动安装X到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，不会自动安装X到node_modules目录中 使用原则:运行时需要用到的包使用–save，否则使用–save-dev。 参考npm install","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"ES6学习之路05","slug":"2018-05-03-ES6学习之路05","date":"2018-05-03T00:34:13.782Z","updated":"2018-05-03T00:34:51.359Z","comments":true,"path":"2018/05/03/2018-05-03-ES6学习之路05/","link":"","permalink":"http://yoursite.com/2018/05/03/2018-05-03-ES6学习之路05/","excerpt":"","text":"ES6-学习之路-05用Proxy进行预处理在运行函数前初始化一些数据，在改变对象值后做一些善后处理。这些都算钩子函数，Proxy的存在就可以让我们给函数加上这样的钩子函数，你也可以理解为在执行方法前预处理一些代码。你可以简单的理解为他是函数或者对象的生命周期。 首先定义对象如下：12345678let obj = &#123; add: (val) =&gt; &#123; return val + 100 &#125;, name: &apos;I am du&apos;&#125;console.log(obj.add(10))console.log(obj.name) 声明proxy用new的方法对Proxy进行声明。可以看一下声明Proxy的基本形式。new Proxy（{},{}） 以下是定义proxy的完整代码：12345678910111213/** 定义proxy*/let pro = new Proxy(&#123; add: (val) =&gt; &#123; return val + 100 &#125;, name: &apos;I am du&apos;&#125;, &#123; get: (target, key, property) =&gt; &#123; console.log(&apos;before get&apos;) return target[key] &#125;&#125;)console.log(pro.name) get属性 target：得到的目标值 key：目标的key值，相当于对象的属性 property：这个不太常用，用法还在研究中，还请大神指教。 set属性set属性是值你要改变Proxy属性值时，进行的预先处理。它接收四个参数： target:目标值。 key：目标的Key值。 value：要改变的值。 receiver：改变前的原始值。 123456789101112131415161718192021222324252627let pro = new Proxy(&#123; add: (val) =&gt; &#123; return val + 100 &#125;, name: &apos;I am du&apos;&#125;, &#123; get: (target, key, property) =&gt; &#123; console.log(&apos;before get&apos;) return target[key] &#125;, set: (target, key, value, receiver) =&gt; &#123; console.log(`$&#123;receiver[key]&#125;=&gt;$&#123;value&#125; `) return target[key] = value &#125;&#125;)console.log(pro.name)pro.name = &apos;ming&apos;console.log(pro.name)输出如下：before getproxy.js:28 I am duproxy.js:20 before getproxy.js:24 I am du=&gt;ming proxy.js:20 before getproxy.js:30 ming applyapply的作用是调用内部的方法，它使用在方法体是一个匿名函数。12345678910111213let target = function() &#123; return &apos;I am test&apos;;&#125;;var handler = &#123; apply(target, ctx, args) &#123; console.log(&apos;do apply&apos;); return Reflect.apply(...arguments); &#125;&#125;var pro2 = new Proxy(target, handler);console.log(pro2()); promise使用ES6中的promise的出现给我们很好的解决了回调地狱的问题，在使用ES5的时候，在多层嵌套回调时，写完的代码层次过多，很难进行维护和二次开发，ES6认识到了这点问题，现在promise的使用，完美解决了这个问题。那我们如何理解promise这个单词在ES5中的作用那，你可以想象他是一种承诺，当它成功时执行一些代码，当它失败时执行一些代码,更符合人类的行为思考习惯。 promise的基本用法promise执行多步操作非常好用，那我们就来模仿一个多步操作的过程，那就以吃饭为例吧。要想在家吃顿饭，是要经过三个步骤： 洗菜做饭。 坐下来吃饭。 收拾桌子洗碗。这个过程是有一定的顺序的，你必须保证上一步完成，才能顺利进行下一步，现在用promise来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142/**promise的使用 */let state = 1;function step1(resolve, reject) &#123; console.log(&apos;1.开始-洗菜做饭&apos;); if (state == 1) &#123; resolve(&apos;洗菜做饭--完成&apos;); &#125; else &#123; reject(&apos;洗菜做饭--出错&apos;); &#125;&#125;function step2(resolve, reject) &#123; console.log(&apos;2.开始-坐下来吃饭&apos;); if (state == 1) &#123; resolve(&apos;坐下来吃饭--完成&apos;); &#125; else &#123; reject(&apos;坐下来吃饭--出错&apos;); &#125;&#125;function step3(resolve, reject) &#123; console.log(&apos;3.开始-收拾桌子洗完&apos;); if (state == 1) &#123; resolve(&apos;收拾桌子洗完--完成&apos;); &#125; else &#123; reject(&apos;收拾桌子洗完--出错&apos;); &#125;&#125;new Promise(step1).then(function(val) &#123; console.log(val); return new Promise(step2);&#125;).then(function(val) &#123; console.log(val); return new Promise(step3);&#125;).then(function(val) &#123; console.log(val); return val;&#125;); 上面示例代码中，resolve 和 reject是两个函数变量，resole函数在Promise对象执行成功的时候触发，reject函数则在Promise对象执行失败的时候触发，Promise实际上就是前面说过的Proxy。 class类的使用class的定义见如下代码：12345678class Code &#123; name(val) &#123; console.log(val) &#125;&#125;let code = new Codecode.name(&apos;duduming&apos;)console.log(code.name) class类内多函数互相调用：123456789101112class Code &#123; name(val) &#123; console.log(val) return val &#125; anthorM(val) &#123; console.log(this.name(&apos;test&apos;) + &apos; another method&apos; + val) &#125;&#125;let code = new Code //code.name(&apos;duduming&apos;)code.anthorM(&apos;ano&apos;) 类的构造函数：通过constructor构造函数，向class内传参，然后在class内的方法中使用参数。12345678910111213141516171819class Code &#123; name(val) &#123; console.log(val) return val &#125; anthorM(val) &#123; console.log(this.name(&apos;test&apos;) + &apos; another method&apos; + val) &#125; add() &#123; return this.a + this.b &#125; constructor(a, b) &#123; this.a = a this.b = b &#125;&#125;let code = new Code(3, 4) //code.name(&apos;duduming&apos;)console.log(code.add()) class的继承,通过extends关键字。123456789101112131415161718192021222324class Code &#123; name(val) &#123; console.log(val) return val &#125; anthorM(val) &#123; console.log(this.name(&apos;test&apos;) + &apos; another method&apos; + val) &#125; add() &#123; return this.a + this.b &#125; constructor(a, b) &#123; this.a = a this.b = b &#125;&#125;class SonCode extends Code &#123;&#125;let sonCode = new SonCode(3, 4) //code.name(&apos;duduming&apos;)console.log(sonCode.add(4, 5)) 模块化exportexport可以让我们把变量，函数，对象进行模块话，提供外部调用接口，让外部进行引用。先来看个最简单的例子，把一个变量模块化。我们新建一个temp.js文件，然后在文件中输出一个模块变量。 export default的使用加上default相当是一个默认的入口。在一个文件里export default只能有一个。我们来对比一下export和export default的区别 export12345export var a =&apos;jspang&apos;; export function add(a,b)&#123; return a+b;&#125; 对应的引入方法：12345export var a =&apos;jspang&apos;; export function add(a,b)&#123; return a+b;&#125; export default1export default var a=&apos;jspang&apos; 对应引入方式1import str from &apos;./temp&apos;; 参考链接技术胖blog","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路04","slug":"2018-05-02-ES6学习之路04","date":"2018-05-02T00:51:46.193Z","updated":"2018-05-02T01:55:56.755Z","comments":true,"path":"2018/05/02/2018-05-02-ES6学习之路04/","link":"","permalink":"http://yoursite.com/2018/05/02/2018-05-02-ES6学习之路04/","excerpt":"","text":"ES6-学习之路-04对象key值构建有时候我们会在后台定义key值，而不是我们前台定义好的，这时候我们如何构建我们的key值。比如我们在后台取了一个key值，然后可以用[ ] 的形式，进行对象的构建。123456/**key值构建 */let key = &apos;name&apos;let obj = &#123; [key]: &apos;duming&apos;&#125;console.log(obj[&apos;name&apos;]) 自定义对象方法对象方法就是把兑现中的属性，用匿名函数的形式编程方法。1234567/**自定义对象方法 */let objFun = &#123; add: (a, b) =&gt; &#123; return a + b &#125;&#125;console.log(objFun.add(3, 4)) Object.is( ) 对象比较对象的比较方法,以前进行对象值的比较，经常使用===来判断，比如下面的代码：123456789 /**对象比较 */let obj1 = &#123; name: &apos;duming&apos; &#125;let obj2 = &#123; name: &apos;duming&apos; &#125;console.log(obj1.name === obj2.name)console.log(Object.is(obj1.name, obj2.name))console.log(Object.is(obj1, obj2)) /** * output: true true false */ ====表示值相等，Object.is()表示严格相等。 Object.assign( )合并对象123456789 /**合并对象 */let obja1 = &#123; tel: &apos;187&apos; &#125;let obja2 = &#123; address: &apos;js&apos; &#125;let obja3 = &#123; age: &apos;20&apos; &#125;let objA = Object.assign(obja1, obja2, obja3)console.log(objA) /** * &#123;tel: &quot;187&quot;, address: &quot;js&quot;, age: &quot;20&quot;&#125; */ Set和WeakSet数据结构首先看set的声明12let setdemo1 = new Set([&apos;apple&apos;, &apos;pear&apos;])console.log(setdemo1) Set和Array 的区别是Set不允许内部有重复的值，如果有只显示一个，相当于去重。虽然Set很像数组，但是他不是数组。增删改查示例代码：1234567891011121314151617181920212223/**set的声明 */let setdemo = new Set([&apos;apple&apos;, &apos;pear&apos;])console.log(setdemo) /** * Set(2) &#123;&quot;apple&quot;, &quot;pear&quot;&#125; */ /**set的增删改查 */setdemo.add(&apos;orange&apos;)setdemo.delete(&apos;apple&apos;)console.log(setdemo.has(&apos;apple&apos;))console.log(setdemo.has(&apos;pear&apos;))/**循环 foreach*/setdemo.forEach(item =&gt; &#123; console.log(item)&#125;)/** * 输出 * falsepearorang */ WeakSet跟Set相比，WeakSet的特点如下： 作为Object的容器，而不是简单类型 WeakSet中的对象如果没有其他地方引用，会被垃圾回收吸收掉。12345678910111213/**WeakSet */var ws = new WeakSet();var windows = &#123;&#125;;var foo = &#123;&#125;;ws.add(windows);ws.has(windows); // truews.has(foo); // false, foo has not been added to the setws.delete(windows); // removes window from the setws.has(windows); // false, window has been removed Map数据结构在一些构建工具中是非常喜欢使用map这种数据结构来进行配置的，因为map是一种灵活，简单的适合一对一查找的数据结构。我们知道的数据结构，已经有了json和set。那map有什么特点。123456789101112131415161718let json = &#123; name: &apos;du&apos;, age: 20&#125;console.log(json)/**map数据结构 */let map1 = new Mapmap1.set(&apos;name&apos;, &apos;du2&apos;)map1.set(&apos;age&apos;, 20)map1.set(&apos;json&apos;, json)console.log(map1)/** * 输出 * &#123;name: &quot;du&quot;, age: 20&#125;Map(3) &#123;&quot;name&quot; =&gt; &quot;du2&quot;, &quot;age&quot; =&gt; 20, &quot;json&quot; =&gt; &#123;…&#125;&#125; */ Map增删改查map的增删改查语句如下：12345map1.delete(&apos;json&apos;)map1.forEach(item =&gt; &#123; console.log(item)&#125;)console.log(map1.get(&apos;json&apos;)) 参考链接技术胖老师blog","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"nodejs学习之路01-异步调用与net fs核心类库","slug":"2018-05-01-nodejs学习之路01","date":"2018-05-01T08:00:18.686Z","updated":"2018-05-01T08:11:05.404Z","comments":true,"path":"2018/05/01/2018-05-01-nodejs学习之路01/","link":"","permalink":"http://yoursite.com/2018/05/01/2018-05-01-nodejs学习之路01/","excerpt":"","text":"nodejs学习之路01本文github地址 https://github.com/dumingcode/nodejs-demo.git 异步调用实例123456789console.log(&quot;Hello&quot;);setTimeout(() =&gt; &#123; console.log(&quot;World&quot;) &#125;, 5000)console.log(&quot;非阻塞&quot;);output:node src\\demo01.js Hello非阻塞World 如上例所示setTimeOut是非阻塞的，程序没有等待而是直接执行了打印非阻塞信息，nodejs一切调用都是异步的。 单线程1234567891011121314151617/**单线程示例 */let start = new Date()console.log(start)setTimeout(() =&gt; &#123; console.log(Date.now() - start.getTime()) for (let i = 0; i &lt; 100000000000; i++) &#123;&#125;&#125;, 1000)setTimeout(() =&gt; &#123; console.log(Date.now() - start.getTime())&#125;, 2000)output:node src\\singleThread.js 2018-04-30T07:03:54.402Z1009160788 可以看到第二个setTimeOut的执行时间为160788秒，这是一个非常大的数字。 Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况： 如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用； 如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件上述代码就是因为是非IO任务，所以耗费了主进程计算时间，使主进程无法执行事件循环，所以nodejs不适合执行CPU计算密集型任务。单线程总结 nodejs单线程是针对图中的Event Loop，事件循环运行在主线程中。换言之nodejs接收任务请求是单线程的。 nodejs在具体执行IO任务的时候是多线程方式，在Async I/O队列中执行。 错误处理12345678910111213141516171819var http = require(&quot;http&quot;)http.createServer(() =&gt; &#123; throw new Error(&quot;错误不会被捕获&quot;)&#125;).listen(3000)输出如下：node src\\err.js d:\\Workspaces\\nodejs-demo\\src\\err.js:4 throw new Error(&quot;错误不会被捕获&quot;) ^Error: 错误不会被捕获 at Server.http.createServer (d:\\Workspaces\\nodejs-demo\\src\\err.js:4:11) at emitTwo (events.js:126:13) at Server.emit (events.js:214:7) at parserOnIncoming (_http_server.js:602:12) at HTTPParser.parserOnHeadersComplete (_http_common.js:116:23) nodejs在发生未被捕获的进程后，进程的状态就不确定了，无法正常工作。下一步添加uncaughtException函数1234567891011var http = require(&quot;http&quot;)http.createServer(() =&gt; &#123; throw new Error(&quot;错误不会被捕获&quot;)&#125;).listen(3000)process.on(&apos;uncaughtException&apos;, (err) =&gt; &#123; console.log(err) process.exit(1)&#125;) 绝大多数异步API回调函数的第一个参数都是err对象或者null。 Node中的js下面主要介绍一些nodejs的核心类库。 global任何global上的属性都可以被全局访问到。 process所有全局执行的上下文都在process中。 nodejs模块模块系统有三个全局的变量，require、module、exports。 绝对模块和相对模块绝对模块指node在node_modules内部查找的模块，或者node内置的比如fs这样的模块。相对模块是require指向工作目录中的js文件。相对模块引用示例require &#39;./moduleA&#39;。 暴露API要让模块暴露一个API成为require调用的返回值，需要依靠module和require的返回值。moduleA.js:123456exports.name = &apos;John&apos;exports.data = &apos;This is module demo&apos;let privateData = 5exports.getPriData = () =&gt; &#123; return privateData&#125; moduleDemo.js代码如下：1234var moduleA = require(&apos;./module_a&apos;)console.log(moduleA.data)console.log(moduleA.name)console.log(moduleA.getPriData()) Nodejs重要API本部分通过定义一个需求来实现： 程序启动后，需要显示当前目录下的文件列表。 选择某个文件后，程序需要显示文件内容。 选择一个目录时，程序需要显示当前目录下的内容。 运行结束后程序退出。程序设计： 创建模块 决定使用同步fs还是异步fs 理解什么是流 实现输入输出 重构 使用fs进行文件交互 完成创建模块创建名为 file-explorer的项目目录，创建一个简单的package.json文件。12345&#123; &quot;name&quot;: &quot;file-explorer&quot;, &quot;version&quot;: &quot;0.01&quot;, &quot;description&quot;: &quot;a command file-explorer&quot;&#125; 同步还是异步需要首先引入fs，fs模块是nodejs中唯一既提供同步又提供异步方法的API，为了体现nodejs异步的特性，决定使用异步方式。1234var fs = require(&apos;fs&apos;)fs.readdir(__dirname, (err, files) =&gt; &#123; console.log(files)&#125;) 示例代码V1版本如下：1234567891011121314151617181920212223242526272829var fs = require(&apos;fs&apos;)fs.readdir(__dirname, (err, files) =&gt; &#123; console.log(&apos;&apos;) if (!files.length) &#123; return console.log(&quot;no file!&quot;) &#125; console.log(&quot;select which dir or file you want to see\\n&quot;) let filefunc = (i) =&gt; &#123; let filename = files[i] //if (filename.startsWith(&quot;.&quot;)) return fs.stat(__dirname + &apos;/&apos; + filename, (err, stats) =&gt; &#123; if (stats.isDirectory()) &#123; console.log(`dir is ` + filename) &#125; else &#123; console.log(`file is ` + filename) &#125; &#125;); i++ if (i == files.length) &#123; console.log(&apos;&apos;) process.stdout.write(&apos;Enter your choice\\n&apos;) process.stdin.resume() &#125; else &#123; filefunc(i) &#125; &#125; filefunc(0)&#125;) TCP本章示例，基于TCP的聊天程序： 成功连接到server后会返回欢迎消息，server要求client输入用户名，并告知当前有多少用户方位 输入用户名，按下回车键人为链接成功 链接成功后，可以向其他用户输入消息V1版本如下:123456789101112131415161718var net = require(&apos;net&apos;)var server = net.createServer((c =&gt; &#123; console.log(`new client $&#123;c.localAddress&#125;`) c.on(&apos;end&apos;, () =&gt; &#123; console.log(&apos;client disconnected&apos;); &#125;); c.write(&apos;hello\\r\\n&apos;); c.pipe(c);&#125;))server.listen(3000, () =&gt; &#123; console.log(&apos;server bound&apos;);&#125;)server.on(&apos;error&apos;, (err) =&gt; &#123; throw err;&#125;) 聊天程序优化 增加当前已连接客户计数器 当有新客户输入昵称时，判断当前是否有重名用户，若无重名用户，则将新客户的信息通知到其余客户。 当有客户退出时，清除存储结构，并通知其他客户。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var net = require(&apos;net&apos;)var conCount = 0, users = &#123;&#125;var server = net.createServer((c =&gt; &#123; var nickname console.log(`new client $&#123;c.localAddress&#125;`) c.setDefaultEncoding(&apos;utf8&apos;) c.write(&apos;hello\\r\\n&apos;); c.write(`$&#123;++conCount&#125; guests\\r\\n please write your name\\r\\n`) c.pipe(c); c.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;client disconnected&apos;); conCount-- delete users[nickname] for (key in users) &#123; users[key].write(`$&#123;nickname&#125; left out game!\\r\\n当前用户数目$&#123;conCount&#125;\\r\\n`) &#125; &#125;) c.on(&apos;data&apos;, (data) =&gt; &#123; let buf = data.toString(&apos;utf8&apos;).replace(&apos;\\r\\n&apos;, &apos;&apos;) if (buf == &apos;&apos;) return if (!nickname) &#123; if (users[buf]) &#123; c.write(`$&#123;nickname&#125; is used,please input again \\r\\n`) &#125; else &#123; nickname = buf users[nickname] = c for (key in users) &#123; users[key].write(`$&#123;nickname&#125; has joined our game\\r\\n`) &#125; &#125; &#125; &#125;)&#125;))server.listen(3000, () =&gt; &#123; console.log(&apos;server bound&apos;);&#125;)server.on(&apos;error&apos;, (err) =&gt; &#123; throw err;&#125;) users 对象存储每一个用户的链接，在每一个链接内增加nickname属性。上述代码，所有的链接共享当前链接数和user对象，任何一个链接改了这两个变量，都会对其他的链接产生影响。 参考链接i5ting大神《了不起的nodejs》","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"docker学习笔记03-Dockerfile指令详解","slug":"2018-04-30-docker学习笔记03","date":"2018-04-30T02:25:10.069Z","updated":"2018-04-30T02:25:44.904Z","comments":true,"path":"2018/04/30/2018-04-30-docker学习笔记03/","link":"","permalink":"http://yoursite.com/2018/04/30/2018-04-30-docker学习笔记03/","excerpt":"","text":"docker学习笔记03-Dockerfile指令详解COPY复制文件命令格式如下： COPY &lt;源路径&gt;… &lt;目标路径&gt; COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如： 1COPY package.json /usr/src/app/ &lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：12COPY hom* /mydir/COPY hom?.txt /mydir/ &lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 CMD容器启动命令CMD 指令的格式和 RUN 相似，也是两种格式： shell 格式： CMD &lt;命令&gt; exec 格式： CMD [“可执行文件”, “参数1”, “参数2”…]之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。 CMD 指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如， ubuntu 镜像默认的CMD 是 /bin/bash ，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash 。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release 。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “ ，而不要使用单引号。 提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。一些初学者将 CMD 写为：1CMD service nginx start 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginxstart”] ，因此主进程实际上是 sh 。那么当 service nginx start 命令结束后， sh 也就结束了， sh 作为主进程退出了，自然就会令容器退出。 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：1CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] ENTRYPOINT 入口点ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。 ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。 当指定了 ENTRYPOINT 后， CMD 的含义就发生了改变，不再是直接的运行其命令，而是将CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：1&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 场景一：让镜像变成像命令一样使用假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：12345FROM ubuntu:16.04RUN apt-get update \\&amp;&amp; apt-get install -y curl \\&amp;&amp; rm -rf /var/lib/apt/lists/*CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ] 假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：12[docker@iz2ze1fd7d8ota0f9ysaazz myubuntu]$ docker run myip当前 IP：39.107.119.46 来自：广东省深圳市 阿里云 这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl ，那么如果我们希望显示 HTTP头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？123[docker@iz2ze1fd7d8ota0f9ysaazz myubuntu]$ docker run myip -idocker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \\&quot;-i\\&quot;: executable file not found in $PATH&quot;: unknown.[docker@iz2ze1fd7d8ota0f9ysaazz myubuntu]$ 我们可以看到可执行文件找不到的报错， executable file not found 。之前我们说过，跟在镜像名后面的是 command ，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的CMD ，而不是添加在原来的 curl -s http://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：1docker run myip curl -s http://ip.cn -i 这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用ENTRYPOINT 来实现这个镜像：12345FROM ubuntu:16.04RUN apt-get update \\&amp;&amp; apt-get install -y curl \\&amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ] 重新build然后再次运行docker run myip -t可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后， CMD 的内容将会作为参数传给ENTRYPOINT ，而这里 -i 就是新的 CMD ，因此会作为参数传给 curl ，从而达到了我们预期的效果。 场景二：应用运行前的准备工作启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的mysql 服务器运行之前解决。 此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。 这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 ）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：1234567FROM alpine:3.4...RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis...ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]EXPOSE 6379CMD [ &quot;redis-server&quot; ] ENV 设置环境变量格式有两种： ENV ENV = =…这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN ，还是运行时的应用，都可以直接使用这里定义的环境变量。 12ENV VERSION=1.0 DEBUG=on \\NAME=&quot;Happy Feet&quot; ARG 构建参数构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是， ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build 中用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。 VOLUME 定义匿名卷格式为： VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…] VOLUME &lt;路径&gt;之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 1VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：1docker run -d -v mydata:/data xxxx 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了Dockerfile 中定义的匿名卷的挂载配置。 EXPOSE 声明端口格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。要将 EXPOSE 和在运格式为 WORKDIR &lt;工作目录路径&gt;行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。 -p ，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR 指定工作目录格式为 WORKDIR &lt;工作目录路径&gt;使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在， WORKDIR 会帮你建立目录。 之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：12RUN cd /appRUN echo &quot;hello&quot; &gt; world.txt 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello 。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。 之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUNcd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。 USER 指定当前用户格式： USER &lt;用户名&gt;USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。 WORKDIR 是改变工作目录， USER 则是改变之后层的执行 RUN , CMD 以及 ENTRYPOINT 这类命令的身份。 当然，和 WORKDIR 一样， USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。 123RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [ &quot;redis-server&quot; ] 如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo ，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu 。123456789# 建立 redis 用户，并使用 gosu 换另一个用户执行命令RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis# 下载 gosuRUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \\&amp;&amp; chmod +x /usr/local/bin/gosu \\&amp;&amp; gosu nobody true# 设置 CMD，并以另外的用户执行CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ] HEALTHCHECK 健康检查格式： HEALTHCHECK [选项] CMD &lt;命令&gt; ：设置检查容器健康状况的命令 HEALTHCHECK NONE ：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12引入的新指令。 HEALTHCHECK 支持下列选项： –interval=&lt;间隔&gt; ：两次健康检查的间隔，默认为 30 秒； –timeout=&lt;时长&gt; ：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； –retries=&lt;次数&gt; ：当连续失败指定次数后，则将容器状态视为 unhealthy ，默认 3次。 和 CMD , ENTRYPOINT 一样， HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写：1234FROM nginxRUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s \\CMD curl -fs http://localhost/ || exit 1 这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit1 作为健康检查命令。使用 docker build 来构建这个镜像：1docker build -t myweb:v1 . 构建好了后，我们启动一个容器：1docker run -d --name web -p 82:80 myweb:v1 执行docker container ls:123[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6519b8beac6f myweb:v1 &quot;nginx -g &apos;daemon of…&quot; 23 seconds ago Up 22 seconds (healthy) 0.0.0.0:82-&gt;80/tcp web ONBUILD 为他人做嫁衣裳格式： ONBUILD &lt;其它指令&gt;ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN , COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile ：1234567FROM node:slimRUN mkdir /appWORKDIR /appCOPY ./package.json /appRUN [ &quot;npm&quot;, &quot;install&quot; ]COPY . /app/CMD [ &quot;npm&quot;, &quot;start&quot; ] 把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。 如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile ，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile ，而第二个项目的 Dockerfile 就会被自动修复。 那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为：1234567FROM node:slimRUN mkdir /appWORKDIR /appONBUILD COPY ./package.json /appONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]ONBUILD COPY . /app/CMD [ &quot;npm&quot;, &quot;start&quot; ] 这次我们回到原始的 Dockerfile ，但是这次将项目相关的指令加上 ONBUILD ，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：1FROM my-node 是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install ，生成应用镜像。 参考dockerFile最佳实践github yeasy/docker_practice","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"指数基金投资指南-银行螺丝钉","slug":"2018-04-29-指数基金投资指南","date":"2018-04-29T03:22:55.290Z","updated":"2018-04-29T03:50:41.825Z","comments":true,"path":"2018/04/29/2018-04-29-指数基金投资指南/","link":"","permalink":"http://yoursite.com/2018/04/29/2018-04-29-指数基金投资指南/","excerpt":"","text":"指数基金投资指南-银行螺丝钉利用一天时间翻了下螺丝钉写的《指数基金投资指南》，还是挺有收获的，下面重点写下这本书提到的指数估值方法。 指数估值-盈利收益率法该方法是格林厄姆提出的，在盈利收益率高的时候开始定投，在盈利收益率低的时候结束甚至止盈。盈利收益率多高算高？格林厄姆认为满足如下两个条件即为高。 盈利收益率要大于10 盈利收益率要大幅高于同期无风险利率 回到中国市场，当盈利收益率大于10坚持定投，盈利收益率小于6.4%时，结束定投（或者止盈分批卖出）。为何是6.4%，因为6.4%是中国债券基金的长期收益率，低于6.4%了不如投资债券了。 盈利收益率法使用条件 成分股流通性好 成分股盈利稳定盈利收益率法适用的指数 上证红利、中证红利、 上证50、基本面50、上证50AH优选、央视50 恒生指数、国企指数 指数估值-博格公式法影响指数基金收益的三大因素 初始投资时刻的股息率 投资期内的市盈率变化 投资期内的盈利增长率 指数基金未来的年复合收益率等于投资初期股息率+指数基金每年的市盈率变化率（可正可负）+指数基金每年的盈利变化率。注：平均到每年的变化率和收益率。 博格公式法如何实践三个因素中，可以确定的因素有两个：（1）股息率（2）当前市盈率所处历史波动中的位置。无法确定的只有一个：未来盈利的增速。根据已知因素，可以做到如下三点： 股息率高的时候买入 市盈率处于较低位置处买入 买入之后，耐心等待均值回归，等待市盈率从低到高。 博格公式法适用指数 沪深300、中证500、创业板 红利机会、消费行业、医药、养老产业指数 指数估值-博格公式变种针对周期行业，盈利E的变化很大已经失去了比较意义，此时我们引入PB对指数进行分析。指数基金未来的年复合收益率 = 指数基金每年市净率的变化率 + 指数基金每年净资产的变化率 博格公式变种适合指数 证券行业、金融行业、非银金融行业、地产行业 定期不定额定投作为一个老韭菜，自认为心理抗波动能力还可以，所以重点记录下定期不定额定投。简单地说，就是跌的多买的多，跌的少买的少。 每期定投资金 = 1000元 【n （当期盈利收益率） / （基准盈利收益率 10%）】。n相当于一个放大器，根据自身随意调节。举例子，比如当前盈利收益率是11.2% ， n=1，则本月投入资金为：1000 1（11.2/10）=1120元。 上面这个公司对博格公式法也适用，博格公式变种法用PB代替PE。 思维导图总结 点击查看大图](http://blog.buyasset.club/images/fund.svg","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"docker学习笔记02-镜像","slug":"2018-04-28-docker学习笔记02","date":"2018-04-28T13:26:42.885Z","updated":"2018-04-29T02:15:42.527Z","comments":true,"path":"2018/04/28/2018-04-28-docker学习笔记02/","link":"","permalink":"http://yoursite.com/2018/04/28/2018-04-28-docker学习笔记02/","excerpt":"","text":"docker学习笔记02-镜像Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。 获取镜像从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 DockerHub。仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt; 。对于 DockerHub，如果不给出用户名，则默认为 library ，也就是官方镜像。123456789docker pull ubuntu:16.0416.04: Pulling from library/ubuntu297061f60c36: Pull complete e9ccef17b516: Pull complete dbc33716854d: Pull complete 8fe36b178d25: Pull complete 686596545a94: Pull complete Digest: sha256:15f721c027e007887ba6cb071a65628c81122cb2b406e341d07cf2c180f7d759Status: Downloaded newer image for ubuntu:16.04 从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的sha256的摘要，以确保下载一致性。 运行image有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的ubuntu:16.04为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。123456789101112131415161718docker run -it --rm \\ubuntu:16.04 \\bash[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker run -it --rm \\&gt; ubuntu:16.04 \\&gt; bashroot@aee0271f7ebc:/# cat /etc/os-releaseNAME=&quot;Ubuntu&quot;VERSION=&quot;16.04.4 LTS (Xenial Xerus)&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 16.04.4 LTS&quot;VERSION_ID=&quot;16.04&quot;HOME_URL=&quot;http://www.ubuntu.com/&quot;SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;VERSION_CODENAME=xenialUBUNTU_CODENAME=xenial docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。 -it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们这里打算进入bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 –rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。 ubuntu:16.04 ：这是指用 ubuntu:16.04 镜像为基础来启动容器。 bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 。 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release ，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。最后我们通过 exit 退出了这个容器。 列出镜像要想列出已经下载下来的镜像，可以使用 docker image ls 命令。1234[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 16.04 0b1edfbffd27 4 hours ago 113MBhello-world latest e38bc07ac18e 2 weeks ago 1.85kB 可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间123456[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker system dfTYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 2 1 113MB 113MB (99%)Containers 1 0 0B 0BLocal Volumes 0 0 0B 0BBuild Cache 0B 0B 中间层镜像为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 删除本地镜像如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：12345678910[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker image rm 0b1edfbffd27Untagged: ubuntu:16.04Untagged: ubuntu@sha256:15f721c027e007887ba6cb071a65628c81122cb2b406e341d07cf2c180f7d759Deleted: sha256:0b1edfbffd27c935a666e233a0042ed634205f6f754dbe20769a60369c614f85Deleted: sha256:a606d2db36205a11036adff8d9556e7180c26639eede2466a128d0de9b3e1b2dDeleted: sha256:fc07fc8491e0f830ebdd30de1c1b683cb2456051d17401351948ed34fe64d4afDeleted: sha256:9ddf57d8cd7fe42a9c547584549ede3dac5990b4c78ddec319ffae2cde20a496Deleted: sha256:349f8ed4d525976a9549088aa1979bc36a79f8209f89024c3cd127399914f46bDeleted: sha256:c8aa3ff3c3d351787cc5f84d960870fad16c9615aab7aa47ab343906fc8cfc24[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ 用 docker image ls 命令来配合删除所有仓库名为 redis 的镜像1docker image rm $(docker image ls -q redis) 使用docker file定制镜像镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。这个脚本就叫做Dockerfile。 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为 Dockerfile ：123$ mkdir mynginx$ cd mynginx$ touch Dockerfile 其内容为:12FROM nginxRUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令， FROM 和 RUN 。 FROM 指定基础镜像所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如nginx 、 redis 、 mongo 、 mysql 、 httpd 、 php 、 tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node 、 openjdk 、 python 、 ruby 、 golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如ubuntu 、 debian 、 centos 、 fedora 、 alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch 。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。使用 Dockerfile 定制镜像。 RUN 执行命令RUN 指令是用来执行命令行命令的。由于命令行的强大能力， RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式： RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 exec 格式： RUN [“可执行文件”, “参数1”, “参数2”] ，这更像是函数调用中的格式。既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：12345678FROM debian:jessieRUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install 上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。正确的写法应该是这样：12345678910111213FROM debian:jessieRUN buildDeps=&apos;gcc libc6-dev make&apos; \\&amp;&amp; apt-get update \\&amp;&amp; apt-get install -y $buildDeps \\&amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \\&amp;&amp; mkdir -p /usr/src/redis \\&amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\&amp;&amp; make -C /usr/src/redis \\&amp;&amp; make -C /usr/src/redis install \\&amp;&amp; rm -rf /var/lib/apt/lists/* \\&amp;&amp; rm redis.tar.gz \\&amp;&amp; rm -r /usr/src/redis \\&amp;&amp; apt-get purge -y --auto-remove $buildDeps 构建镜像进入之前创建的 Dockerfile所在目录 12345678910111213141516[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048kBStep 1/2 : FROM nginxlatest: Pulling from library/nginx2a72cbf407d6: Pull complete 04b2d3302d48: Pull complete e7f619103861: Pull complete Digest: sha256:18156dcd747677b03968621b2729d46021ce83a5bc15118e5bcced925fb4ebb9Status: Downloaded newer image for nginx:latest ---&gt; b175e7467d66Step 2/2 : RUN echo Hello, Docker! &gt; /usr/share/nginx/html/index.html ---&gt; Running in 332935fd6a32Removing intermediate container 332935fd6a32 ---&gt; c08e23705638Successfully built c08e23705638Successfully tagged nginx:v3 运行nginx:v3镜像 12345678910111213141516171819202122232425262728docker run --name web2 -d -p 81:80 nginx:v3[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker run --name web2 -d -p 81:80 nginx:v372a659ee4374df18579dbe2a662ddc1927cfce5b507fe79a158409934e851aad 在shell中运行 links 127.0.0.1:81``` #### 镜像构建上下文（Context） 如果注意，会看到 docker build 命令最后有一个 . 。 . 表示当前目录，而 Dockerfile就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？ 首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 DockerRemote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当构建的时候，用户会指定构建镜像上下文的路径， dockerbuild 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： COPY ./package.json /app/`这并不是要复制执行 docker build 命令所在的目录下的 package.json ，也不是复制Dockerfile 所在目录下的 package.json ，而是复制 上下文（context） 目录下的package.json 。 因此， COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore ，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 参考链接github yeasy/docker_practice","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"docker学习笔记01-docker介绍与安装","slug":"2018-04-28-docker学习笔记01","date":"2018-04-28T13:19:05.569Z","updated":"2018-04-28T13:20:43.716Z","comments":true,"path":"2018/04/28/2018-04-28-docker学习笔记01/","link":"","permalink":"http://yoursite.com/2018/04/28/2018-04-28-docker学习笔记01/","excerpt":"","text":"docker学习笔记01-docker介绍与安装docker与VM区别首先上两张图，第一张是传统vm，第二张是docker。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于 系统支持量 单机上千容器 一般几十个 基本概念镜像ImageDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器Container镜像（ Image ）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学Docker时常常会混淆容器和虚拟机。前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 仓库Repository镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，DockerRegistry就是这样的服务。一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 以 Ubuntu 镜像为例，ubuntu是仓库的名字，其内包含有不同的版本标签，如，14.04,16.04。我们可以通过ubuntu:14.04 ，或者 ubuntu:16.04来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu ，那将视为 ubuntu:latest 。仓库名经常以 两段式路径形式出现，比如jwilder/nginx-proxy ，前者往往意味着DockerRegistry多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。 centos安装docker engine卸载旧版本12345678910yum remove docker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-selinux \\docker-engine-selinux \\docker-engine 使用脚本自动安装12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。 启动 Docker CE12345678910111213141516171819202122$ sudo systemctl enable docker$ sudo systemctl start docker[root@iz2ze1fd7d8ota0f9ysaazz ~]# docker versionClient: Version: 18.04.0-ce API version: 1.37 Go version: go1.9.4 Git commit: 3d479c0 Built: Tue Apr 10 18:21:36 2018 OS/Arch: linux/amd64 Experimental: false Orchestrator: swarmServer: Engine: Version: 18.04.0-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.4 Git commit: 3d479c0 Built: Tue Apr 10 18:25:25 2018 OS/Arch: linux/amd64 Experimental: false 建立 docker 用户组默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用root用户。因此，更好地做法是将需要使用 docker 的用户加入 docker用户组。 建立 docker 组用户groupadd dockeruseradd docker -g docker 将docker用户加入 docker 组usermod -aG docker docker 测试 Docker 是否安装正确1234567891011121314151617181920212223242526272829docker run hello-world[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-world9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 添加内核参数默认配置下，如果在CentOS使用DockerCE看到下面的这些警告信息：12WARNING: bridge-nf-call-iptables is disabledWARNING: bridge-nf-call-ip6tables is disabled 请添加内核配置参数以启用这些功能。1234$ sudo tee -a /etc/sysctl.conf &lt;&lt;-EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF 然后重新加载 sysctl.conf 即可sysctl -p重新执行docker info命令， 没有warning信息即可。 镜像加速鉴于国内网络问题，后续拉取Docker镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。对于centos7，请在/etc/docker/daemon.json中写入如下内容（如果文件不存在请新建该文件）。12345&#123;&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; 修改完毕后重启docker服务12$ sudo systemctl daemon-reload$ sudo systemctl restart docker 检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info ，如果从结果中看到了如下内容，说明配置成功。12Registry Mirrors: https://registry.docker-cn.com/ 参考链接github yeasy/docker_practice","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"我的常用git命令","slug":"2018-04-26-我的常用git命令","date":"2018-04-26T00:47:19.130Z","updated":"2018-04-28T01:21:29.948Z","comments":true,"path":"2018/04/26/2018-04-26-我的常用git命令/","link":"","permalink":"http://yoursite.com/2018/04/26/2018-04-26-我的常用git命令/","excerpt":"","text":"常用git命令回退到某次提交git reset –hard xxxxxxx好吧，这个如此rude的操作，放在第一条有点不协调。 push/pull 远程git clone xxx.git (本地目录)git push [远程名] [本地分支]:[远程分支]git pull [远程名] [本地分支]:[远程分支]从remote拉取一个新分支git checkout -b [本地分支] [远程名]/[远程分支]checkout的本地分支和远程分支名可以不一样 git loggit log –oneline –graph –decorate使用上面命令打印出来的日志，比较美观直观。 git rebase 需要注意的第一点，如果是执行git rebase master，此处的master实际上是本地的master 。 所以在执行git rebase 。 master之前，最好保证本地的master是最新的。 rebase适用的黄金法则：最好是本地的feature，不需要同步到remote的，这样安全性是最高的，不会对他人的commit造成混乱。因为rebase实际上是将master分支的commit，压到最前面。 rebase fix conflictrebase提示有冲突，可以按以下顺序解决： 修改程序代码，解决冲突。 git add fix后的代码文件 git rebase –continue 如果仍然有冲突继续解决，即重复1-3步骤，直至结束。 rebase –skip –abortgit rebase –skip 高风险操作，是将本次提交的代码删除掉（慎用）。git rebase –abort 将代码回退到 执行rebase之前的操作 查看远端分支git branch -a 冷冻当前dev分支修复bug软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交 12345678910111213$ git stash //冷冻现在在dev分支上的工作状态 冻结吧！ $ git checkout master //这个bug发生在master主分支上,我们切回master分支$ git checkout -b issue-101 //创建代号101的修复bug分支修改你的bug$ git add readme.txt //提交到暂存区$ git commit -m &quot;fix bug 101&quot; //注意填写信息，以免日后查证$ git checkout master //切换回master分支$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 //合并分支，注意不使用fast forward模式$ git branch -d issue-101 //删除issue-101分支$ git checkout dev //bug 改完了，是时候回到dev继续写bug了$ git stash list //查看刚刚的冻结现场$ git stash pop //git stash pop，恢复的同时把stash内容也删了：//一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 github上定期从目标仓库更新个人仓库1234git remote add upstream https://github.com/目标仓库/docker_practice$ git fetch upstream$ git rebase upstream/master$ git push -f origin master 参考链接掘金—bibi94","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"ES6学习之路-03","slug":"2018-04-25-ES6学习之路03","date":"2018-04-25T00:58:53.457Z","updated":"2018-04-25T00:59:32.052Z","comments":true,"path":"2018/04/25/2018-04-25-ES6学习之路03/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-25-ES6学习之路03/","excerpt":"","text":"ES6学习之路-03数组JSON数组格式转换JSON的数组格式就是为了前端快速的把JSON转换成数组的一种格式。1234567891011let json = &#123; &apos;0&apos;: &apos;test1&apos;, &apos;1&apos;: &apos;test2&apos;, &apos;2&apos;: &apos;test3&apos;, length: 3&#125;let arr = Array.from(json)console.log(arr)output:[&quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot;] 这就是一个标准的JSON数组格式，跟普通的JSON对比是在最后多了一个length属性。只要是这种特殊的json格式都可以轻松使用ES6的语法转变成数组。在ES6中绝大部分的Array操作都存在于Array对象里。我们就用Array.from(xxx)来进行转换。我们把上边的JSON代码转换成数组，并打印在控制台。 Array.of()方法它负责把一堆文本或者变量转换成数组。在开发中我们经常拿到了一个类似数组的字符串，需要使用eval来进行转换，d但是eval的效率是很低的，它会拖慢我们的程序。这时候我们就可以使用Array.of方法。我们看下边的代码把一堆数字转换成数组并打印在控制台上：12345678let arr2 = Array.of(3, 4, 5, 6)console.log(arr2)let arr3 = Array.of(&quot;1test&quot;, &quot;2test&quot;, &quot;3test&quot;)console.log(arr3)[3, 4, 5, 6][&quot;1test&quot;, &quot;2test&quot;, &quot;3test&quot;] find( )实例方法这里的find方法是从数组中查找。在find方法中我们需要传入一个匿名函数，函数需要传入三个参数： value：表示当前查找的值。 index：表示当前查找的数组索引。 arr：表示当前数组。在函数中如果找到符合条件的数组元素就进行return，并停止查找。你可以拷贝下边的代码进行测试，就会知道find作用。1234let arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr4.find(function(value, index, arr) &#123; return value &gt; 6;&#125;)) fill( )实例方法fill()也是一个实例方法，它的作用是把数组进行填充，它接收三个参数，第一个参数是填充的变量，第二个是开始填充的位置，第三个是填充到的位置。12345678let arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr4.find(function(value, index, arr) &#123; return value &gt; 6;&#125;))arr4.fill(&quot;es6&quot;, 3, 5)[1, 2, 3, &quot;es6&quot;, &quot;es6&quot;, 6, 7, 8, 9] 数组的遍历for…of循环先来一个最简单的for of循环1234let arr5 = [1, 2, 3, 4, 5, 6, 7, 8, 9];for (let item of arr5) &#123; console.log(item)&#125; for…of数组索引1234let arr5 = [1, 2, 3, 4, 5, 6, 7, 8, 9]for (let index of arr5.keys()) &#123; console.log(index)&#125; for…of 值和索引同时访问用entries()这个实例方法，配合我们的for…of循环就可以同时输出内容和索引了。123for (let [index, value] of arr4.entries()) &#123; console.log(index + &apos;:&apos; + value)&#125; entries()实例方式生成的是Iterator形式的数组，那这种形式的好处就是可以让我们在需要时用next()手动跳转到下一个值。 箭头函数和扩展默认值1234function add(a, b = 1) &#123; return a + b;&#125;console.log(add(1)); 主动抛出错误ES6中我们直接用throw new Error( xxxx ),就可以抛出错误。123456789/**函数抛出异常 */function addExp(a, b = 1) &#123; if (a == 0) &#123; throw new Error(&apos;This is error&apos;) &#125; return a + b;&#125;console.log(addExp(0));console.log(addExp.length); 注意上面代码最后一行，可以打印出函数的参数（必传参数）个数。 箭头函数感觉有点像java的lambda表达式，语言果然像融合的方向发展。12let add1 = (a, b = 1) =&gt; a + bconsole.log(add1(3, 4)) {}的使用括号右侧如果是两句话，就需要使用{}。12345let add2 = (a, b = 1) =&gt; &#123; console.log(&quot;function&quot;) return a + b&#125;console.log(add2(6, 7)) 箭头函数中不可加new，也就是说箭头函数不能当构造函数进行使用。 对象的函数解构在前后端分离时，后端经常返回来JSON格式的数据，前端的美好愿望是直接把这个JSON格式数据当作参数，传递到函数内部进行处理。ES6就为我们提供了这样的解构赋值。123456let json = &#123; a: &apos;es6&apos;, b: &apos;study&apos;&#125;let foo = (&#123; a, b = &apos;study&apos; &#125;) =&gt; console.log(a, b)foo(json) in的用法in是用来判断对象或者数组中是否存在某个值的。我们先来看一下用in如何判断对象里是否有某个值。 对象判断12345let ajson = &#123; a: &apos;es6&apos;, b: &apos;study&apos;&#125;console.log(&apos;a&apos; in ajson); //true 数组判断先来看一下ES5判断的弊端，以前会使用length属性进行判断，为0表示没有数组元素。但是这并不准确，或者说真实开发中有弊端。1234/**in的用法 判断数组是否为空 */let arr11 = [, , , , , ];console.log(arr11.length); //5console.log(0 in arr11); //false 数组的遍历方法下面的代码包含了forEach，filter,some，map，这四个方法的参数本质上也是个函数，函数参数使用了匿名箭头函数。1234567891011/**数组循环 */let arrs = [&quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w5&quot;]arrs.forEach((value, index) =&gt; console.log(index + &quot;:&quot; + value))arrs.filter(x =&gt; console.log(x))arrs.some(x =&gt; console.log(x))let arrs1 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]arrs1.map(x =&gt; &#123; &apos;web&apos;; console.log(x)&#125;) 数组转换字符串 join()方法 12let arrs22 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]console.log(arrs22.join(&apos;|&apos;)); toString方法 123let arrs22 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]console.log(arrs22.join(&apos;|&apos;));console.log(arrs22.toString()); 参考链接技术胖老师es6学习blog","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路-02","slug":"2018-04-24-ES6学习之路02","date":"2018-04-25T00:58:08.074Z","updated":"2018-04-25T00:58:47.726Z","comments":true,"path":"2018/04/25/2018-04-24-ES6学习之路02/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-24-ES6学习之路02/","excerpt":"","text":"ES6学习之路-02ES6声明变量的方式var方式var在ES6里是用来升级全局变量的，我们可以先作一个最简单的实例，用var声明一个变量a,然后用console.log进行输出。如何理解它的作用是声明全局变量那？我们用匿名函数给他进行一个包裹，然后在匿名函数中调用这个a变量，看看能不能调用到。12345var a=2;&#123; var a=3;&#125;console.log(a); 上述代码打印出3，可见var 声明变量的范围是全局的。 let方式通过上面简单的例子，我们对var的全局声明有了一定了解。那跟var向对应的是let，它是局部变量声明。还是上面的例子，我们试着在区块里用let声明。1234let a = 2; &#123; let a = 3;&#125;console.log(a); babel转换成es5的文件内容为：1234var a = 2;&#123; var _a = 3;&#125;console.log(a); let的作用范围et声明只在区块内起作用，外部是不可以调用的。下面的代码执行时会报错。1234&#123; let a=3;&#125;console.log(a); let的作用是防止数据污染，在一个大型的项目中，使用let安全性会非常高。 const方式在程序开发中，有些变量是希望声明后在业务层就不再发生变化了，简单来说就是从声明开始，这个变量始终不变，就需要用const进行声明。123const a = &quot;JSPang&quot;;var a = &apos;技术胖&apos;;console.log(a); 上面的代码编译阶段就报错了，原因就是我们const声明的变量是不可以改变的。 变量的解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。解构赋值在实际开发中可以大量减少我们的代码量，并且让我们的程序结构更清晰。 数组的解构赋值简单的数组解构以前，为变量赋值，我们只能直接指定值。比如下面的代码：123let a = 0;let b = 1;let c = 2; 而现在我们可以用数组解构的方式来进行赋值。1let [a,b,c]=[1,2,3]; 上面的代码表示，可以从数组中提取值，按照位置的对象关系对变量赋值。 数组模式和赋值模式统一可以简单的理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。1let [a,[b,c],d]=[1,[2,3],4]; 解构的默认值解构赋值是允许你使用默认值的，先看一个最简单的默认是的例子。12let [foo = true] = [];console.log(foo); //控制台打印出true 上边的例子数组中只有一个值，可能你会多少有些疑惑，我们就来个多个值的数组，并给他一些默认值。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;]console.log(a+b); //控制台显示“技术胖JSPang” 现在我们对默认值有所了解，需要注意的是undefined和null的区别。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;,undefined];console.log(a+b); //控制台显示“技术胖JSPang” undefined相当于什么都没有，b是默认值。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;,null];console.log(a+b); //控制台显示“技术胖null” null相当于有值，但值为null。所以b并没有取默认值，而是解构成了null。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123let &#123; foo, bar &#125; = &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;console.log(foo)console.log(bar) 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 扩展运算符和rest运算符对象扩展运算符（…）当编写一个方法时，我们允许它传入的参数是不确定的。这时候可以使用对象扩展运算符来作参数，看一个简单的列子：12345678function jspang(...arg)&#123; console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]); &#125;jspang(1,2,3); 扩展运算符的用处 先用一个例子说明，我们声明两个数组arr1和arr2，然后我们把arr1赋值给arr2，然后我们改变arr2的值，你会发现arr1的值也改变了，因为我们这是对内存堆栈的引用，而不是真正的赋值。123456789 /**扩展运算符的用处-数组赋值 */let arr1 = [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;]let arr2 = arr1console.log(arr2)arr2.push(&quot;study&quot;)console.log(arr1)输出实例如下：[&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;][&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;, &quot;study&quot;] 利用扩展运算符可以解决数组深度构造的问题。12345678let arr3 = [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;]let arr4 = [...arr3]console.log(arr3)arr4.push(&quot;study&quot;)console.log(arr3)(3) [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;](3) [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;] 可见arr3并没有被改变，与arr4是各自独立占一块内存。 rest运算符 如果你已经很好的掌握了对象扩展运算符，那么理解rest运算符并不困难，它们有很多相似之处，甚至很多时候你不用特意去区分。它也用…（三个点）来表示，我们先来看一个例子。1234567 /**rest运算符 */function restOper(first, ...args) &#123; console.log(args.length)&#125;restOper(0, 1, 2, 3, 4, 5, 6, 7)打印出7 ，说明args中有7个元素。 for…of循环12345function restOperForOf(first, ...args) &#123; for (let val of args) console.log(val)&#125;restOperForOf(0, 1, 2, 3, 4, 5, 6, 7) for…of的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for…of循环。有的小伙伴会说了，反正最后要转换成ES5，没有什么差别，但是至少从代码量上我们少打了一些单词，这就是开发效率的提高。 字符串模板这节主要学习ES6对字符串新增的操作，最重要的就是字符串模版，字符串模版的出现让我们再也不用拼接变量了，而且支持在模板里有简单计算操作。 先看ES5下的字符串拼接实例123let username = &apos;jake1036&apos;let blog = &apos;欢迎大家来到&apos; + username + &apos;博客&apos;document.write(blog) ES5下必须用+username+这样的形式进行拼接，这样很麻烦而且很容易出错。ES6新增了字符串模版，可以很好的解决这个问题。字符串模版不再使用’xxx’这样的单引号，而是换成了xxx这种形式(可以看下面的代码)，也叫连接号。这时我们再引用jspang变量就需要用${username}这种形式了，我们对上边的代码进行改造。12345/**es6改造 */let username_es6 = &apos;jake1036&apos;let blog_es6 = `es6欢迎大家来到 $&#123;username&#125;博客`document.write(blog_es6) 还可以在字符串中增加html样式和代码12345 /**es6字符串添加html代码 */let username_es6_html = &apos;jake1036&apos;let blog_es6_html = `&lt;br/&gt;es6欢迎大家来到&lt;b&gt; $&#123;username&#125;&lt;/b&gt;博客`document.write(blog_es6_html) 对运算的支持 1234 /**对运算符的支持 */let a_es6 = 1let b_es6 = 2document.write(`&lt;br/&gt;a+b:$&#123;a_es6+b_es6&#125;`) 字符串函数 1234 /**字符串函数的应用 */let str_es6 = `测试es6字符串函数查找，支持汉字`console.log(str_es6.includes(&apos;es6&apos;))document.write(&apos;es6|&apos;.repeat(3)); //字符串重复 ES6数字操作二进制和八进制二进制和八进制数字的声明并不是ES6的特性，我们只是做一个常识性的回顾。 二进制声明二进制的英文单词是Binary,二进制的开始是0（零），然后第二个位置是b（注意这里大小写都可以实现），然后跟上二进制的值就可以了。12let binaryVal = 0B0110console.log(binaryVal) 控制台打印出6. 八进制声明八进制的英文单词是Octal，也是以0（零）开始的，然后第二个位置是O（欧），然后跟上八进制的值就可以了。12let b=0o666;console.log(b); 控制台打印出438。 数字判断和转换 数字验证Number.isFinite( xx )可以使用Number.isFinite( )来进行数字验证，只要是数字，不论是浮点型还是整形都会返回true，其他时候会返回false。 12345/**判断是否是数字 */let numberVal = 11 / 4console.log(Number.isFinite(numberVal)) //trueconsole.log(Number.isFinite(0.3434)) //trueconsole.log(Number.isFinite(&apos;test&apos;)) //false NaN验证NaN是特殊的非数字，可以使用Number.isNaN()来进行验证。下边的代码控制台返回了true。 1console.log(Number.isNaN(NaN)); 判断是否为整数Number.isInteger(xx) 1console.log(Number.isInteger(0.3434)) 参考jishupang老师博客","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路-01搭建环境","slug":"2018-04-23-ES6学习之路01","date":"2018-04-25T00:56:56.665Z","updated":"2018-04-25T00:58:01.993Z","comments":true,"path":"2018/04/25/2018-04-23-ES6学习之路01/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-23-ES6学习之路01/","excerpt":"","text":"ES6学习之路-01搭建环境继续跟着技术胖老师学习前端，接下来学习ES6，首先是搭建开发环境。本实例教程github地址：https://github.com/dumingcode/es6.git 搭建开发环境有些低版本的浏览器还是不支持ES6语法，需要我们把ES6的语法自动的转变成ES5的语法。webpack能实现此功能，Babel也可以，本文使用Babel将ES6编译成ES5。 建立工程目录es6，新建两个目录 src : 书写ES6代码的文件夹，写的js程序都放在这里 dist : 利用Babel编译成的ES5代码的文件夹，在HTML页面需要引入的时这里的js文件。 编写index.html页面（在工程根目录下）,html代码我就直接复制了，注意下面js的位置在dist中，我们的js文件写在src下，需要借助babel编译到dist目录下。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;script src=&quot;./dist/index.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello ECMA Script 6 &lt;/body&gt;&lt;/html&gt; 在src目录下编写index.js功能简单只作一个a变量的声明，并用console.log()打印出来。 12let a=1;console.log(a); let是ES6的一种声明方式，接下来我们需要把这个ES6的语法文件自动编程成ES5的语法文件。 初始化项目在安装Babel之前，需要用npm init先初始化我们的项目。npm init -y-y代表全部默认同意，就不用一次次按回车了。命令执行完成后，会在项目根目录下生产package.json文件。 123456789101112&#123; &quot;name&quot;: &quot;es6&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 全局安装Babel-clicnpm install -g babel-cli虽然已经安装了babel-cli，只是这样还不能成功进行转换，尝试输入命令babel src/index.js -o dist/index.js ， 显示结果如下 12let a = 1;console.log(a); 说明编译没有成功。 本地安装babel-preset-es2015 和 babel-clicnpm install --save-dev babel-preset-es2015 babel-cli 提示babel-preset-es2015过期，采用最新包继续安装cnpm install --save-dev babel-preset-env babel-cli。安装完成后打开package.json文件，发现新增配置如下： 12345&quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;&#125; 新建.babelrc在根目录下新建.babelrc文件，并打开录入下面的代码 123456&#123; &quot;presets&quot;:[ &quot;env&quot; ], &quot;plugins&quot;:[]&#125; 然后重新执行编译命令babel src/index.js -o dist/index.js。然后打开编译后的dist/index.js文件，源代码如下：1234&quot;use strict&quot;;var a = 1;console.log(a); 已经成功将ES6的语法编译成ES5。 编写转换script使用npm run build 直接利用webpack进行打包，在这里也希望利用这种方式完成转换。打开package.json文件，把文件修改成下面的样子。1234567891011121314151617&#123; &quot;name&quot;: &quot;es6&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;babel src/index.js -o dist/index.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot; &#125;&#125; 然后就可以使用npm run build打包了。 参考技术胖老师ES6","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"软技能-代码之外的生存指南读书心得","slug":"2018-04-22-软技能 代码之外的生存指南读书心得","date":"2018-04-22T08:44:19.053Z","updated":"2018-04-22T09:02:51.953Z","comments":true,"path":"2018/04/22/2018-04-22-软技能 代码之外的生存指南读书心得/","link":"","permalink":"http://yoursite.com/2018/04/22/2018-04-22-软技能 代码之外的生存指南读书心得/","excerpt":"","text":"软技能-代码之外的生存指南读后感花费半个月读完了John Z. Sonmez写的《软技能 代码之外的生存指南》一书。非常推荐广大程序员看一下此书，越早看受益越早。作者针对程序员职业生涯重点写到了如下几个方面： 如何学习技术 对待工作的态度，一周工作60小时以上是必要前提 程序员如何自我营销 节省时间提供工作效率的方法 建议程序员培养健身+理财的意识用思维导图把作者的主要观点表述如下 读后个人实践读完这本书，我具体实践了以下几个方面（已经在做，不是口号）： 建立了个人blog，养成每周至少发一篇高质量（尽量做到高质量）文章。 每周跑三次步（从14年就开始跑了） 理财意识（17年初开始关注股权投资） 每周工作60小时以上（公司工作） 日常工作使用番茄工作法，主要借助此方法评估每天的工作，每天10个番茄。 微信朋友圈消息提醒关闭。 每天7点前到公司，学习前端技术，vue、es6、nodejs，学习到9点。 作者推荐的书籍看一下，然后发表读书心得","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"hexo使用jenkins自动部署到阿里云","slug":"2018-04-21-hexo使用jenkins自动部署到阿里云","date":"2018-04-21T07:09:38.991Z","updated":"2018-04-21T07:35:34.530Z","comments":true,"path":"2018/04/21/2018-04-21-hexo使用jenkins自动部署到阿里云/","link":"","permalink":"http://yoursite.com/2018/04/21/2018-04-21-hexo使用jenkins自动部署到阿里云/","excerpt":"","text":"hexo使用jenkins自动部署到阿里云本地安装hexo12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 使用github pages服务部署hexo我们用来托管博客的服务叫做 Github Pages，它是 Github 用来提供给个人/组织或者项目的网页服务，只需要部署到你的 Github Repository，推送代码，便可以实时呈现。 首先，你需要有一个 Github 的账号。然后创建一个名称为 .github.io 的仓库来托管网页即可。 以我的 Github 为例，我的用户名是 dumingcode，所以创建一个名为 dumingcode.github.io 的仓库，创建的仓库地址便是：https://github.com/dumingcode/dumingcode.github.io.git 创建完后，我们可以暂时不用管它，不需要往仓库里面 push 任何的东西。 hexo部署配置接着，我们来配置一下本地的 Hexo。 在博客的根目录下有一个名为 _config.yml 的文件，这是博客的主配置文件。前面的其他部分我们先不理会，后文再谈，我们先看最后的 Deployment 配置项：1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 根据官方的文档显示，现在 Hexo 支持 Git、Heroku、Rsync、OpenShift、FTPSync 等部署方式，我们选择 Git 来部署的话，需要首先安装 hexo-deployer-git 插件：cnpm install hexo-deployer-git --save然后编辑上面的配置文件：12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 我们需要把刚才创建的仓库地址添加进来，branch 和 message 项可以不填，默认情况下推送到 master 分支，这里我建议使用 SSH 加密的仓库地址（参看 Github 官方文档配置 SSH 免密操作）。 保存配置文件之后，我们在博客的跟目录键入：hexo g -d便可以把博客部署到 Github 了。现在，所有人都可以通过 http://.github.io 来访问自己的博客。 hexo使用第三方模板找了半天发现hexo-theme-BlueLake主题很简洁，于是使用下面的命令安装（进入blog根目录执行）。 123git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLakecnpm install hexo-renderer-jade@0.3.0 --savecnpm install hexo-renderer-stylus --save 本人搭建好的github个人主页:https://dumingcode.github.io/，欢迎访问。 hexo部署到阿里云虽说利用github pages服务能够对外发布博客，但是作为一个码农还是希望有自己的域名博客，但是我比较懒，不想手动发布博客。我想自动化地既发布到github也能同时发布到个人网站。所以决定采用CICD的方法，CICD工具使用开源的jenkins，jenkins也搭建在阿里云个人服务器上。 下载并运行jenkins注意端口使用的是8081123mkdir /usr/local/jenkinswget http://mirrors.jenkins.io/war-stable/latest/jenkins.warnohup java -jar jenkins.war --ajp13Port=-1 --httpPort=8081 &amp; 安装nginx 安装nginx依赖 1234567891011yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-develwget http://nginx.org/download/nginx-1.13.10.tar.gztar xvf nginx-1.13.10.tar.gz./configure --prefix=/usr/local/nginxmakemake installcd /usr/local/nginx/sbin./nginx -s reloadnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or direc需要设置nginx.conf./nginx -c /usr/local/nginx/conf/nginx.conf nginx.conf配置 12345678910111213141516171819upstream jenkins &#123; server 127.0.0.1:8081; keepalive 64;&#125;server &#123; listen 80; server_name jenkins.buyasset.com; client_max_body_size 60M; client_body_buffer_size 512k; location / &#123; port_in_redirect on; proxy_pass http://jenkins/; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; &#125; 以上通过nginx 反向代理jenkins，在浏览器输入http://jenkins.buyasset.club就能够进入jenkins管理后台。 配置jenkins在jenkins页面提示目录中找到默认密码，输入jenkis域名，登陆jenkins。 安装jenkins社区推荐的插件 配置github获取sercret text登陆github网站，进入 github-&gt;Settings-&gt;Developer settings-&gt; Generate new token，点击生成完毕一定记录下下面的secret text。secret text一定要记住，忘记的话只能重新生成。 GitHub webhooks 设置进入GitHub上指定的项目（hexo 仓库） –&gt; setting –&gt; WebHooks&amp;Services –&gt; add webhook –&gt; 输入刚刚部署jenkins的服务器的IP图片中标红区域是变化的，后缀都是一样的为github-webhook。 jenkins中的github配置配置GitHub Plugin系统管理 –&gt; 系统设置 –&gt; GitHub –&gt; Add GitHub SeverAPI URL 输入 https://api.github.com，Credentials点击Add添加，Kind选择Secret Text,具体如下图所示。设置完成后，点击TestConnection,提示Credentials verified for user UUserName, rate limit: xxx,则表明有效。 创建一个freestyle任务 General 设置填写GitHub project URL, 也就是你的项目主页eg. https://github.com/your_name/your_repo_name 配置源码管理 构建触发器，构建环境 构建 构建脚本将上图的构建脚本替换如下： 1234cd /var/www/blog（hexo目录）git pullhexo cleanhexo g -d 构建后操作 构建前clone hexo将hexo初始代码拉取到/var/www/blog目录中，以后jenkins会监控github的push操作，一旦发现push会自动更新。cd /var/wwwgit clone https://github.com/dumingcode/dumingcode.github.io.git blog nginx反向代理hexohexo为静态网站，所以直接用nginx反向代理即可,nginx脚本如下：注意root指向的是hexo部署目录。12345678910111213141516171819202122232425server&#123; listen 80; server_name blog.buyasset.club; index index.html index.htm index.php default.html default.htm default.php; root /var/www/blog; #error_page 404 /404.html; location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$ &#123; access_log off; expires 1d; &#125; location ~ .*\\.(js|css|txt|xml)?$ &#123; access_log off; expires 12h; &#125; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 测试CICD效果进入本地hexo目录，修改发布的博客，然后执行hexo g -d，登陆jenkins发现jenkins已经获取到了push操作，并且执行了自动构建任务。以下为jenkins的变更记录1234Site updated: 2018-04-21 13:35:51 (commit: 76f3c53) (details)Commit 76f3c530d077782fd66a8ca375afaa17cd188286 by dumingSite updated: 2018-04-21 13:35:51 (commit: 76f3c53) 参考链接手把手教你搭建Jenkins+Github持续集成环境Jenkins+Github持续集成Jenkins最佳实践hexo自动部署基于 Hexo 的全自动博客构建部署系统","categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"}],"keywords":[]},{"title":"2018我的小目标","slug":"2018-04-15-我的小目标","date":"2018-04-15T08:43:27.901Z","updated":"2018-04-25T01:06:05.802Z","comments":true,"path":"2018/04/15/2018-04-15-我的小目标/","link":"","permalink":"http://yoursite.com/2018/04/15/2018-04-15-我的小目标/","excerpt":"","text":"技术方面学习知识 掌握vue框架，能使用vue实现功能。 学习使用ELK日志分析系统。 CICD-学习使用jenkins、Travis。 nginx open resty开发。 mongodb java8新特性比如lambda docker 阿里云部署实践docker java设计模式 nodejs学习并实践 按照前端开发栈学习es6 webpack等基础技术 实践知识学习-实践-教授-再学习，只学习效率会很低，学习技术必须学以致用，实践会加深理解。 大数整体仓位算下加权pb pe roe 股息率。 按申万一级，统计每个各行业符合大数的个股情况。 他山石现金流模型。 建立自己的专用域名blog，github和个人域名都写博客,坚持每周至少一篇blog。 每学习一种技术，写blog，然后录音频视频提供大家培训。 微信、app、都进行尝试 学会造轮子。","categories":[],"tags":[{"name":"规划","slug":"规划","permalink":"http://yoursite.com/tags/规划/"}],"keywords":[]},{"title":"2018北京长跑节半程马拉松","slug":"2018-04-15-北京长跑节半程马拉松","date":"2018-04-15T08:35:12.832Z","updated":"2018-04-15T08:38:56.882Z","comments":true,"path":"2018/04/15/2018-04-15-北京长跑节半程马拉松/","link":"","permalink":"http://yoursite.com/2018/04/15/2018-04-15-北京长跑节半程马拉松/","excerpt":"","text":"2018北京半程马拉松20180415忙里偷闲参加了北京长跑节半程马拉松，2:07跑完全程，创造个人最好成绩了。下面晒一些图，留下纪念。","categories":[],"tags":[{"name":"运动","slug":"运动","permalink":"http://yoursite.com/tags/运动/"}],"keywords":[]}]}