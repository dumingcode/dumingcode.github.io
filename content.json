{"meta":{"title":"学习之路","subtitle":"做只笨鸟","description":"记录技术学习以及读书心得","author":"DuMing","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-04-14T13:26:37.000Z","updated":"2018-04-14T13:26:37.678Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"微服务限流","slug":"2018-07-30-微服务限流","date":"2018-07-30T05:45:19.276Z","updated":"2018-07-30T05:57:41.591Z","comments":true,"path":"2018/07/30/2018-07-30-微服务限流/","link":"","permalink":"http://yoursite.com/2018/07/30/2018-07-30-微服务限流/","excerpt":"","text":"微服务限流常用限流架构 在接入层(api-gateway)集成限流功能。分布式或者单实例，如果多实例部署需要考虑使用分布式限流算法。 限流功能封装成RPC服务。微服务接收到请求后，会通过限流服务暴露的RPC接口查询请求是否超过阈值。需要单独部署限流服务，增长运维成本。限流服务本身可能会成为系统性能的瓶颈。 限流功能集成在微服务系统内。需要集成在切面层，尽量与业务代码解耦。限流算法 固定、滑动时间窗口限流。适合微服务接口。 令牌桶、漏桶限流算法。适合阻塞限流。后台一些JOB类限流，超过最大访问频率后，请求不会被拒绝，而是阻塞 到有令牌后再继续执行。 限流熔断策略 记录日志 发送告警 服务降级上线初期适合采用日志记录和告警，待通过日志分析限流达到效果后，再进一步升级为其他限流熔断策略。 验证是否有效针对每次请求需要记录下，对应接口、请求时间点、限流结果（通过还是熔断），通过记录数据绘制图表。 限流开发库-Ratelimiter4j限流开发库需要具有以下特点： 低延迟，不能或者较小影响接口本身的响应时间。 高度容错，限流框架异常不能影响微服务的可用性。 高TPS。限流框架的TPS至少要大于微服务本身的接口TPS。 参考微服务接口限流的设计与思考（附GitHub框架源码）Ratelimiter4j","categories":[],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://yoursite.com/tags/微服务/"}],"keywords":[]},{"title":"一个人的朝圣","slug":"2018-07-30-一个人的朝圣","date":"2018-07-30T05:43:08.224Z","updated":"2018-07-30T05:57:41.586Z","comments":true,"path":"2018/07/30/2018-07-30-一个人的朝圣/","link":"","permalink":"http://yoursite.com/2018/07/30/2018-07-30-一个人的朝圣/","excerpt":"","text":"一个人的朝圣读后感今年做记录的第五本书。 故事梗概 利用半个月的时间读了这本小说，这本小说写的很朴实。讲述了哈罗德与妻子莫琳几十年的感情纠葛。夫妻之间因为儿子的去世而心生隔膜几十年，即使同住一个屋檐下，心却不在一起了。事情起因于哈罗德收到恩人奎妮（替哈罗德背过锅，而丢掉了工作）的来信，告诉他罹患癌症时日无多。哈罗德冲动地拨去电话，请护工转告奎妮，他会步行1000公里去看她，请她一定等着他。说走就走，哈罗德什么都没准备就出发了。期间遇到了很多陌生人给予的帮助，让我印象比较深的是，旅途中哈罗德的几次放弃。 第一次放弃，行程10%处，大概是身体吃不消，后来在一个外科护士的帮助下身体恢复了。 第二次放弃，行程60%处，信念受到动摇，待与疗养院确认奎妮健在且期待他的到来时恢复。 第三次放弃，行程98%处，心灰意冷，失去了动机。在老婆的帮助下，恢复动机。可见坚持做一件事好难，坚持与保持动机才是成功的关键。旅途中通过描写夫妻之间的心理活动，双方都对过去的事情进行了反思，哈罗德也反思自己对儿子教育方式。两认多次都重温了初次见面的情景，感情的根还在。他在旅途中对待一位问题青年的照顾，更像是对儿子的弥补。最终哈罗德还是到达了目的地，但是他与恩人的见面描写的很朴实，很平静。恩人去世的时候，护工说像是在说什么话，像意识到有人来看她了。 莫林最后也来与他回合，两人找回了失去的感情。 感想 心存正念，正如齐老师说的，但行好事莫问前程。 绝大多数人还是普通人，平平淡淡过一生。 心存信念，保持动机。动机不是永恒的，短暂的褪去很正常。","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"刻意练习读书笔记","slug":"2018-07-18-刻意练习读书笔记","date":"2018-07-18T00:16:04.008Z","updated":"2018-07-18T00:16:04.009Z","comments":true,"path":"2018/07/18/2018-07-18-刻意练习读书笔记/","link":"","permalink":"http://yoursite.com/2018/07/18/2018-07-18-刻意练习读书笔记/","excerpt":"","text":"刻意练习好久没写博客了，工作忙了一个月，github上也是只有周日才能贡献代码了。光输出迟早变成穷光蛋，还是得持续的输入，读书、看大牛的技术blog。我发现读书的时候，手里还是有个笔记本，能记录下当时的想法。这篇文章基本是我kindle笔记的标注的印象笔记深刻的语句。 我印象最深的一点：还是作者认为的，某项技能都有个最低的入门门槛，一旦达到了入门门槛，以后的成绩跟基因无关。另外这本书给了我对孩子教育的一些想法： 尽早对孩子进行兴趣培养，比如3岁左右可以让她接触舞蹈。 一定坚持鼓励孩子的进步 针对孩子的培训，一定得坚持刻意练习，不能为了克服自己的焦虑，就乱上培训班。 舍得花钱上好老师。 经典语句 一万小时定律前提：刻意练习。 年轻人的大脑比成年人更强，有些能力只能在6岁、12岁、18岁之前培养（或更适宜），但是成年人仍然能通过正确训练掌握新的能力。 天生才能被高估，机会、动机、努力被低估。 5年的程序员不一定比3年的技能更高，原因是没有刻意地提高，天天CRUD提高不了。 最杰出的人是那些在各种有目的的练习中花费时间最多的人。 刻意练习的最佳方法：找到优秀的导师。 如果发现自己不能再快速进步，去找一位新的导师。 瓶颈期 试着做不同的事情，而非更难的事情 并非达到极限，而是动力不足 走出舒适区 人类的身体有一种偏爱稳定性的倾向。 练习改变大脑结构 经常性的训练会使大脑中受到挑战的区域发生改变，大脑通过重新布线的方式来适应这些挑战。 传统学习方法与刻意练习关键差别：传统方法并不是专门用于挑战体内平衡。 心理表征 杰出人物和其他人区别开来的因素：心理表征的质量和数量。 刻意练习的目的就是创建有效的心理表征 刻意练习的特点 刻意练习发展的技能，拥有一整套行之有效的训练方法。 发生在舒适区之外。 有良好定义的特定目标。 有意而为。 包含反馈 既产生有效的心理表征，又依靠有效的心理表征。 构建或修改过去已经获取的技能，逐步改进。 三个F创建有效心理表征 专注focus 反馈feedback 纠正fix 保持动机 刻意练习最终面对的最大问题就是保持动机 意志力和天生才华，是人们在事实发生之后再赋予某人的优点。 刻意练习的人应该每天花费1小时，专心练习那些需要全神贯注才能做好的事情。 刻意练习是孤独的追求。 孩子教育 第一阶段让孩子产生兴趣，从玩耍中追求卓越。（小时候给孩子读书，长大了让他们自己读） 第二阶段：变的认真，激励孩子。 第三阶段：全力投入。杰出人物一般在12-13或15-16要付出巨大的投入。 第四阶段：开拓创新。 怎样解释天生才华 孩子刚开始学习某项技能时，智商高的学得快。 往往有种趋势：智商较低的孩子，练习的更刻苦。 从长远看占上风的是那些练习更勤奋的人，而不是一开始就展露才华的人。 换个角度看基因差异 某些行业或者领域，对从业者的能力或者智商有个最低要求。 最低要求达到之后，以上的成就就跟先天基因无关了。 不存在音乐基因、象棋基因。 相信天生才华是危险的。","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"iview使用async-validator校验数字范围","slug":"2018-06-10-iview使用validator校验数字范围","date":"2018-07-18T00:16:04.005Z","updated":"2018-07-18T00:16:04.005Z","comments":true,"path":"2018/07/18/2018-06-10-iview使用validator校验数字范围/","link":"","permalink":"http://yoursite.com/2018/07/18/2018-06-10-iview使用validator校验数字范围/","excerpt":"","text":"iview使用async-validator校验数字范围自定义验证在实际开发中使用iview input组件被要求实现一个功能：校验输入的数字小于xx或者大于xxx，看了一下async-validator API，自定义实现的validator能够通过rule对象的options变量传入参数。自定义校验函数如下：123456789101112131415161718//验证输入的数字比min小export const validateNumberMin = (rule, value, callback) =&gt; &#123; let val = Number(value) if (val != &apos;&apos; &amp;&amp; rule.options.min != &apos;&apos; &amp;&amp; (val &lt; rule.options.min)) &#123; return callback(new Error(&apos;number&apos;)) &#125; else &#123; callback() &#125; &#125; //验证输入的数字比max大export const validateNumberMax = (rule, value, callback) =&gt; &#123; let val = Number(value) if (val != &apos;&apos; &amp;&amp; rule.options.max != &apos;&apos; &amp;&amp; (val &gt; rule.options.max)) &#123; return callback(new Error(&apos;number&apos;)) &#125; else &#123; callback() &#125;&#125; 实际调用validator函数：123456789101112&#123; validator: validateNumberMin, message: &quot;应大于等于100&quot;, trigger: &quot;blur&quot;, options: &#123; min: 100 &#125;&#125;&#123; validator: validateNumberMax, message: &quot;应小于等于200&quot;, trigger: &quot;blur&quot;, options: &#123; max: 100 &#125;&#125; 注意：options实际上是rule对象中的一个变量。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"travis阿里云自动部署","slug":"2018-06-02-travis自动部署阿里云","date":"2018-06-02T07:24:27.826Z","updated":"2018-07-18T00:16:03.997Z","comments":true,"path":"2018/06/02/2018-06-02-travis自动部署阿里云/","link":"","permalink":"http://yoursite.com/2018/06/02/2018-06-02-travis自动部署阿里云/","excerpt":"","text":"travis阿里云自动部署之前写过一篇关于travis自动部署的文章，但是文章里关于使用ssh auto deploy的描述不太清楚，现在继续重新一篇。 生成部署服务器ssh key直接登陆阿里云部署服务器，执行下面的脚本。注意这段脚本的执行目录可以自己定义，不一定非要在~/.ssh中。第二行travis encrypt-file是加密私钥，其中的-r后跟自己的github仓库名。第三行ssh-copy-id 是将生成的公钥加入到部署主机的~/.ssh/authorized_keys公钥文件中。脚本执行完毕可以将私钥文件和公钥文件删除，切记需要将加密后的私钥文件放入代码目录中。 1234567ssh-keygen -t rsa -b 4096 -C &apos;build@travis-ci.org&apos; -f ./deploy_rsatravis encrypt-file deploy_rsa -r dumingcode/my-fintech-frontendssh-copy-id -i deploy_rsa.pub &lt;ssh-user&gt;@&lt;deploy-host&gt;rm -f deploy_rsa deploy_rsa.pubgit add deploy_rsa.enc .travis.yml 部署前执行脚本先上脚本：12345678addons: ssh_known_hosts: &lt;deploy-host&gt;before_deploy:- openssl aes-256-cbc -K $encrypted_&lt;...&gt;_key -iv $encrypted_&lt;...&gt;_iv -in deploy_rsa.enc -out /tmp/deploy_rsa -d- eval &quot;$(ssh-agent -s)&quot;- chmod 600 /tmp/deploy_rsa- ssh-add /tmp/deploy_rsa 此脚本实际运行在travis服务器中，上述脚本的主要作用： addons防止travis登陆部署主机时，需要用户输入一些交互信息。 openssl这行相当于解密私钥文件，注意私钥文件解密在tmp目录下，这个是指travis build主机的目录，不是部署主机的目录。 ssh-add把专用密钥添加到 ssh-agent 的高速缓存，deploy阶段在部署服务器执行命令时，不需要再输入秘钥相关信息。部署脚本123456deploy: provider: script skip_cleanup: true script: rsync -r --delete-after --quiet $TRAVIS_BUILD_DIR/&lt;dir&gt; &lt;ssh-user&gt;@&lt;deploy-host&gt;:path/to/files on: branch: master 此段脚本实际是travis服务器ssh登录到部署服务器后，在部署服务器中执行的命令。$TRAVIS_BUILD_DIR/&lt;dir&gt; 此目录指的是travis build主机中的地址，如果你要部署hexo博客，那dir指的是public，如果要部署的是vue应用则此dir指的是dist目录。 完整版travis.yml12345678910111213141516171819202122sudo: falselanguage: node_jsnode_js: - 8cache: directories: - node_modulesscript: - npm run buildaddons: ssh_known_hosts: 39.107.119.46 # 请替换成自己的服务器IPbefore_deploy: - openssl aes-256-cbc -K $encrypted_ed86006c7fbb_key -iv $encrypted_ed86006c7fbb_iv -in deploy_rsa.enc -out /tmp/deploy_rsa -d - eval &quot;$(ssh-agent -s)&quot; - chmod 600 /tmp/deploy_rsa - ssh-add /tmp/deploy_rsadeploy: provider: script skip_cleanup: true script: rsync -r --delete-after --quiet $TRAVIS_BUILD_DIR/dist $deploy_user@39.107.119.46:$DEPLOY_PATH on: branch: master 参考SSH deploys with Travis CI","categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"}],"keywords":[]},{"title":"成功动机目标读书笔记","slug":"2018-05-27-成功动机目标读书笔记","date":"2018-06-02T07:24:27.822Z","updated":"2018-06-02T07:24:27.822Z","comments":true,"path":"2018/06/02/2018-05-27-成功动机目标读书笔记/","link":"","permalink":"http://yoursite.com/2018/06/02/2018-05-27-成功动机目标读书笔记/","excerpt":"","text":"成功、动机与目标成功者与自制力悖论 区分为什么和是什么 长期困难的目标采用“为什么”制定目标 简单的目标采用“是什么”制定目标，强调即刻动手去做。 智力是否是增长的 坚信智力、个性、体质不是固定不变的，都是可以成长的。 环境中部署一些提示点和触发点，让潜意识为达到目标而努力工作。 注重成长还是表现聚焦“进步”，享受旅途。把绩效目标转换成长期成长目标，这样能降低忧虑。个人感受：在公司就要努力工作，但是不能一味埋头，也要考虑自己的职业生涯。 幸福的三个要素满足人类对关联感、胜任力、与自主权这三种基本需求的目标，能带来幸福。 关联感增强人际关系。目标建立或巩固人际关系以及回报社会，关联感的需求就会得到满足。 胜任力开发新技能。追求的目标应该与个人成长、从经验中学习以及开发性机能有关。 自主权反映出热情所在。追求符合个人兴趣爱好以及核心价值的目标。 过度追求名誉财富可能带来困扰。 内在动力可以燎原，自由选择的目标能够产生内在动力。但是注意的是，这种动力能被任何管制因素破坏，包括奖励、惩罚、期限以及监控。 自主权是动力的燃料。将任务转成个人目标，称为内化。 进攻型目标和防御性目标 进攻给为了获得，防御为了不失去。 乐观精神适合进取型目标，不适合防御性目标。 进攻使人热血沸腾，防御使人如释重负。 进攻目标偏爱风险，防御目标偏爱谨慎。 目标感染 使目标个人化。给他人尽可能多的达标方式的选择。 无个人选择时，公众承诺。 运用适当的触发因素。 有效计划 制定如果…..就…..计划。如果是周一到周五晚上，我就不吃完饭。诸如此类的计划 决定具体行动，目标计划要具体，时点地点要详细。 瞄准障碍。对待诱惑也制定出如果就计划。如果周一到周五晚上有人叫我吃饭，我就不去。 不冒无畏的风险 不进则退，意志力这个东西类似人的肌肉，一旦不锻炼就会消退。但是一直锻炼则会加强。 启动自制力。日常接受一些小的挑战，比如周一到周五晚节食。 休息必不可少。自制力是损耗品。 别冒无谓的风险。尊重自制肌的局限性，别同时接受两个很难的挑战。比如节食和戒烟。 乐观精神 适度乐观有益。 把注意力从能力上移走，转移到努力、坚持与计划上来。 懂的何时放手 学会坚韧。长期投入、不退缩。 坚韧起来的方法，进步型目标以及自主选择的目标。 旧的不去，新的不来。放弃困难太大或者代价太高的目标，但是需要找个新目标去代替旧的。从而保持参与感与使命感。 评价 说实话，人们要为自己缺少勤奋和错误策略而负责。 正面、实用的建议。 真诚的赞美。 表扬对事不对人。 避免比较，不能在孩子之间、学生、职员之间比较。 领悟与总结","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"github_travis_coveralls自动集成自动部署","slug":"2018-05-15-github_travis_coveralls自动集成自动部署","date":"2018-05-27T00:41:06.792Z","updated":"2018-05-27T00:41:06.792Z","comments":true,"path":"2018/05/27/2018-05-15-github_travis_coveralls自动集成自动部署/","link":"","permalink":"http://yoursite.com/2018/05/27/2018-05-15-github_travis_coveralls自动集成自动部署/","excerpt":"","text":"github_travis_coveralls自动集成自动部署近期准备开发一个指数定投金额计算的小项目，源码托管在github上。之前都是本地测试通过后，使用XSHELL将代码传输到部署服务器。后来自己研究了下jenkins，并借助jenkins实现将hexo博客自动部署，详见之前写的文章。但是首先jenkins需要自己部署，而且毕竟代码托管在github，干脆秉承一切都开源的精神，折腾一下将github,travis,coveralls结合起来，实现CICD。 travis配置注册配置travis直接使用github的账号登陆travis，登陆之后如下图所示添加自己的github repo。添加完毕后，setting如下图所示。 travis自动集成简单说这个功能就是实现代码上传travis后，能够travis自动执行测试过程。本人使用的是nodejs开发项目，所以先在package.json文件中定义了npm test命令，travis通过执行npm test命令完成自动构建。 travis mocha测试异步代码不退出在测试过程中，遇到一个大坑折腾很久，项目中含有异步调用测试案例，导致travis测试通过后一直运行不退出，后来只能在npm test脚本命令中添加--exit。另外travis默认异步调用等待时间是2秒，所以需要在命令中使用-t 10000人为延长travis等待时间。具体npm test命令为：12345678&quot;name&quot;: &quot;my-fintech-datacenter&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;data-center&quot;, &quot;main&quot;: &quot;schedule.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha -t 10000 ./test/tasktest.js --exit&quot; &#125; &#125; redis服务设置秘钥travis支持在测试前启用mysql redis mongodb等服务，但是我的代码中对redis设置了秘钥，而且犯懒了不太想改代码，然后找到了如下解决方案，在travis.yml配置文件中添加:before_script: sudo redis-server /etc/redis/redis.conf --requirepass $redis_password ，注意命令中的$redis_password是在travis setting中设置的加密环境变量。后面还会讲到travis还会针对文件进行加密，比如一些项目配置文件以及SSH秘钥都需要进行文件加密。 travis代码覆盖率集成这个功能主要是借助coveralls实现。首先package.json文件中,定义一条命令：1&quot;test-cov&quot;: &quot;./node_modules/istanbul/lib/cli.js cover ./node_modules/mocha/bin/_mocha -- --timeout 10000 -R spec ./test/ --exit&quot; 测试依赖包如下所示：12345678&quot;devDependencies&quot;: &#123; &quot;chai&quot;: &quot;^4.1.2&quot;, &quot;coveralls&quot;: &quot;^3.0.1&quot;, &quot;istanbul&quot;: &quot;^0.4.5&quot;, &quot;istanbul-harmony&quot;: &quot;^0.3.16&quot;, &quot;mocha&quot;: &quot;^5.1.1&quot;, &quot;supertest&quot;: &quot;^3.0.0&quot; &#125; coveralls网站配置登陆coveralls，coveralls也是关联github的账号直接登陆。如下图所示添加github中的repo。添加repo完毕后，需要记录下下图所示的token。 travis.yml 配置123after_success: - npm run test-covafter_script: cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js -repotoken $COVERALLS_TOKEN 注意上述代码中的$COVERALLS_TOKEN，同样也是在travis setting中加密。 自动部署在上面两步自动构建完毕之后，需要将测试通过的代码直接提交到部署服务器，然后重启部署服务器的服务。从travis构建服务器到部署服务器，需要使用SSH协议。travis服务器中需要存储有私钥(_rsa files)，而远端部署服务器需要部署公钥(_rsa.pub files)。但是私钥肯定是不能存储到git repo或者显示在travis的构建日志中。幸运的是，travis提供了对文件的加密功能，可以借助此功能，将加密后的私钥放到github repo中。注：此处说的ssh 公钥 私钥都是在部署服务器中生成的。私钥加密后传到github，公钥继续留在部署服务器。travis文件加密需要安装travis客户端，推荐linux上安装。目标（想登陆的机器）主机存公钥，源机器存私钥。 travis客户端安装12345678yum install ruby ruby-develyum install gemgem update --system#添加源gem sources --add https://gems.ruby-china.org/gem install travistravis login输入github用户密码即可 deploy server生成ssh key登陆deploy server，执行下面的代码。注意：私钥需要经过travis加密，然后传到github repo 。对待公钥则直接执行ssh-copy-id命令。12345ssh-keygen -t rsa -b 4096 -C &apos;build@travis-ci.org&apos; -f ./deploy_rsatravis encrypt-file deploy_rsa --addssh-copy-id -i deploy_rsa.pub &lt;ssh-user&gt;@&lt;deploy-host&gt;rm -f deploy_rsa deploy_rsa.pub travis加密文件的执行步骤如下所示：1234567891011121314[root@iz2ze1fd7d8ota0f9ysaazz .ssh]# [root@iz2ze1fd7d8ota0f9ysaazz .ssh]# travis encrypt-file id_rsa -r dumingcode/my-fintech-datacenterencrypting id_rsa for dumingcode/my-fintech-datacenterstoring result as id_rsa.encstoring secure env variables for decryptionPlease add the following to your build script (before_install stage in your .travis.yml, for instance): openssl aes-256-cbc -K $encrypted_383bc2ea2d21_key -iv $encrypted_383bc2ea2d21_iv -in id_rsa.enc -out id_rsa -dPro Tip: You can add it automatically by running with --add.Make sure to add id_rsa.enc to the git repository.Make sure not to add id_rsa to the git repository.Commit all changes to your .travis.yml. 还有一点要注意 travis第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置：12addons: ssh_known_hosts: your-ip 自动部署脚本自动部署脚本如下所示。本人是采用的rsync命令从travis上将有变化的文件传输到部署服务器，这个命令比scp命令要好。after_deploy命令执行的是pm2 restart，要求nodejs服务至少之前在服务器上执行一次，要不restart要报错。1234567891011deploy: provider: script skip_cleanup: true script: rsync -r --delete-after --quiet $TRAVIS_BUILD_DIR $deploy_user@39.107.119.46:$DEPLOY_PATH on: branch: masterafter_deploy: - ssh $deploy_user@your-ip &quot;pm2 restart datacenter&quot;addons: ssh_known_hosts: your-ip 完整代码下面贴上travis.yml和package.json文件的全部信息。项目github的地址为github。travis.yml文件:12345678910111213141516171819202122232425262728293031sudo: falselanguage: node_jsnode_js: - 8before_install: - openssl aes-256-cbc -K $encrypted_1fc90f464345_key -iv $encrypted_1fc90f464345_iv -in ./config/config.js.enc -out ./config/config.js -d - openssl aes-256-cbc -K $encrypted_383bc2ea2d21_key -iv $encrypted_383bc2ea2d21_iv -in id_rsa.enc -out ~/.ssh/id_rsa -d - chmod 600 ~/.ssh/id_rsabefore_script: sudo redis-server /etc/redis/redis.conf --requirepass $redis_passwordnotifications: email: recipients: - jake1036@126.com on_success: always on_failure: alwaysscript: - npm testafter_success: - npm run test-covdeploy: provider: script skip_cleanup: true script: rsync -r --delete-after --quiet $TRAVIS_BUILD_DIR $deploy_user@39.107.119.46:$DEPLOY_PATH on: branch: masterafter_deploy: - ssh $deploy_user@39.107.119.46 &quot;pm2 restart datacenter&quot;addons: ssh_known_hosts: 39.107.119.46 # 请替换成自己的服务器IPafter_script: cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js -repotoken $COVERALLS_TOKEN package.json文件内容：12345678910111213141516171819202122232425262728293031323334353637&#123; &quot;name&quot;: &quot;my-fintech-datacenter&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;data-center&quot;, &quot;main&quot;: &quot;schedule.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha -t 10000 ./test/tasktest.js --exit&quot;, &quot;test-cov&quot;: &quot;./node_modules/istanbul/lib/cli.js cover ./node_modules/mocha/bin/_mocha -- --timeout 10000 -R spec ./test/ --exit&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/dumingcode/my-fintech-datacenter.git&quot; &#125;, &quot;keywords&quot;: [ &quot;datacenter&quot; ], &quot;author&quot;: &quot;duming&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;https://github.com/dumingcode/my-fintech-datacenter/issues&quot; &#125;, &quot;homepage&quot;: &quot;https://github.com/dumingcode/my-fintech-datacenter#readme&quot;, &quot;dependencies&quot;: &#123; &quot;axios&quot;: &quot;^0.18.0&quot;, &quot;bunyan&quot;: &quot;^1.8.12&quot;, &quot;ioredis&quot;: &quot;^3.2.2&quot;, &quot;node-schedule&quot;: &quot;^1.3.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;chai&quot;: &quot;^4.1.2&quot;, &quot;coveralls&quot;: &quot;^3.0.1&quot;, &quot;istanbul&quot;: &quot;^0.4.5&quot;, &quot;istanbul-harmony&quot;: &quot;^0.3.16&quot;, &quot;mocha&quot;: &quot;^5.1.1&quot;, &quot;supertest&quot;: &quot;^3.0.0&quot; &#125;&#125; 参考感谢以下各位大神。Travis CI 系列：自动化部署博客SSH deploys with Travis CIBuilding Better npm Modules with Travis and Coveralls","categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"}],"keywords":[]},{"title":"koa2学习之路-02-静态资源&cookie&jsonp&测试","slug":"2018-05-11-koa2学习之路-02","date":"2018-05-27T00:41:06.772Z","updated":"2018-05-27T00:41:06.772Z","comments":true,"path":"2018/05/27/2018-05-11-koa2学习之路-02/","link":"","permalink":"http://yoursite.com/2018/05/27/2018-05-11-koa2学习之路-02/","excerpt":"","text":"koa2学习之路-02-静态资源-cookie-jsonp-测试koa2针对静态资源提供了一个koa-staticpackage。1234567891011121314var Koa = require(&apos;koa&apos;)var KoaStatic = require(&apos;koa-static&apos;)var path = require(&apos;path&apos;)// 静态资源目录对于相对入口文件index.js的路径const staticPath = &apos;./static&apos;var app = new Koa()app.use(KoaStatic( path.join(__dirname, staticPath)))app.listen(3000, () =&gt; &#123; console.log(path.join(__dirname, staticPath))&#125;) koa2实现cookie直接用上下文cookie对象操作cookie。123456789101112131415161718192021222324var Koa = require(&apos;koa&apos;)var app = new Koa()app.use(async(ctx) =&gt; &#123; if (ctx.url === &apos;/&apos;) &#123; ctx.cookies.set(&apos;cid&apos;, &apos;hello world&apos;, &#123; domain: &apos;localhost&apos;, // 写cookie所在的域名 path: &apos;/index&apos;, // 写cookie所在的路径 maxAge: 10 * 60 * 1000, // cookie有效时长 expires: new Date(&apos;2019-02-15&apos;), // cookie失效时间 httpOnly: false, // 是否只用于http请求中获取 overwrite: false // 是否允许重写 &#125;) ctx.body = &apos;cookie set ok&apos; &#125; else &#123; ctx.body = &apos;hello world&apos; &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log(&apos;server is running on port 3000&apos;)&#125;) 注意上述代码中，cookies.set(name,value,option)的函数参数，第一个是key，第二个是vlaue，第三个是option。 sessionkoa2原生功能只提供了cookie的操作，但是没有提供session操作。session就只用自己实现或者通过第三方中间件实现。在koa2中实现session的方案有一下几种 如果session数据量很小，可以直接存在内存中 如果session数据量很大，则需要存储介质存放session数据 模板引擎koa使用koa-views在服务器端渲染视图，另外采用ejs模板。 123456789101112131415161718const Koa = require(&apos;koa&apos;)const views = require(&apos;koa-views&apos;)const path = require(&apos;path&apos;)const app = new Koa()// 加载模板引擎app.use(views(path.join(__dirname, &apos;./view&apos;), &#123; extension: &apos;ejs&apos;&#125;))app.use(async(ctx) =&gt; &#123; let title = &apos;hello koa2&apos; await ctx.render(&apos;index&apos;, &#123; title, &#125;)&#125;)app.listen(3000) index.ejs模板内容：12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;EJS Welcome to &lt;%= title %&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; jsonp实现在项目复杂的业务场景，有时候需要在前端跨域获取数据，这时候提供数据的服务就需要提供跨域请求的接口，通常是使用JSONP的方式提供跨域接口。123456789101112131415161718192021222324252627var Koa = require(&apos;koa&apos;)var app = new Koa()app.use(async(ctx) =&gt; &#123; // 判断是否为JSONP的请求 if (ctx.method === &apos;GET&apos; &amp;&amp; ctx.url.split(&apos;?&apos;)[0] === &apos;/getData.jsonp&apos;) &#123; // 获取jsonp的callback let callbackName = ctx.query.callback || &apos;callback&apos; let returnData = &#123; success: true, data: &#123; text: &apos;this is a jsonp api&apos;, time: new Date().getTime(), &#125; &#125; // jsonp的script字符串 let jsonpStr = `;$&#123;callbackName&#125;($&#123;JSON.stringify(returnData)&#125;)` // 用text/javascript，让请求支持跨域获取 ctx.type = &apos;text/javascript&apos; // 输出jsonp字符串 ctx.body = jsonpStr &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log(&apos;server is running on port 3000&apos;)&#125;) 下面使用koa-jsonp中间件实现一版。123456789101112131415161718192021222324const Koa = require(&apos;koa&apos;)const jsonp = require(&apos;koa-jsonp&apos;)const app = new Koa()// 使用中间件app.use(jsonp())app.use(async(ctx) =&gt; &#123; let returnData = &#123; success: true, data: &#123; text: &apos;this is a jsonp api&apos;, time: new Date().getTime(), &#125; &#125; // 直接输出JSON ctx.body = returnData&#125;)app.listen(3000, () =&gt; &#123; console.log(&apos;[demo] jsonp is starting at port 3000&apos;)&#125;) jsonp解析原理： JSONP跨域输出的数据是可执行的JavaScript代码 ctx输出的类型应该是’text/javascript’ ctx输出的内容为可执行的返回数据JavaScript代码字符串 需要有回调函数名callbackName，前端获取后会通过动态执行JavaScript代码字符，获取里面的数据 单元测试测试是一个项目周期里必不可少的环节，开发者在开发过程中也是无时无刻进行“人工测试”，如果每次修改一点代码，都要牵一发动全身都要手动测试关联接口，这样子是禁锢了生产力。为了解放大部分测试生产力，相关的测试框架应运而生，比较出名的有mocha，karma，jasmine等。虽然框架繁多，但是使用起来都是大同小异。 安装单元测试库npm install --save-dev mocha chai supertest mocha 模块是测试框架 chai 模块是用来进行测试结果断言库，比如一个判断 1 + 1 是否等于 2 supertest 模块是http请求测试库，用来请求API接口 创建demo程序12345678910111213141516171819202122232425262728293031323334353637383940const Koa = require(&apos;koa&apos;)const app = new Koa()const server = async(ctx, next) =&gt; &#123; let result = &#123; success: true, data: null &#125; if (ctx.method === &apos;GET&apos;) &#123; if (ctx.url === &apos;/getString.json&apos;) &#123; result.data = &apos;this is string data&apos; &#125; else if (ctx.url === &apos;/getNumber.json&apos;) &#123; result.data = 123456 &#125; else &#123; result.success = false &#125; ctx.body = result next &amp;&amp; next() &#125; else if (ctx.method === &apos;POST&apos;) &#123; if (ctx.url === &apos;/postData.json&apos;) &#123; result.data = &apos;ok&apos; &#125; else &#123; result.success = false &#125; ctx.body = result next &amp;&amp; next() &#125; else &#123; ctx.body = &apos;hello world&apos; next &amp;&amp; next() &#125;&#125;app.use(server)module.exports = appapp.listen(3000, () =&gt; &#123; console.log(&apos;[demo] test-unit is starting at port 3000&apos;)&#125;) 注意上述代码中有一句app.use(server)这是为了供测试框架调用，访问http://127.0.0.1:3000/getString.json，输出结果为：1234&#123;success: true,data: &quot;this is string data&quot;&#125; 测试框架代码123456789101112131415161718const supertest = require(&apos;supertest&apos;)const chai = require(&apos;chai&apos;)const app = require(&apos;../index&apos;)const expect = chai.expectconst request = supertest(app.listen())//测试组套件describe(&apos;开始测试demo的getString请求&apos;, //测试用例 it(&apos;测试/getString.json请求&apos;, (done) =&gt; &#123; request.get(&apos;/getString.json&apos;).expect(200).end((err, res) =&gt; &#123; expect(res.body).to.be.an(&apos;object&apos;) expect(res.body.success).to.be.an(&apos;boolean&apos;) expect(res.body.data).to.be.an(&apos;string&apos;) done() &#125;) &#125;)) 全部安装mocha后，直接在上述代码文件目录内执行mocha --harmony，执行结果如下：1234[demo] test-unit is starting at port 3000 √ 测试/getString.json请求 1 passing (46ms) 更新package.json中的包 安装：npm install -g npm-check-updates 检查package.json中dependencies的最新版本：ncu 更新dependencies到新版本：ncu -u 参考感谢让我站在肩膀上的大神chenshenhai。koa2实践5分钟讲透jsonp","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"koa2学习之路-01","slug":"2018-05-11-koa2学习之路-01","date":"2018-05-27T00:41:06.759Z","updated":"2018-05-27T00:41:06.759Z","comments":true,"path":"2018/05/27/2018-05-11-koa2学习之路-01/","link":"","permalink":"http://yoursite.com/2018/05/27/2018-05-11-koa2学习之路-01/","excerpt":"","text":"koa2学习之路-01继续尝试学习koa2，首先从helloworld开始，直接上代码。 helloworld123456789var koa = require(&apos;koa&apos;)var app = new koa()app.use(async(ctx) =&gt; &#123; ctx.body = &apos;hello koa2&apos;&#125;)app.listen(3000)console.log(&apos;server is running on port 3000&apos;) 运行上述js文件，通过浏览器访问127.0.0.1:3000。 async/await特点 可以让异步逻辑用同步写法实现 最底层的await返回需要是Promise对象 可以通过多层 async function的同步写法代替传统的callback嵌套 async 中间件在koa2中使用中间件的代码如下：12345678910function log(ctx) &#123; console.log(ctx.method, ctx.header.host + ctx.url)&#125;module.exports = function() &#123; return async function(ctx, next) &#123; log(ctx); await next(); &#125;;&#125; 调用中间的代码如下：123456789101112var koa = require(&apos;koa&apos;)var async_log = require(&apos;./middleware/async-log&apos;)var app = new koa()app.use(async_log())app.use(async(ctx) =&gt; &#123; ctx.body = &apos;hello koa2&apos;&#125;)app.listen(3000)console.log(&apos;server is running on port 3000&apos;) 综上可以看出所谓的middleware实际上就是一个async函数，函数最后需要用await 调用下一个middleware，上述代码中为await next()。koa2代码对middleware的编写顺序即为中间件的执行顺序。 java web的filter 可以使用 middleware去实现，包括校验用户是否登陆，均可以通过middleware实现。 GET请求数据获取使用方法在koa中，获取GET请求数据源头是koa中request对象中的query方法或querystring方法，query返回是格式化好的参数对象，querystring返回的是请求字符串，由于ctx对request的API有直接引用的方式，所以获取GET请求数据有两个途径。 是从上下文中直接获取 请求对象ctx.query，返回如 { a:1, b:2 } 请求字符串 ctx.querystring，返回如 a=1&amp;b=2 是从上下文的request对象中获取 请求对象ctx.request.query，返回如 { a:1, b:2 } 请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2 代码实例如下：12345678910111213141516171819202122var Koa = require(&apos;koa&apos;)var app = new Koa()app.use(async(ctx) =&gt; &#123; let url = ctx.url let ctx_query = ctx.query let ctx_query_string = ctx.querystring let request = ctx.request let request_query = request.query let request_query_string = request.querystring ctx.body = &#123; url, ctx_query, ctx_query_string, request_query, request_query_string &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log(&apos;[demo] request get is starting at port 3000&apos;)&#125;) POST请求参数post请求需要使用koa-body包获取表单提交的参数。12345678910111213141516171819202122232425262728293031323334var Koa = require(&apos;koa&apos;)var koaBody = require(&apos;koa-body&apos;)var app = new Koa()app.use(koaBody())app.use(async(ctx) =&gt; &#123; console.log(ctx.url) if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos;) &#123; // 当GET请求时候返回表单页面 let html = ` &lt;h1&gt;koa2 request post demo&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt; &lt;p&gt;nickName&lt;/p&gt; &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt; &lt;p&gt;email&lt;/p&gt; &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html &#125; else if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;POST&apos;) &#123; // 当POST请求的时候，解析POST表单里的数据，并显示出来 ctx.body = `Request Body: $&#123;JSON.stringify(ctx.request.body)&#125;`; &#125; else &#123; // 其他请求显示404 ctx.body = &apos;&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;&apos; &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log(&apos;[demo] request post is starting at port 3000&apos;)&#125;) 代码github地址 参考感谢让我站在肩膀上的大神chenshenhai。koa2学习进阶笔记","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"ES6学习之路07_Promise与async深入","slug":"2018-05-09-ES6学习之路07_Promise与async深入","date":"2018-05-10T23:51:40.833Z","updated":"2018-05-10T23:52:45.710Z","comments":true,"path":"2018/05/11/2018-05-09-ES6学习之路07_Promise与async深入/","link":"","permalink":"http://yoursite.com/2018/05/11/2018-05-09-ES6学习之路07_Promise与async深入/","excerpt":"","text":"ES6-学习之路-07 async Promise深入继续深入对js异步操作的学习，主要针对async和await。 Promise方式首先继续回顾Promise，Promise针对异步回调的处理方式，是通过链式，每一步resole data，并将数据传递给下一个then函数。123456789101112new Promise(function(resolve, reject) &#123; // if OK resolve(data); // if ERROR reject(error);&#125;).then(function(data) &#123; return turtle;&#125;).then(function(turtle) &#123; return turtleToRat&#125;).catch(function(error) &#123; // handle an error&#125;); fetch函数针对大多数浏览器都适用并且这个函数会返回一个Promise，下面是一个具体示例，我们会根据用户名访问github的用户信息和用户名下的仓库。123456789101112131415161718192021222324252627282930313233343536var fetch = require(&apos;node-fetch&apos;)function fetchGitProfile(username) &#123; return fetch(`https://api.github.com/users/$&#123;username&#125;`) .then((data) =&gt; data.json()) .then((&#123; bio, company, followers, following, repos_url &#125;) =&gt; (&#123; bio, company, followers, following, repos_url &#125;));&#125;function includeGitRepos(user) &#123; return fetch(user.repos_url) .then((data) =&gt; data.json()) .then((data) =&gt; data.map((&#123; name, stargazers_count &#125;) =&gt; (&#123; name, stargazers_count &#125;))) .then((repoList) =&gt; &#123; return &#123; ...user, repoList &#125;; &#125;);&#125;function log(data) &#123; console.log(data);&#125;fetchGitProfile(&apos;dumingcode&apos;) .then(includeGitRepos) .then(log); 以上代码也许仅仅比回调函数写的好理解一些，而且还需要深入理解Promise代码。 使用async/awaitasync/await 由ES7引入，这两个关键词需要共同使用，await必须在async函数中使用，绝对不能单独使用。一个有趣的特性是，这两个关键字适配Promise。如果一个函数返回结果是Promise你可以用await去resole，或者针对async函数的返回使用then去解析。 基本用法1234async function resolveMyData() &#123; const data = await fetchData(&apos;/a&apos;); return await fetchMoreData(&apos;/b/&apos; + data.id);&#125; 改写上述github代码：12345678910111213141516171819202122232425262728var fetch = require(&apos;node-fetch&apos;)async function fetchGitProfile(username) &#123; const userinfo = await fetch(`https://api.github.com/users/$&#123;username&#125;`) let &#123; bio, company, followers, following, repos_url &#125; = await userinfo.json() return &#123; bio, company, followers, following, repos_url &#125;&#125;async function includeGitRepos(repoUrl) &#123; const repo = await fetch(repoUrl) .then((data) =&gt; data.json()); return repo.map((&#123; name, stargazers_count &#125;) =&gt; (&#123; name, stargazers_count &#125;));&#125;async function resolveGithubProfile() &#123; const profile = await fetchGitProfile(&apos;duming&apos;); const repoList = await includeGitRepos(profile.repos_url); console.log(&#123; ...profile, repoList &#125;);&#125;;resolveGithubProfile(); 上述代码中includeGitRepos中的fetch API后跟着一个then函数，fetch函数仍然会返回一个Promise。 并行异步调用没必要针对每一个函数都使用一个await函数，可以并行地调用，并逐个处理每个请求的返回值:1234567891011async function resolveGithubProfileParallel() &#123; let dumingPromise = fetchGitProfile(&apos;dumingcode&apos;) let octocatPromise = fetchGitProfile(&apos;octocat&apos;) const duming = await dumingPromise; const octocat = await octocatPromise; // this will complete in the same time as rkotzePromise. return [duming, octocat, &quot;done!&quot;];&#125;resolveGithubProfileParallel().then((data) =&gt; &#123; console.log(data)&#125;) 使用promise all12345678910111213141516Promise.all([fetchGitProfile(&apos;rkotze&apos;), fetchGitProfile(&apos;octocat&apos;)]).then(function(values) &#123; console.log(values);&#125;);输出（注意输出的是一个数组）：[ &#123; bio: &apos;Software engineer. Currently into ES6, ReactJS, NodeJS and Elixir.&apos;, company: &apos;@findmypast&apos;, followers: 24, following: 52, repos_url: &apos;https://api.github.com/users/rkotze/repos&apos; &#125;, &#123; bio: null, company: &apos;GitHub&apos;, followers: 2238, following: 5, repos_url: &apos;https://api.github.com/users/octocat/repos&apos; &#125; ] 异步测试框架优先研究一下MochaMochaJestJasmine codewar挑战如果能通过这个挑战，说明你掌握了js异步，点击链接code war异步挑战 参考感谢大神们，让我站在你们的肩膀上。promises-async-await-testing","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"ES6-学习之路-06promise-async","slug":"2018-05-08-ES6学习之路06_Promise深入","date":"2018-05-08T01:28:52.562Z","updated":"2018-05-10T23:52:45.706Z","comments":true,"path":"2018/05/08/2018-05-08-ES6学习之路06_Promise深入/","link":"","permalink":"http://yoursite.com/2018/05/08/2018-05-08-ES6学习之路06_Promise深入/","excerpt":"","text":"ES6-学习之路-06promise-async刚接触ES6学了好久，对promise、async、await还是一知半解，so 我能怎么办呢，网上找资料抄代码，研究一番。 回调函数地域当使用回调函数来进行事件处理的时候，如果嵌套多层回调函数的时候，就会出现回调地狱，例如：123456789101112131415161718192021method1(function(err, result) &#123; if (err) &#123; throw err; &#125; method2(function(err, result) &#123; if (err) &#123; throw err; &#125; method3(function(err, result) &#123; if (err) &#123; throw err; &#125; method4(function(err, result) &#123; if (err) &#123; throw err; &#125; method5(result); &#125;); &#125;); &#125;);&#125;); 本例一样嵌套多个方法调用会创建错综复杂的代码，会难以理解与调试。当想要实现更复杂的功能时，回调函数也会存在问题。要是你想让两个异步操作并行运行，并且在它们都结束后提醒你，那该怎么做？要是你想同时启动两个异步操作，但只采用首个结束的结果，那又该怎么做？而使用Promise就能避免回调地狱的情况。 Promise可以当做是一个占位符，表示异步操作的执行结果。函数可以返回一个Promise，而不必订阅一个事件或者向函数传递一个回调函数。 Promise生命周期每个 Promise 都会经历一个短暂的生命周期，初始为挂起状态（pending state） ，这表示异步操作尚未结束。一个挂起的 Promise 也被认为是未决的（unsettled )。一旦异步操作结束， Promise就会被认为是已决的（settled ） ，并进入两种可能状态之一： 已完成（fulfilled ） ： Promise 的异步操作已成功结束； 已拒绝（rejected ） ： Promise 的异步操作未成功结束，可能是一个错误，或由其他原因导致。内部的[[PromiseState]] 属性会被设置为”pending” 、 “fulfilled” 或 “rejected”，以反映Promise的状态。该属性并未在 Promise 对象上被暴露出来，因此你无法以编程方式判断 Promise 到底处于哪种状态。不过你可以使用then()方法在 Promise 的状态改变时执行一些特定操作。 then方法then()方法在所有的 Promise 上都存在，并且接受两个参数。第一个参数是 Promise 被完成时要调用的函数，异步操作的结果数据都会被传入这个完成函数。第二个参数则是 Promise 被拒绝时要调用的函数，与完成函数相似，拒绝函数会被传入与拒绝相关联的任何附加数据。then()方法的两个参数是可选的，因此可以自由组合监听完成和失败的处理函数； catch方法Promise有catch()方法，等同于只传递拒绝处理函数给then()方法：123456789promise.catch(function(err) &#123; // 拒绝 console.error(err.message);&#125;);// 等同于：promise.then(null, function(err) &#123; // 拒绝 console.error(err.message);&#125;); 创建未决的Promise使用Promise构造器可以创建一个Promise实例，此构造器接收一个参数：一个被称之为执行器（excutor）的函数，该函数包含了resolve()函数和reject()函数这两个参数。resolve()函数在异步任务执行成功时调用，而reject()函数在异步任务执行失败时调用。例如：1234567891011let pro = new Promise((resolve, reject) =&gt; &#123; console.log(&apos;hi promise&apos;)&#125;)pro.then(() =&gt; &#123; console.log(&apos;hi then&apos;)&#125;)输出：hi promisei am resole parameterhi then 从输出结果可以看出，Promise构造器中的代码是最先执行的，而then()代码是最后执行的，这是因为只有在Promise中的处理器函数执行结束之后，then()方法中的完成处理函数或者拒绝处理函数才会添加到作业队列的尾部。 创建已决的Promise使用Promise.resolve()Promise.resolve()方法接收一个参数，并会返回一个处于已完成状态的 Promise ，在then()方法中使用完成处理函数才能提取该完成态的Promise传递的值，例如：1234let promise = Promise.resolve(&apos;hi&apos;);promise.then((value) =&gt; &#123; console.log(value); //hi&#125;); 使用Promise.reject()可以使用Promise.reject()方法来创建一个已拒绝状态的Promise，同样只有在拒绝处理函数中或者catch()方法中才能接受reject()方法传递的值：1234let promise_rec = Promise.reject(&apos;reject&apos;)promise_rec.catch((val) =&gt; &#123; console.log(val)&#125;) 执行器错误当执行器内部抛出错误，那么Promise的拒绝处理函数就会被调用，例如：123456let promise_catch = new Promise((resolve, reject) =&gt; &#123; throw new Error(&apos;Error!&apos;)&#125;)promise_catch.catch((msg) =&gt; &#123; console.log(msg)&#125;) Promise链除了使用单个Promise外，多个Promise可以进行级联使用，实际上then()方法或者catch()方法会返回一个新的Promise，仅当前一个Promise被决议之后，后一个Promise才会进行处理。 串联调用12345678910/**串联Promise链 */let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;p1串联链式调用&apos;)&#125;)p1.then((val) =&gt; &#123; console.log(val) throw new Error(&apos;串联调用抛出异常Err&apos;)&#125;).catch((msg) =&gt; &#123; console.log(msg)&#125;) 可以看出当p1的then()方法执行结束后会返回一个Promise，因此，在此基础上可以继续执行catch()方法。同时，Promise链允许捕获前一个Promise的错误。 Promise链中传值Promise链的另一个重要方面是能从一个Promise传递数据给另一个Promise的能力。**前一个Promise的完成处理函数的返回值，传递到下一个Promise中。12345678910/**Promise链中传值 */let p2 = new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;)p2.then((val =&gt; val + 1)).then((val) =&gt; &#123; console.log(val)&#125;)输出：2 Promise链中传递Promise在完成或者拒绝处理函数中可以返回基本类型值，从而可以在Promise链中传递。另外，在Promise链中也可以传递对象，如果传递的是Promise对象，就需要额外的处理。12345678910111213/**Promise链中传Promise */let p31 = new Promise((resolve, reject) =&gt; &#123; resolve(100)&#125;)let p41 = new Promise((resolve, reject) =&gt; &#123; resolve(200)&#125;)p31.then((val) =&gt; &#123; console.log(val) return p41&#125;).then((value) =&gt; &#123; console.log(value)&#125;) 如果传递的是reject，则代码如下1234567891011121314151617let p32 = new Promise((resolve, reject) =&gt; &#123; resolve(100)&#125;)let p42 = new Promise((resolve, reject) =&gt; &#123; reject(200)&#125;)p32.then((val) =&gt; &#123; console.log(val) return p42&#125;).then(() =&gt; &#123; console.log(&apos;检验是否执行&apos;)&#125;).catch((value) =&gt; &#123; console.log(value)&#125;)输出：100200 注：上面代码P42的then函数没有执行。 响应多个Promise如果想监视多个Promise的状态，从而决定下一步动作，可以使用ES6提供的两个方法：Promise.all()和Promise.race()； Promise.allPromise.all()方法能接受单个可迭代对象（如数组）作为参数，可迭代对象的元素都是Promise。该方法会返回一个Promise，只有传入所有的Promise都已完成，所返回的Promise才会完成，例如：12345678910111213let p1 = new Promise((resolve, reject) =&gt; &#123; console.log(&apos;p1&apos;)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; console.log(&apos;p2&apos;)&#125;)let p3 = new Promise((resolve, reject) =&gt; &#123; console.log(&apos;p3&apos;)&#125;)let p4 = Promise.all([p1, p2, p3]).then((arr) =&gt; &#123; console.log(arr)&#125;) 对 Promise.all() 的调用创建了新的Promise p4，在 p1 、 p2 与 p3 都被完成后， p4 最终会也被完成。传递给 p4 的完成处理函数的结果是一个包含每个决议值（1 、 2 与 3 ） 的数组，这些值的存储顺序保持了待决议的 Promise 的顺序（与完成的先后顺序无关） ，因此你可以将结果匹配到每个Promise。1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;p1&apos;)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; reject(&apos;p2&apos;)&#125;)let p3 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;p3&apos;)&#125;)let p4 = Promise.all([p1, p2, p3]).then((arr) =&gt; &#123; console.log(arr)&#125;).catch((msg) =&gt; &#123; console.log(msg)&#125;)输出:p2 在此例中， p2 被使用数值 2 进行了拒绝，则 p4 的拒绝处理函数就立刻被调用，而不会 等待 p1 或 p3 结束执行（它们仍然会各自结束执行，只是 p4 不等它们） 。拒绝处理函数总会接受到单个值，而不是一个数组。该值是被拒绝的Promise所返回的拒绝值。 Promise.race()Promise.race()方法接收一个元素是Promise的可迭代对象，并返回一个新的Promise。一旦传入Promise.race()的可迭代对象中有一个Promise是已决状态，那么返回的Promise对象就会立刻成为已决状态。而Promise.all()方法得必须等到所有传入的Promise全部变为已决状态，所返回的Promise才会已决。123456789101112131415161718192021let p1 = new Promise(function(resolve, reject) &#123; resolve(1);&#125;)let p2 = new Promise(function(resolve, reject) &#123; resolve(2);&#125;)let p3 = new Promise(function(resolve, reject) &#123; resolve(3);&#125;)let p4 = Promise.race([p1, p2, p3]);p4.then(value =&gt; &#123; console.log(Array.isArray(value)); //false console.log(value); //1&#125;)输出：false1 romise.race() 方法传入的Promise中哪一个Promise先变成已完成状态，就会将值传递给所返回的Promise对象的完成处理函数中。若哪一个Promise最先变成已拒绝状态，同样的，会将值传递给p4的拒绝处理函数中。 Promise总结 参考感谢以下各位大神，让我站在你们的肩膀上。掘金-你听___","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"nodejs学习之路03-express webscoket","slug":"2018-05-07-nodejs学习之路03","date":"2018-05-07T01:00:31.946Z","updated":"2018-05-07T01:01:04.651Z","comments":true,"path":"2018/05/07/2018-05-07-nodejs学习之路03/","link":"","permalink":"http://yoursite.com/2018/05/07/2018-05-07-nodejs学习之路03/","excerpt":"","text":"expressConnect基于http提供了web开发常用的基础功能，express又在Connect基础上提供了构建整个网站和web更为方便的API。通过一个小demo项目熟悉express的用法。demo程序实现的内容： 提供一个表单，接受用户的输入。 输入作为检索关键字，调用tweetAPI，并将返回结果返回给用户。ejs模板文件创建index.ejs和result.ejs12345678index.ejs&lt;h1&gt; Twitter app &lt;/h1&gt;&lt;p&gt;Please enter your search name&lt;/p&gt;&lt;form action=&quot;/search&quot; method=&quot;GET&quot;&gt; name: &lt;input type=&quot;text&quot; name=&quot;q&quot; /&gt; &lt;button&gt;search&lt;/button&gt;&lt;/form&gt; result.ejs实现比较简单，仅仅是回调一下函数12&lt;h1&gt;查询结果：&lt;/h1&gt;&lt;%= results %&gt; nodejs webserver代码注意下面的express代码使用的是最新的express库，《了不起的nodejs》书中的API已经严重老化了。123456789101112131415161718192021222324var express = require(&apos;express&apos;)var app = express();app.set(&apos;view engine&apos;, &apos;ejs&apos;)app.set(&apos;views&apos;, __dirname + &apos;/views&apos;)app.set(&apos;view options&apos;, &#123; layout: false &#125;)app.get(&apos;/&apos;, function(req, res) &#123; res.render(&apos;index&apos;)&#125;);app.get(&apos;/search&apos;, function(req, res, next) &#123; console.log(&apos;Accessing the secret section ...&apos;); res.render(&apos;result&apos;, &#123; results: req.param(&apos;q&apos;) &#125;)&#125;);var server = app.listen(3000, function() &#123; var host = server.address().address; var port = server.address().port; console.log(&apos;Example app listening at http://%s:%s&apos;, host, port);&#125;); package.json文件123456789101112131415&#123; &quot;name&quot;: &quot;express-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;express demo&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;duming&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;ejs&quot;: &quot;^2.6.1&quot;, &quot;express&quot;: &quot;^4.16.3&quot; &#125;&#125; 代码组织策略一个项目可能会有非常多的路由，这时良好的代码组织策略非常必要。比如一个应用包含三个模块，\\blog、\\tags、\\pages，每个版块都包含各自的路由，例如：/blog/search,/tags/new,/pages/del。 好的代码组织方式，就是维护一个server.js，该文件包含了路由表。同时将每一个部分的路由处理器通过模块化的方式引入，如blog.js，tags.js，pages.js，首先定义依赖的模块，并初始化app定义中间件。1234567891011121314151617var express = require(&apos;express&apos;), blog = require(&apos;/blog&apos;), tags = require(&apos;/tags&apos;), pages = require(&apos;/pages&apos;)var app = express();//blog routesapp.get(&apos;/blog&apos;,blog.home)app.get(&apos;/blog/search&apos;,blog.search)//tags routesapp.get(&apos;/tags&apos;,tags.home)app.get(&apos;/tags/search&apos;,tags.search)//pages routesapp.get(&apos;/pages&apos;,pages.home)app.get(&apos;/pages/search&apos;,pages.search) 以blog.js为例，针对每个路由函数使用exports123exports.home = function(res,rep,next)&#123; &#125; websocketwebsocket是web下的TCP， 一个底层的双向socket， 允许用户对消息传递进行控制。websocket包含两个部分：一个是前端浏览器实现的WebSocket API，另一个是服务器端实现的WebSocket协议，websocket还是建立在http之上。websocket是双向的，这样server可以向客户端主动推送数据，而之前的http协议交互是单向的，只能是客户端请求server。 （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 代码实例本文采用ws包实现server端的web service协议。server端代码如下：12345678910const WebSocket = require(&apos;ws&apos;);const wss = new WebSocket.Server(&#123; port: 8181 &#125;);wss.on(&apos;connection&apos;, function connection(ws) &#123; ws.on(&apos;message&apos;, function incoming(message) &#123; console.log(&apos;received: %s&apos;, message); &#125;); ws.send(&apos;something&apos;);&#125;); frontend代码如下：123456789101112131415&lt;h1&gt; Twitter app &lt;/h1&gt;&lt;p&gt;Please enter your search name&lt;/p&gt;&lt;input type=&quot;text&quot; name=&quot;message&quot; id=&quot;message&quot; placeholder=&quot;Type text to echo in here&quot; value=&quot;&quot; /&gt;&lt;button onclick=&quot;sendMessage();&quot;&gt;提交&lt;/button&gt;&lt;script&gt; var ws = new WebSocket(&quot;ws://localhost:8181&quot;); ws.onopen = function(e) &#123; console.log(&apos;Connection to server opened&apos;); &#125; function sendMessage() &#123; ws.send(&quot;test&quot;); &#125;&lt;/script&gt; 参考《了不起的nodejs》express官方网站阮一峰老师blog","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"nodejs学习之路02","slug":"2018-05-06-nodejs学习之路02","date":"2018-05-06T04:03:34.769Z","updated":"2018-05-06T04:10:07.225Z","comments":true,"path":"2018/05/06/2018-05-06-nodejs学习之路02/","link":"","permalink":"http://yoursite.com/2018/05/06/2018-05-06-nodejs学习之路02/","excerpt":"","text":"nodejs学习之路02简单http代码实例1234567var http = require(&apos;http&apos;)http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;text/html&apos; &#125;) res.end(&apos;Hello &lt;b&gt;World&lt;/b&gt;&apos;)&#125;).listen(3000) 下面尝试另一个案例，通过http协议传输png文件，体会png文件传输中对chunk的使用。12345678910111213141516171819var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;iamge/png&apos; &#125;) //创建png视图 let stream = fs.createReadStream(&apos;D:/Workspaces/blog/source/images/docker_vm.png&apos;) stream.on(&apos;data&apos;, (data) =&gt; &#123; res.write(data) &#125;) stream.on(&apos;end&apos;, () =&gt; &#123; res.end() &#125;) stream.on(&apos;error&apos;, (err) =&gt; &#123; console.log(err) &#125;)&#125;).listen(3000) http实战demo通过nodejs http API完成一个实际的任务，接收浏览器传来的form数据。首先构建一个发送表单的http服务，代码如下所示：123456var http = require(&apos;http&apos;)http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;text/html&apos; &#125;) res.end([&apos;&lt;form method=&quot;post&quot; action=&quot;/url&quot;&gt;&apos;, &apos;&lt;h1&gt;My Form&lt;/h1&gt;&apos;, &apos;&lt;fieldset&gt;&apos;, &apos;&lt;label&gt;Personal information&lt;/label&gt;&apos;, &apos;&lt;p&gt;what is your name?&lt;/p&gt;&apos;, &apos;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/input&gt;&apos;, &apos;&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;&apos;, &apos;&lt;/form&gt;&apos;].join(&apos;&apos;))&#125;).listen(3000) 点击表单中的按钮，因为server端没有/url的具体方法，所以无响应。下面增加提交按钮响应逻辑(接受并将输入的name返回到新的页面中,若访问的url不存在返回404)：12345678910111213141516171819var http = require(&apos;http&apos;)http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;text/html&apos; &#125;) let body = &apos;&apos; if (&apos;/&apos; == req.url) res.end([&apos;&lt;form method=&quot;post&quot; action=&quot;/url&quot;&gt;&apos;, &apos;&lt;h1&gt;My Form&lt;/h1&gt;&apos;, &apos;&lt;fieldset&gt;&apos;, &apos;&lt;label&gt;Personal information&lt;/label&gt;&apos;, &apos;&lt;p&gt;what is your name?&lt;/p&gt;&apos;, &apos;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/input&gt;&apos;, &apos;&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;&apos;, &apos;&lt;/form&gt;&apos;].join(&apos;&apos;)) else if (&apos;/url&apos; == req.url) &#123; req.on(&apos;data&apos;, (chunk) =&gt; &#123; body += chunk &#125;) req.on(&apos;end&apos;, () =&gt; &#123; res.end(`your name is:$&#123;body&#125;`) &#125;) &#125; else &#123; res.writeHead(404) res.end(&apos;not found&apos;) &#125;&#125;).listen(3000) http客户端http包提供了request API，但是本人倾向于使用axios第三方包。axios get请求是一个promise函数，封装了抽象的函数。12345678var axios = require(&apos;axios&apos;)axios.get(&apos;http://www.sse.com.cn/assortment/stock/list/info/company/index.shtml?COMPANY_CODE=600033&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); connect 中间件尝试使用一个demo来熟悉connet中间件，demo功能如下： 托管静态文件 处理错误以及损坏或者不存在的文件 处理不同类型的请求新建package.json文件12345678&#123; &quot;name&quot;: &quot;connect&quot;, &quot;version&quot;: &quot;0.01&quot;, &quot;description&quot;: &quot;a simple connect demo&quot;, &quot;dependencies&quot;: &#123; &quot;connect&quot;: &quot;^3.6.6&quot; &#125;&#125; 了不起的nodejs这本书中提供的例子实在是太老了，所以我按照现在的API重写了下面的代码。12345678910var finalHandler = require(&apos;finalHandler&apos;)var http = require(&apos;http&apos;)var serveStatic = require(&apos;serve-static&apos;)console.log(__dirname)var serve = serveStatic(__dirname, &#123; &apos;index&apos;: [&apos;1.html&apos;] &#125;)var server = http.createServer((req, res) =&gt; &#123; serve(req, res, finalHandler(req, res))&#125;)server.listen(3000) 除了http包，finalHandler和serve-static。在书写大型应用时，每个请求可能会触发多个功能，如果把这些功能代码都放在一个回调函数中，函数逻辑会很复杂。这时候可以考虑使用中间件机制，中间件本质上是函数。中间件函数除了接受req和res，还可以接受一个next函数来做流控制。这样一个大的业务逻辑，可以划分成多个中间件函数，业务逻辑划分就比较清晰了,next函数会按代码编写顺序由上到下执行，直到最后一个没有调用next函数为止。12345678app.use(function middleware1(req, res, next) &#123; // middleware 1 next();&#125;);app.use(function middleware2(req, res, next) &#123; // middleware 2 next();&#125;); 实践代码：12345678910111213141516171819202122232425262728293031var connect = require(&apos;connect&apos;)var http = require(&apos;http&apos;)var app = connect()var serveStatic = require(&apos;serve-static&apos;)var cookieSession = require(&apos;cookie-session&apos;)/**静态服务器 */app.use((req, res, next) =&gt; &#123; serveStatic(__dirname, &#123; &apos;index&apos;: [&apos;1.html&apos;] &#125;) next()&#125;)/**打印访问url */app.use((req, res, next) =&gt; &#123; console.log(req.url) next()&#125;)/**打印访问url */app.use((req, res, next) =&gt; &#123; console.log(req.method)&#125;)http.createServer(app).listen(3000) npm install命令总结一直都是直接输入npm install 直接输入，今天整理下这条命令的相关用法。 npm install 会把X包安装到node_modules目录中 不会修改package.json 之后运行npm install命令时，不会自动安装Xnpm install X –save: 会把X包安装到node_modules目录中 会在package.json的dependencies属性下添加X 之后运行npm install命令时，会自动安装X到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，会自动安装msbuild到node_modules目录中 npm install X –save-dev: 会把X包安装到node_modules目录中 会在package.json的devDependencies属性下添加X 之后运行npm install命令时，会自动安装X到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，不会自动安装X到node_modules目录中 使用原则:运行时需要用到的包使用–save，否则使用–save-dev。 参考npm install","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"ES6学习之路05","slug":"2018-05-03-ES6学习之路05","date":"2018-05-03T00:34:13.782Z","updated":"2018-05-03T00:34:51.359Z","comments":true,"path":"2018/05/03/2018-05-03-ES6学习之路05/","link":"","permalink":"http://yoursite.com/2018/05/03/2018-05-03-ES6学习之路05/","excerpt":"","text":"ES6-学习之路-05用Proxy进行预处理在运行函数前初始化一些数据，在改变对象值后做一些善后处理。这些都算钩子函数，Proxy的存在就可以让我们给函数加上这样的钩子函数，你也可以理解为在执行方法前预处理一些代码。你可以简单的理解为他是函数或者对象的生命周期。 首先定义对象如下：12345678let obj = &#123; add: (val) =&gt; &#123; return val + 100 &#125;, name: &apos;I am du&apos;&#125;console.log(obj.add(10))console.log(obj.name) 声明proxy用new的方法对Proxy进行声明。可以看一下声明Proxy的基本形式。new Proxy（{},{}） 以下是定义proxy的完整代码：12345678910111213/** 定义proxy*/let pro = new Proxy(&#123; add: (val) =&gt; &#123; return val + 100 &#125;, name: &apos;I am du&apos;&#125;, &#123; get: (target, key, property) =&gt; &#123; console.log(&apos;before get&apos;) return target[key] &#125;&#125;)console.log(pro.name) get属性 target：得到的目标值 key：目标的key值，相当于对象的属性 property：这个不太常用，用法还在研究中，还请大神指教。 set属性set属性是值你要改变Proxy属性值时，进行的预先处理。它接收四个参数： target:目标值。 key：目标的Key值。 value：要改变的值。 receiver：改变前的原始值。 123456789101112131415161718192021222324252627let pro = new Proxy(&#123; add: (val) =&gt; &#123; return val + 100 &#125;, name: &apos;I am du&apos;&#125;, &#123; get: (target, key, property) =&gt; &#123; console.log(&apos;before get&apos;) return target[key] &#125;, set: (target, key, value, receiver) =&gt; &#123; console.log(`$&#123;receiver[key]&#125;=&gt;$&#123;value&#125; `) return target[key] = value &#125;&#125;)console.log(pro.name)pro.name = &apos;ming&apos;console.log(pro.name)输出如下：before getproxy.js:28 I am duproxy.js:20 before getproxy.js:24 I am du=&gt;ming proxy.js:20 before getproxy.js:30 ming applyapply的作用是调用内部的方法，它使用在方法体是一个匿名函数。12345678910111213let target = function() &#123; return &apos;I am test&apos;;&#125;;var handler = &#123; apply(target, ctx, args) &#123; console.log(&apos;do apply&apos;); return Reflect.apply(...arguments); &#125;&#125;var pro2 = new Proxy(target, handler);console.log(pro2()); promise使用ES6中的promise的出现给我们很好的解决了回调地狱的问题，在使用ES5的时候，在多层嵌套回调时，写完的代码层次过多，很难进行维护和二次开发，ES6认识到了这点问题，现在promise的使用，完美解决了这个问题。那我们如何理解promise这个单词在ES5中的作用那，你可以想象他是一种承诺，当它成功时执行一些代码，当它失败时执行一些代码,更符合人类的行为思考习惯。 promise的基本用法promise执行多步操作非常好用，那我们就来模仿一个多步操作的过程，那就以吃饭为例吧。要想在家吃顿饭，是要经过三个步骤： 洗菜做饭。 坐下来吃饭。 收拾桌子洗碗。这个过程是有一定的顺序的，你必须保证上一步完成，才能顺利进行下一步，现在用promise来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142/**promise的使用 */let state = 1;function step1(resolve, reject) &#123; console.log(&apos;1.开始-洗菜做饭&apos;); if (state == 1) &#123; resolve(&apos;洗菜做饭--完成&apos;); &#125; else &#123; reject(&apos;洗菜做饭--出错&apos;); &#125;&#125;function step2(resolve, reject) &#123; console.log(&apos;2.开始-坐下来吃饭&apos;); if (state == 1) &#123; resolve(&apos;坐下来吃饭--完成&apos;); &#125; else &#123; reject(&apos;坐下来吃饭--出错&apos;); &#125;&#125;function step3(resolve, reject) &#123; console.log(&apos;3.开始-收拾桌子洗完&apos;); if (state == 1) &#123; resolve(&apos;收拾桌子洗完--完成&apos;); &#125; else &#123; reject(&apos;收拾桌子洗完--出错&apos;); &#125;&#125;new Promise(step1).then(function(val) &#123; console.log(val); return new Promise(step2);&#125;).then(function(val) &#123; console.log(val); return new Promise(step3);&#125;).then(function(val) &#123; console.log(val); return val;&#125;); 上面示例代码中，resolve 和 reject是两个函数变量，resole函数在Promise对象执行成功的时候触发，reject函数则在Promise对象执行失败的时候触发，Promise实际上就是前面说过的Proxy。 class类的使用class的定义见如下代码：12345678class Code &#123; name(val) &#123; console.log(val) &#125;&#125;let code = new Codecode.name(&apos;duduming&apos;)console.log(code.name) class类内多函数互相调用：123456789101112class Code &#123; name(val) &#123; console.log(val) return val &#125; anthorM(val) &#123; console.log(this.name(&apos;test&apos;) + &apos; another method&apos; + val) &#125;&#125;let code = new Code //code.name(&apos;duduming&apos;)code.anthorM(&apos;ano&apos;) 类的构造函数：通过constructor构造函数，向class内传参，然后在class内的方法中使用参数。12345678910111213141516171819class Code &#123; name(val) &#123; console.log(val) return val &#125; anthorM(val) &#123; console.log(this.name(&apos;test&apos;) + &apos; another method&apos; + val) &#125; add() &#123; return this.a + this.b &#125; constructor(a, b) &#123; this.a = a this.b = b &#125;&#125;let code = new Code(3, 4) //code.name(&apos;duduming&apos;)console.log(code.add()) class的继承,通过extends关键字。123456789101112131415161718192021222324class Code &#123; name(val) &#123; console.log(val) return val &#125; anthorM(val) &#123; console.log(this.name(&apos;test&apos;) + &apos; another method&apos; + val) &#125; add() &#123; return this.a + this.b &#125; constructor(a, b) &#123; this.a = a this.b = b &#125;&#125;class SonCode extends Code &#123;&#125;let sonCode = new SonCode(3, 4) //code.name(&apos;duduming&apos;)console.log(sonCode.add(4, 5)) 模块化exportexport可以让我们把变量，函数，对象进行模块话，提供外部调用接口，让外部进行引用。先来看个最简单的例子，把一个变量模块化。我们新建一个temp.js文件，然后在文件中输出一个模块变量。 export default的使用加上default相当是一个默认的入口。在一个文件里export default只能有一个。我们来对比一下export和export default的区别 export12345export var a =&apos;jspang&apos;; export function add(a,b)&#123; return a+b;&#125; 对应的引入方法：12345export var a =&apos;jspang&apos;; export function add(a,b)&#123; return a+b;&#125; export default1export default var a=&apos;jspang&apos; 对应引入方式1import str from &apos;./temp&apos;; 参考链接技术胖blog","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路04","slug":"2018-05-02-ES6学习之路04","date":"2018-05-02T00:51:46.193Z","updated":"2018-05-02T01:55:56.755Z","comments":true,"path":"2018/05/02/2018-05-02-ES6学习之路04/","link":"","permalink":"http://yoursite.com/2018/05/02/2018-05-02-ES6学习之路04/","excerpt":"","text":"ES6-学习之路-04对象key值构建有时候我们会在后台定义key值，而不是我们前台定义好的，这时候我们如何构建我们的key值。比如我们在后台取了一个key值，然后可以用[ ] 的形式，进行对象的构建。123456/**key值构建 */let key = &apos;name&apos;let obj = &#123; [key]: &apos;duming&apos;&#125;console.log(obj[&apos;name&apos;]) 自定义对象方法对象方法就是把兑现中的属性，用匿名函数的形式编程方法。1234567/**自定义对象方法 */let objFun = &#123; add: (a, b) =&gt; &#123; return a + b &#125;&#125;console.log(objFun.add(3, 4)) Object.is( ) 对象比较对象的比较方法,以前进行对象值的比较，经常使用===来判断，比如下面的代码：123456789 /**对象比较 */let obj1 = &#123; name: &apos;duming&apos; &#125;let obj2 = &#123; name: &apos;duming&apos; &#125;console.log(obj1.name === obj2.name)console.log(Object.is(obj1.name, obj2.name))console.log(Object.is(obj1, obj2)) /** * output: true true false */ ====表示值相等，Object.is()表示严格相等。 Object.assign( )合并对象123456789 /**合并对象 */let obja1 = &#123; tel: &apos;187&apos; &#125;let obja2 = &#123; address: &apos;js&apos; &#125;let obja3 = &#123; age: &apos;20&apos; &#125;let objA = Object.assign(obja1, obja2, obja3)console.log(objA) /** * &#123;tel: &quot;187&quot;, address: &quot;js&quot;, age: &quot;20&quot;&#125; */ Set和WeakSet数据结构首先看set的声明12let setdemo1 = new Set([&apos;apple&apos;, &apos;pear&apos;])console.log(setdemo1) Set和Array 的区别是Set不允许内部有重复的值，如果有只显示一个，相当于去重。虽然Set很像数组，但是他不是数组。增删改查示例代码：1234567891011121314151617181920212223/**set的声明 */let setdemo = new Set([&apos;apple&apos;, &apos;pear&apos;])console.log(setdemo) /** * Set(2) &#123;&quot;apple&quot;, &quot;pear&quot;&#125; */ /**set的增删改查 */setdemo.add(&apos;orange&apos;)setdemo.delete(&apos;apple&apos;)console.log(setdemo.has(&apos;apple&apos;))console.log(setdemo.has(&apos;pear&apos;))/**循环 foreach*/setdemo.forEach(item =&gt; &#123; console.log(item)&#125;)/** * 输出 * falsepearorang */ WeakSet跟Set相比，WeakSet的特点如下： 作为Object的容器，而不是简单类型 WeakSet中的对象如果没有其他地方引用，会被垃圾回收吸收掉。12345678910111213/**WeakSet */var ws = new WeakSet();var windows = &#123;&#125;;var foo = &#123;&#125;;ws.add(windows);ws.has(windows); // truews.has(foo); // false, foo has not been added to the setws.delete(windows); // removes window from the setws.has(windows); // false, window has been removed Map数据结构在一些构建工具中是非常喜欢使用map这种数据结构来进行配置的，因为map是一种灵活，简单的适合一对一查找的数据结构。我们知道的数据结构，已经有了json和set。那map有什么特点。123456789101112131415161718let json = &#123; name: &apos;du&apos;, age: 20&#125;console.log(json)/**map数据结构 */let map1 = new Mapmap1.set(&apos;name&apos;, &apos;du2&apos;)map1.set(&apos;age&apos;, 20)map1.set(&apos;json&apos;, json)console.log(map1)/** * 输出 * &#123;name: &quot;du&quot;, age: 20&#125;Map(3) &#123;&quot;name&quot; =&gt; &quot;du2&quot;, &quot;age&quot; =&gt; 20, &quot;json&quot; =&gt; &#123;…&#125;&#125; */ Map增删改查map的增删改查语句如下：12345map1.delete(&apos;json&apos;)map1.forEach(item =&gt; &#123; console.log(item)&#125;)console.log(map1.get(&apos;json&apos;)) 参考链接技术胖老师blog","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"nodejs学习之路01-异步调用与net fs核心类库","slug":"2018-05-01-nodejs学习之路01","date":"2018-05-01T08:00:18.686Z","updated":"2018-05-01T08:11:05.404Z","comments":true,"path":"2018/05/01/2018-05-01-nodejs学习之路01/","link":"","permalink":"http://yoursite.com/2018/05/01/2018-05-01-nodejs学习之路01/","excerpt":"","text":"nodejs学习之路01本文github地址 https://github.com/dumingcode/nodejs-demo.git 异步调用实例123456789console.log(&quot;Hello&quot;);setTimeout(() =&gt; &#123; console.log(&quot;World&quot;) &#125;, 5000)console.log(&quot;非阻塞&quot;);output:node src\\demo01.js Hello非阻塞World 如上例所示setTimeOut是非阻塞的，程序没有等待而是直接执行了打印非阻塞信息，nodejs一切调用都是异步的。 单线程1234567891011121314151617/**单线程示例 */let start = new Date()console.log(start)setTimeout(() =&gt; &#123; console.log(Date.now() - start.getTime()) for (let i = 0; i &lt; 100000000000; i++) &#123;&#125;&#125;, 1000)setTimeout(() =&gt; &#123; console.log(Date.now() - start.getTime())&#125;, 2000)output:node src\\singleThread.js 2018-04-30T07:03:54.402Z1009160788 可以看到第二个setTimeOut的执行时间为160788秒，这是一个非常大的数字。 Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况： 如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用； 如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件上述代码就是因为是非IO任务，所以耗费了主进程计算时间，使主进程无法执行事件循环，所以nodejs不适合执行CPU计算密集型任务。单线程总结 nodejs单线程是针对图中的Event Loop，事件循环运行在主线程中。换言之nodejs接收任务请求是单线程的。 nodejs在具体执行IO任务的时候是多线程方式，在Async I/O队列中执行。 错误处理12345678910111213141516171819var http = require(&quot;http&quot;)http.createServer(() =&gt; &#123; throw new Error(&quot;错误不会被捕获&quot;)&#125;).listen(3000)输出如下：node src\\err.js d:\\Workspaces\\nodejs-demo\\src\\err.js:4 throw new Error(&quot;错误不会被捕获&quot;) ^Error: 错误不会被捕获 at Server.http.createServer (d:\\Workspaces\\nodejs-demo\\src\\err.js:4:11) at emitTwo (events.js:126:13) at Server.emit (events.js:214:7) at parserOnIncoming (_http_server.js:602:12) at HTTPParser.parserOnHeadersComplete (_http_common.js:116:23) nodejs在发生未被捕获的进程后，进程的状态就不确定了，无法正常工作。下一步添加uncaughtException函数1234567891011var http = require(&quot;http&quot;)http.createServer(() =&gt; &#123; throw new Error(&quot;错误不会被捕获&quot;)&#125;).listen(3000)process.on(&apos;uncaughtException&apos;, (err) =&gt; &#123; console.log(err) process.exit(1)&#125;) 绝大多数异步API回调函数的第一个参数都是err对象或者null。 Node中的js下面主要介绍一些nodejs的核心类库。 global任何global上的属性都可以被全局访问到。 process所有全局执行的上下文都在process中。 nodejs模块模块系统有三个全局的变量，require、module、exports。 绝对模块和相对模块绝对模块指node在node_modules内部查找的模块，或者node内置的比如fs这样的模块。相对模块是require指向工作目录中的js文件。相对模块引用示例require &#39;./moduleA&#39;。 暴露API要让模块暴露一个API成为require调用的返回值，需要依靠module和require的返回值。moduleA.js:123456exports.name = &apos;John&apos;exports.data = &apos;This is module demo&apos;let privateData = 5exports.getPriData = () =&gt; &#123; return privateData&#125; moduleDemo.js代码如下：1234var moduleA = require(&apos;./module_a&apos;)console.log(moduleA.data)console.log(moduleA.name)console.log(moduleA.getPriData()) Nodejs重要API本部分通过定义一个需求来实现： 程序启动后，需要显示当前目录下的文件列表。 选择某个文件后，程序需要显示文件内容。 选择一个目录时，程序需要显示当前目录下的内容。 运行结束后程序退出。程序设计： 创建模块 决定使用同步fs还是异步fs 理解什么是流 实现输入输出 重构 使用fs进行文件交互 完成创建模块创建名为 file-explorer的项目目录，创建一个简单的package.json文件。12345&#123; &quot;name&quot;: &quot;file-explorer&quot;, &quot;version&quot;: &quot;0.01&quot;, &quot;description&quot;: &quot;a command file-explorer&quot;&#125; 同步还是异步需要首先引入fs，fs模块是nodejs中唯一既提供同步又提供异步方法的API，为了体现nodejs异步的特性，决定使用异步方式。1234var fs = require(&apos;fs&apos;)fs.readdir(__dirname, (err, files) =&gt; &#123; console.log(files)&#125;) 示例代码V1版本如下：1234567891011121314151617181920212223242526272829var fs = require(&apos;fs&apos;)fs.readdir(__dirname, (err, files) =&gt; &#123; console.log(&apos;&apos;) if (!files.length) &#123; return console.log(&quot;no file!&quot;) &#125; console.log(&quot;select which dir or file you want to see\\n&quot;) let filefunc = (i) =&gt; &#123; let filename = files[i] //if (filename.startsWith(&quot;.&quot;)) return fs.stat(__dirname + &apos;/&apos; + filename, (err, stats) =&gt; &#123; if (stats.isDirectory()) &#123; console.log(`dir is ` + filename) &#125; else &#123; console.log(`file is ` + filename) &#125; &#125;); i++ if (i == files.length) &#123; console.log(&apos;&apos;) process.stdout.write(&apos;Enter your choice\\n&apos;) process.stdin.resume() &#125; else &#123; filefunc(i) &#125; &#125; filefunc(0)&#125;) TCP本章示例，基于TCP的聊天程序： 成功连接到server后会返回欢迎消息，server要求client输入用户名，并告知当前有多少用户方位 输入用户名，按下回车键人为链接成功 链接成功后，可以向其他用户输入消息V1版本如下:123456789101112131415161718var net = require(&apos;net&apos;)var server = net.createServer((c =&gt; &#123; console.log(`new client $&#123;c.localAddress&#125;`) c.on(&apos;end&apos;, () =&gt; &#123; console.log(&apos;client disconnected&apos;); &#125;); c.write(&apos;hello\\r\\n&apos;); c.pipe(c);&#125;))server.listen(3000, () =&gt; &#123; console.log(&apos;server bound&apos;);&#125;)server.on(&apos;error&apos;, (err) =&gt; &#123; throw err;&#125;) 聊天程序优化 增加当前已连接客户计数器 当有新客户输入昵称时，判断当前是否有重名用户，若无重名用户，则将新客户的信息通知到其余客户。 当有客户退出时，清除存储结构，并通知其他客户。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var net = require(&apos;net&apos;)var conCount = 0, users = &#123;&#125;var server = net.createServer((c =&gt; &#123; var nickname console.log(`new client $&#123;c.localAddress&#125;`) c.setDefaultEncoding(&apos;utf8&apos;) c.write(&apos;hello\\r\\n&apos;); c.write(`$&#123;++conCount&#125; guests\\r\\n please write your name\\r\\n`) c.pipe(c); c.on(&apos;close&apos;, () =&gt; &#123; console.log(&apos;client disconnected&apos;); conCount-- delete users[nickname] for (key in users) &#123; users[key].write(`$&#123;nickname&#125; left out game!\\r\\n当前用户数目$&#123;conCount&#125;\\r\\n`) &#125; &#125;) c.on(&apos;data&apos;, (data) =&gt; &#123; let buf = data.toString(&apos;utf8&apos;).replace(&apos;\\r\\n&apos;, &apos;&apos;) if (buf == &apos;&apos;) return if (!nickname) &#123; if (users[buf]) &#123; c.write(`$&#123;nickname&#125; is used,please input again \\r\\n`) &#125; else &#123; nickname = buf users[nickname] = c for (key in users) &#123; users[key].write(`$&#123;nickname&#125; has joined our game\\r\\n`) &#125; &#125; &#125; &#125;)&#125;))server.listen(3000, () =&gt; &#123; console.log(&apos;server bound&apos;);&#125;)server.on(&apos;error&apos;, (err) =&gt; &#123; throw err;&#125;) users 对象存储每一个用户的链接，在每一个链接内增加nickname属性。上述代码，所有的链接共享当前链接数和user对象，任何一个链接改了这两个变量，都会对其他的链接产生影响。 参考链接i5ting大神《了不起的nodejs》","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}],"keywords":[]},{"title":"docker学习笔记03-Dockerfile指令详解","slug":"2018-04-30-docker学习笔记03","date":"2018-04-30T02:25:10.069Z","updated":"2018-04-30T02:25:44.904Z","comments":true,"path":"2018/04/30/2018-04-30-docker学习笔记03/","link":"","permalink":"http://yoursite.com/2018/04/30/2018-04-30-docker学习笔记03/","excerpt":"","text":"docker学习笔记03-Dockerfile指令详解COPY复制文件命令格式如下： COPY &lt;源路径&gt;… &lt;目标路径&gt; COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如： 1COPY package.json /usr/src/app/ &lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：12COPY hom* /mydir/COPY hom?.txt /mydir/ &lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 CMD容器启动命令CMD 指令的格式和 RUN 相似，也是两种格式： shell 格式： CMD &lt;命令&gt; exec 格式： CMD [“可执行文件”, “参数1”, “参数2”…]之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。 CMD 指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如， ubuntu 镜像默认的CMD 是 /bin/bash ，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash 。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release 。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “ ，而不要使用单引号。 提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。一些初学者将 CMD 写为：1CMD service nginx start 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginxstart”] ，因此主进程实际上是 sh 。那么当 service nginx start 命令结束后， sh 也就结束了， sh 作为主进程退出了，自然就会令容器退出。 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：1CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] ENTRYPOINT 入口点ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。 ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。 当指定了 ENTRYPOINT 后， CMD 的含义就发生了改变，不再是直接的运行其命令，而是将CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：1&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 场景一：让镜像变成像命令一样使用假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：12345FROM ubuntu:16.04RUN apt-get update \\&amp;&amp; apt-get install -y curl \\&amp;&amp; rm -rf /var/lib/apt/lists/*CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ] 假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：12[docker@iz2ze1fd7d8ota0f9ysaazz myubuntu]$ docker run myip当前 IP：39.107.119.46 来自：广东省深圳市 阿里云 这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl ，那么如果我们希望显示 HTTP头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？123[docker@iz2ze1fd7d8ota0f9ysaazz myubuntu]$ docker run myip -idocker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \\&quot;-i\\&quot;: executable file not found in $PATH&quot;: unknown.[docker@iz2ze1fd7d8ota0f9ysaazz myubuntu]$ 我们可以看到可执行文件找不到的报错， executable file not found 。之前我们说过，跟在镜像名后面的是 command ，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的CMD ，而不是添加在原来的 curl -s http://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：1docker run myip curl -s http://ip.cn -i 这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用ENTRYPOINT 来实现这个镜像：12345FROM ubuntu:16.04RUN apt-get update \\&amp;&amp; apt-get install -y curl \\&amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ] 重新build然后再次运行docker run myip -t可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后， CMD 的内容将会作为参数传给ENTRYPOINT ，而这里 -i 就是新的 CMD ，因此会作为参数传给 curl ，从而达到了我们预期的效果。 场景二：应用运行前的准备工作启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的mysql 服务器运行之前解决。 此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。 这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 ）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：1234567FROM alpine:3.4...RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis...ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]EXPOSE 6379CMD [ &quot;redis-server&quot; ] ENV 设置环境变量格式有两种： ENV ENV = =…这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN ，还是运行时的应用，都可以直接使用这里定义的环境变量。 12ENV VERSION=1.0 DEBUG=on \\NAME=&quot;Happy Feet&quot; ARG 构建参数构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是， ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build 中用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。 VOLUME 定义匿名卷格式为： VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…] VOLUME &lt;路径&gt;之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 1VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：1docker run -d -v mydata:/data xxxx 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了Dockerfile 中定义的匿名卷的挂载配置。 EXPOSE 声明端口格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。要将 EXPOSE 和在运格式为 WORKDIR &lt;工作目录路径&gt;行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。 -p ，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR 指定工作目录格式为 WORKDIR &lt;工作目录路径&gt;使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在， WORKDIR 会帮你建立目录。 之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：12RUN cd /appRUN echo &quot;hello&quot; &gt; world.txt 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello 。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。 之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUNcd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。 USER 指定当前用户格式： USER &lt;用户名&gt;USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。 WORKDIR 是改变工作目录， USER 则是改变之后层的执行 RUN , CMD 以及 ENTRYPOINT 这类命令的身份。 当然，和 WORKDIR 一样， USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。 123RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [ &quot;redis-server&quot; ] 如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo ，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu 。123456789# 建立 redis 用户，并使用 gosu 换另一个用户执行命令RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis# 下载 gosuRUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \\&amp;&amp; chmod +x /usr/local/bin/gosu \\&amp;&amp; gosu nobody true# 设置 CMD，并以另外的用户执行CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ] HEALTHCHECK 健康检查格式： HEALTHCHECK [选项] CMD &lt;命令&gt; ：设置检查容器健康状况的命令 HEALTHCHECK NONE ：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12引入的新指令。 HEALTHCHECK 支持下列选项： –interval=&lt;间隔&gt; ：两次健康检查的间隔，默认为 30 秒； –timeout=&lt;时长&gt; ：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； –retries=&lt;次数&gt; ：当连续失败指定次数后，则将容器状态视为 unhealthy ，默认 3次。 和 CMD , ENTRYPOINT 一样， HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写：1234FROM nginxRUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s \\CMD curl -fs http://localhost/ || exit 1 这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit1 作为健康检查命令。使用 docker build 来构建这个镜像：1docker build -t myweb:v1 . 构建好了后，我们启动一个容器：1docker run -d --name web -p 82:80 myweb:v1 执行docker container ls:123[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6519b8beac6f myweb:v1 &quot;nginx -g &apos;daemon of…&quot; 23 seconds ago Up 22 seconds (healthy) 0.0.0.0:82-&gt;80/tcp web ONBUILD 为他人做嫁衣裳格式： ONBUILD &lt;其它指令&gt;ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN , COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile ：1234567FROM node:slimRUN mkdir /appWORKDIR /appCOPY ./package.json /appRUN [ &quot;npm&quot;, &quot;install&quot; ]COPY . /app/CMD [ &quot;npm&quot;, &quot;start&quot; ] 把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。 如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile ，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile ，而第二个项目的 Dockerfile 就会被自动修复。 那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为：1234567FROM node:slimRUN mkdir /appWORKDIR /appONBUILD COPY ./package.json /appONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]ONBUILD COPY . /app/CMD [ &quot;npm&quot;, &quot;start&quot; ] 这次我们回到原始的 Dockerfile ，但是这次将项目相关的指令加上 ONBUILD ，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：1FROM my-node 是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install ，生成应用镜像。 参考dockerFile最佳实践github yeasy/docker_practice","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"指数基金投资指南-银行螺丝钉","slug":"2018-04-29-指数基金投资指南","date":"2018-04-29T03:22:55.290Z","updated":"2018-05-27T00:41:06.724Z","comments":true,"path":"2018/04/29/2018-04-29-指数基金投资指南/","link":"","permalink":"http://yoursite.com/2018/04/29/2018-04-29-指数基金投资指南/","excerpt":"","text":"指数基金投资指南-银行螺丝钉利用一天时间翻了下螺丝钉写的《指数基金投资指南》，还是挺有收获的，下面重点写下这本书提到的指数估值方法。 指数估值-盈利收益率法该方法是格林厄姆提出的，在盈利收益率高的时候开始定投，在盈利收益率低的时候结束甚至止盈。盈利收益率多高算高？格林厄姆认为满足如下两个条件即为高。 盈利收益率要大于10 盈利收益率要大幅高于同期无风险利率 回到中国市场，当盈利收益率大于10坚持定投，盈利收益率小于6.4%时，结束定投（或者止盈分批卖出）。为何是6.4%，因为6.4%是中国债券基金的长期收益率，低于6.4%了不如投资债券了。 盈利收益率法使用条件 成分股流通性好 成分股盈利稳定盈利收益率法适用的指数 上证红利、中证红利、 上证50、基本面50、上证50AH优选、央视50 恒生指数、国企指数 指数估值-博格公式法影响指数基金收益的三大因素 初始投资时刻的股息率 投资期内的市盈率变化 投资期内的盈利增长率 指数基金未来的年复合收益率等于投资初期股息率+指数基金每年的市盈率变化率（可正可负）+指数基金每年的盈利变化率。注：平均到每年的变化率和收益率。 博格公式法如何实践三个因素中，可以确定的因素有两个：（1）股息率（2）当前市盈率所处历史波动中的位置。无法确定的只有一个：未来盈利的增速。根据已知因素，可以做到如下三点： 股息率高的时候买入 市盈率处于较低位置处买入 买入之后，耐心等待均值回归，等待市盈率从低到高。 博格公式法适用指数 沪深300、中证500、创业板 红利机会、消费行业、医药、养老产业指数 指数估值-博格公式变种针对周期行业，盈利E的变化很大已经失去了比较意义，此时我们引入PB对指数进行分析。指数基金未来的年复合收益率 = 指数基金每年市净率的变化率 + 指数基金每年净资产的变化率 博格公式变种适合指数 证券行业、金融行业、非银金融行业、地产行业 定期不定额定投作为一个老韭菜，自认为心理抗波动能力还可以，所以重点记录下定期不定额定投。简单地说，就是跌的多买的多，跌的少买的少。 每期定投资金 = 1000元 【n （当期盈利收益率） / （基准盈利收益率 10%）】。n相当于一个放大器，根据自身随意调节。举例子，比如当前盈利收益率是11.2% ， n=1，则本月投入资金为：1000 1（11.2/10）=1120元。 上面这个公司对博格公式法也适用，博格公式变种法用PB代替PE。 思维导图总结 点击查看大图](https://blog.gunxueqiu.site/images/fund.svg","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"docker学习笔记02-镜像","slug":"2018-04-28-docker学习笔记02","date":"2018-04-28T13:26:42.885Z","updated":"2018-04-29T02:15:42.527Z","comments":true,"path":"2018/04/28/2018-04-28-docker学习笔记02/","link":"","permalink":"http://yoursite.com/2018/04/28/2018-04-28-docker学习笔记02/","excerpt":"","text":"docker学习笔记02-镜像Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。 获取镜像从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 DockerHub。仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt; 。对于 DockerHub，如果不给出用户名，则默认为 library ，也就是官方镜像。123456789docker pull ubuntu:16.0416.04: Pulling from library/ubuntu297061f60c36: Pull complete e9ccef17b516: Pull complete dbc33716854d: Pull complete 8fe36b178d25: Pull complete 686596545a94: Pull complete Digest: sha256:15f721c027e007887ba6cb071a65628c81122cb2b406e341d07cf2c180f7d759Status: Downloaded newer image for ubuntu:16.04 从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的sha256的摘要，以确保下载一致性。 运行image有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的ubuntu:16.04为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。123456789101112131415161718docker run -it --rm \\ubuntu:16.04 \\bash[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker run -it --rm \\&gt; ubuntu:16.04 \\&gt; bashroot@aee0271f7ebc:/# cat /etc/os-releaseNAME=&quot;Ubuntu&quot;VERSION=&quot;16.04.4 LTS (Xenial Xerus)&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 16.04.4 LTS&quot;VERSION_ID=&quot;16.04&quot;HOME_URL=&quot;http://www.ubuntu.com/&quot;SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;VERSION_CODENAME=xenialUBUNTU_CODENAME=xenial docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。 -it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们这里打算进入bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 –rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。 ubuntu:16.04 ：这是指用 ubuntu:16.04 镜像为基础来启动容器。 bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 。 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release ，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。最后我们通过 exit 退出了这个容器。 列出镜像要想列出已经下载下来的镜像，可以使用 docker image ls 命令。1234[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 16.04 0b1edfbffd27 4 hours ago 113MBhello-world latest e38bc07ac18e 2 weeks ago 1.85kB 可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间123456[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker system dfTYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 2 1 113MB 113MB (99%)Containers 1 0 0B 0BLocal Volumes 0 0 0B 0BBuild Cache 0B 0B 中间层镜像为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 删除本地镜像如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：12345678910[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker image rm 0b1edfbffd27Untagged: ubuntu:16.04Untagged: ubuntu@sha256:15f721c027e007887ba6cb071a65628c81122cb2b406e341d07cf2c180f7d759Deleted: sha256:0b1edfbffd27c935a666e233a0042ed634205f6f754dbe20769a60369c614f85Deleted: sha256:a606d2db36205a11036adff8d9556e7180c26639eede2466a128d0de9b3e1b2dDeleted: sha256:fc07fc8491e0f830ebdd30de1c1b683cb2456051d17401351948ed34fe64d4afDeleted: sha256:9ddf57d8cd7fe42a9c547584549ede3dac5990b4c78ddec319ffae2cde20a496Deleted: sha256:349f8ed4d525976a9549088aa1979bc36a79f8209f89024c3cd127399914f46bDeleted: sha256:c8aa3ff3c3d351787cc5f84d960870fad16c9615aab7aa47ab343906fc8cfc24[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ 用 docker image ls 命令来配合删除所有仓库名为 redis 的镜像1docker image rm $(docker image ls -q redis) 使用docker file定制镜像镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。这个脚本就叫做Dockerfile。 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为 Dockerfile ：123$ mkdir mynginx$ cd mynginx$ touch Dockerfile 其内容为:12FROM nginxRUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令， FROM 和 RUN 。 FROM 指定基础镜像所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如nginx 、 redis 、 mongo 、 mysql 、 httpd 、 php 、 tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node 、 openjdk 、 python 、 ruby 、 golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如ubuntu 、 debian 、 centos 、 fedora 、 alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch 。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。使用 Dockerfile 定制镜像。 RUN 执行命令RUN 指令是用来执行命令行命令的。由于命令行的强大能力， RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式： RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 exec 格式： RUN [“可执行文件”, “参数1”, “参数2”] ，这更像是函数调用中的格式。既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：12345678FROM debian:jessieRUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install 上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。正确的写法应该是这样：12345678910111213FROM debian:jessieRUN buildDeps=&apos;gcc libc6-dev make&apos; \\&amp;&amp; apt-get update \\&amp;&amp; apt-get install -y $buildDeps \\&amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \\&amp;&amp; mkdir -p /usr/src/redis \\&amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\&amp;&amp; make -C /usr/src/redis \\&amp;&amp; make -C /usr/src/redis install \\&amp;&amp; rm -rf /var/lib/apt/lists/* \\&amp;&amp; rm redis.tar.gz \\&amp;&amp; rm -r /usr/src/redis \\&amp;&amp; apt-get purge -y --auto-remove $buildDeps 构建镜像进入之前创建的 Dockerfile所在目录 12345678910111213141516[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048kBStep 1/2 : FROM nginxlatest: Pulling from library/nginx2a72cbf407d6: Pull complete 04b2d3302d48: Pull complete e7f619103861: Pull complete Digest: sha256:18156dcd747677b03968621b2729d46021ce83a5bc15118e5bcced925fb4ebb9Status: Downloaded newer image for nginx:latest ---&gt; b175e7467d66Step 2/2 : RUN echo Hello, Docker! &gt; /usr/share/nginx/html/index.html ---&gt; Running in 332935fd6a32Removing intermediate container 332935fd6a32 ---&gt; c08e23705638Successfully built c08e23705638Successfully tagged nginx:v3 运行nginx:v3镜像 12345678910111213141516171819202122232425262728docker run --name web2 -d -p 81:80 nginx:v3[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker run --name web2 -d -p 81:80 nginx:v372a659ee4374df18579dbe2a662ddc1927cfce5b507fe79a158409934e851aad 在shell中运行 links 127.0.0.1:81``` #### 镜像构建上下文（Context） 如果注意，会看到 docker build 命令最后有一个 . 。 . 表示当前目录，而 Dockerfile就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？ 首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 DockerRemote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当构建的时候，用户会指定构建镜像上下文的路径， dockerbuild 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： COPY ./package.json /app/`这并不是要复制执行 docker build 命令所在的目录下的 package.json ，也不是复制Dockerfile 所在目录下的 package.json ，而是复制 上下文（context） 目录下的package.json 。 因此， COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore ，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 参考链接github yeasy/docker_practice","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"docker学习笔记01-docker介绍与安装","slug":"2018-04-28-docker学习笔记01","date":"2018-04-28T13:19:05.569Z","updated":"2018-04-28T13:20:43.716Z","comments":true,"path":"2018/04/28/2018-04-28-docker学习笔记01/","link":"","permalink":"http://yoursite.com/2018/04/28/2018-04-28-docker学习笔记01/","excerpt":"","text":"docker学习笔记01-docker介绍与安装docker与VM区别首先上两张图，第一张是传统vm，第二张是docker。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于 系统支持量 单机上千容器 一般几十个 基本概念镜像ImageDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器Container镜像（ Image ）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学Docker时常常会混淆容器和虚拟机。前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 仓库Repository镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，DockerRegistry就是这样的服务。一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 以 Ubuntu 镜像为例，ubuntu是仓库的名字，其内包含有不同的版本标签，如，14.04,16.04。我们可以通过ubuntu:14.04 ，或者 ubuntu:16.04来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu ，那将视为 ubuntu:latest 。仓库名经常以 两段式路径形式出现，比如jwilder/nginx-proxy ，前者往往意味着DockerRegistry多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。 centos安装docker engine卸载旧版本12345678910yum remove docker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-selinux \\docker-engine-selinux \\docker-engine 使用脚本自动安装12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。 启动 Docker CE12345678910111213141516171819202122$ sudo systemctl enable docker$ sudo systemctl start docker[root@iz2ze1fd7d8ota0f9ysaazz ~]# docker versionClient: Version: 18.04.0-ce API version: 1.37 Go version: go1.9.4 Git commit: 3d479c0 Built: Tue Apr 10 18:21:36 2018 OS/Arch: linux/amd64 Experimental: false Orchestrator: swarmServer: Engine: Version: 18.04.0-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.4 Git commit: 3d479c0 Built: Tue Apr 10 18:25:25 2018 OS/Arch: linux/amd64 Experimental: false 建立 docker 用户组默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用root用户。因此，更好地做法是将需要使用 docker 的用户加入 docker用户组。 建立 docker 组用户groupadd dockeruseradd docker -g docker 将docker用户加入 docker 组usermod -aG docker docker 测试 Docker 是否安装正确1234567891011121314151617181920212223242526272829docker run hello-world[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-world9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 添加内核参数默认配置下，如果在CentOS使用DockerCE看到下面的这些警告信息：12WARNING: bridge-nf-call-iptables is disabledWARNING: bridge-nf-call-ip6tables is disabled 请添加内核配置参数以启用这些功能。1234$ sudo tee -a /etc/sysctl.conf &lt;&lt;-EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF 然后重新加载 sysctl.conf 即可sysctl -p重新执行docker info命令， 没有warning信息即可。 镜像加速鉴于国内网络问题，后续拉取Docker镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。对于centos7，请在/etc/docker/daemon.json中写入如下内容（如果文件不存在请新建该文件）。12345&#123;&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; 修改完毕后重启docker服务12$ sudo systemctl daemon-reload$ sudo systemctl restart docker 检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info ，如果从结果中看到了如下内容，说明配置成功。12Registry Mirrors: https://registry.docker-cn.com/ 参考链接github yeasy/docker_practice","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"keywords":[]},{"title":"我的常用git命令","slug":"2018-04-26-我的常用git命令","date":"2018-04-26T00:47:19.130Z","updated":"2018-04-28T01:21:29.948Z","comments":true,"path":"2018/04/26/2018-04-26-我的常用git命令/","link":"","permalink":"http://yoursite.com/2018/04/26/2018-04-26-我的常用git命令/","excerpt":"","text":"常用git命令回退到某次提交git reset –hard xxxxxxx好吧，这个如此rude的操作，放在第一条有点不协调。 push/pull 远程git clone xxx.git (本地目录)git push [远程名] [本地分支]:[远程分支]git pull [远程名] [本地分支]:[远程分支]从remote拉取一个新分支git checkout -b [本地分支] [远程名]/[远程分支]checkout的本地分支和远程分支名可以不一样 git loggit log –oneline –graph –decorate使用上面命令打印出来的日志，比较美观直观。 git rebase 需要注意的第一点，如果是执行git rebase master，此处的master实际上是本地的master 。 所以在执行git rebase 。 master之前，最好保证本地的master是最新的。 rebase适用的黄金法则：最好是本地的feature，不需要同步到remote的，这样安全性是最高的，不会对他人的commit造成混乱。因为rebase实际上是将master分支的commit，压到最前面。 rebase fix conflictrebase提示有冲突，可以按以下顺序解决： 修改程序代码，解决冲突。 git add fix后的代码文件 git rebase –continue 如果仍然有冲突继续解决，即重复1-3步骤，直至结束。 rebase –skip –abortgit rebase –skip 高风险操作，是将本次提交的代码删除掉（慎用）。git rebase –abort 将代码回退到 执行rebase之前的操作 查看远端分支git branch -a 冷冻当前dev分支修复bug软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交 12345678910111213$ git stash //冷冻现在在dev分支上的工作状态 冻结吧！ $ git checkout master //这个bug发生在master主分支上,我们切回master分支$ git checkout -b issue-101 //创建代号101的修复bug分支修改你的bug$ git add readme.txt //提交到暂存区$ git commit -m &quot;fix bug 101&quot; //注意填写信息，以免日后查证$ git checkout master //切换回master分支$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 //合并分支，注意不使用fast forward模式$ git branch -d issue-101 //删除issue-101分支$ git checkout dev //bug 改完了，是时候回到dev继续写bug了$ git stash list //查看刚刚的冻结现场$ git stash pop //git stash pop，恢复的同时把stash内容也删了：//一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 github上定期从目标仓库更新个人仓库1234git remote add upstream https://github.com/目标仓库/docker_practice$ git fetch upstream$ git rebase upstream/master$ git push -f origin master 参考链接掘金—bibi94","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"ES6学习之路-03","slug":"2018-04-25-ES6学习之路03","date":"2018-04-25T00:58:53.457Z","updated":"2018-04-25T00:59:32.052Z","comments":true,"path":"2018/04/25/2018-04-25-ES6学习之路03/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-25-ES6学习之路03/","excerpt":"","text":"ES6学习之路-03数组JSON数组格式转换JSON的数组格式就是为了前端快速的把JSON转换成数组的一种格式。1234567891011let json = &#123; &apos;0&apos;: &apos;test1&apos;, &apos;1&apos;: &apos;test2&apos;, &apos;2&apos;: &apos;test3&apos;, length: 3&#125;let arr = Array.from(json)console.log(arr)output:[&quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot;] 这就是一个标准的JSON数组格式，跟普通的JSON对比是在最后多了一个length属性。只要是这种特殊的json格式都可以轻松使用ES6的语法转变成数组。在ES6中绝大部分的Array操作都存在于Array对象里。我们就用Array.from(xxx)来进行转换。我们把上边的JSON代码转换成数组，并打印在控制台。 Array.of()方法它负责把一堆文本或者变量转换成数组。在开发中我们经常拿到了一个类似数组的字符串，需要使用eval来进行转换，d但是eval的效率是很低的，它会拖慢我们的程序。这时候我们就可以使用Array.of方法。我们看下边的代码把一堆数字转换成数组并打印在控制台上：12345678let arr2 = Array.of(3, 4, 5, 6)console.log(arr2)let arr3 = Array.of(&quot;1test&quot;, &quot;2test&quot;, &quot;3test&quot;)console.log(arr3)[3, 4, 5, 6][&quot;1test&quot;, &quot;2test&quot;, &quot;3test&quot;] find( )实例方法这里的find方法是从数组中查找。在find方法中我们需要传入一个匿名函数，函数需要传入三个参数： value：表示当前查找的值。 index：表示当前查找的数组索引。 arr：表示当前数组。在函数中如果找到符合条件的数组元素就进行return，并停止查找。你可以拷贝下边的代码进行测试，就会知道find作用。1234let arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr4.find(function(value, index, arr) &#123; return value &gt; 6;&#125;)) fill( )实例方法fill()也是一个实例方法，它的作用是把数组进行填充，它接收三个参数，第一个参数是填充的变量，第二个是开始填充的位置，第三个是填充到的位置。12345678let arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr4.find(function(value, index, arr) &#123; return value &gt; 6;&#125;))arr4.fill(&quot;es6&quot;, 3, 5)[1, 2, 3, &quot;es6&quot;, &quot;es6&quot;, 6, 7, 8, 9] 数组的遍历for…of循环先来一个最简单的for of循环1234let arr5 = [1, 2, 3, 4, 5, 6, 7, 8, 9];for (let item of arr5) &#123; console.log(item)&#125; for…of数组索引1234let arr5 = [1, 2, 3, 4, 5, 6, 7, 8, 9]for (let index of arr5.keys()) &#123; console.log(index)&#125; for…of 值和索引同时访问用entries()这个实例方法，配合我们的for…of循环就可以同时输出内容和索引了。123for (let [index, value] of arr4.entries()) &#123; console.log(index + &apos;:&apos; + value)&#125; entries()实例方式生成的是Iterator形式的数组，那这种形式的好处就是可以让我们在需要时用next()手动跳转到下一个值。 箭头函数和扩展默认值1234function add(a, b = 1) &#123; return a + b;&#125;console.log(add(1)); 主动抛出错误ES6中我们直接用throw new Error( xxxx ),就可以抛出错误。123456789/**函数抛出异常 */function addExp(a, b = 1) &#123; if (a == 0) &#123; throw new Error(&apos;This is error&apos;) &#125; return a + b;&#125;console.log(addExp(0));console.log(addExp.length); 注意上面代码最后一行，可以打印出函数的参数（必传参数）个数。 箭头函数感觉有点像java的lambda表达式，语言果然像融合的方向发展。12let add1 = (a, b = 1) =&gt; a + bconsole.log(add1(3, 4)) {}的使用括号右侧如果是两句话，就需要使用{}。12345let add2 = (a, b = 1) =&gt; &#123; console.log(&quot;function&quot;) return a + b&#125;console.log(add2(6, 7)) 箭头函数中不可加new，也就是说箭头函数不能当构造函数进行使用。 对象的函数解构在前后端分离时，后端经常返回来JSON格式的数据，前端的美好愿望是直接把这个JSON格式数据当作参数，传递到函数内部进行处理。ES6就为我们提供了这样的解构赋值。123456let json = &#123; a: &apos;es6&apos;, b: &apos;study&apos;&#125;let foo = (&#123; a, b = &apos;study&apos; &#125;) =&gt; console.log(a, b)foo(json) in的用法in是用来判断对象或者数组中是否存在某个值的。我们先来看一下用in如何判断对象里是否有某个值。 对象判断12345let ajson = &#123; a: &apos;es6&apos;, b: &apos;study&apos;&#125;console.log(&apos;a&apos; in ajson); //true 数组判断先来看一下ES5判断的弊端，以前会使用length属性进行判断，为0表示没有数组元素。但是这并不准确，或者说真实开发中有弊端。1234/**in的用法 判断数组是否为空 */let arr11 = [, , , , , ];console.log(arr11.length); //5console.log(0 in arr11); //false 数组的遍历方法下面的代码包含了forEach，filter,some，map，这四个方法的参数本质上也是个函数，函数参数使用了匿名箭头函数。1234567891011/**数组循环 */let arrs = [&quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w5&quot;]arrs.forEach((value, index) =&gt; console.log(index + &quot;:&quot; + value))arrs.filter(x =&gt; console.log(x))arrs.some(x =&gt; console.log(x))let arrs1 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]arrs1.map(x =&gt; &#123; &apos;web&apos;; console.log(x)&#125;) 数组转换字符串 join()方法 12let arrs22 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]console.log(arrs22.join(&apos;|&apos;)); toString方法 123let arrs22 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]console.log(arrs22.join(&apos;|&apos;));console.log(arrs22.toString()); 参考链接技术胖老师es6学习blog","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路-02","slug":"2018-04-24-ES6学习之路02","date":"2018-04-25T00:58:08.074Z","updated":"2018-04-25T00:58:47.726Z","comments":true,"path":"2018/04/25/2018-04-24-ES6学习之路02/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-24-ES6学习之路02/","excerpt":"","text":"ES6学习之路-02ES6声明变量的方式var方式var在ES6里是用来升级全局变量的，我们可以先作一个最简单的实例，用var声明一个变量a,然后用console.log进行输出。如何理解它的作用是声明全局变量那？我们用匿名函数给他进行一个包裹，然后在匿名函数中调用这个a变量，看看能不能调用到。12345var a=2;&#123; var a=3;&#125;console.log(a); 上述代码打印出3，可见var 声明变量的范围是全局的。 let方式通过上面简单的例子，我们对var的全局声明有了一定了解。那跟var向对应的是let，它是局部变量声明。还是上面的例子，我们试着在区块里用let声明。1234let a = 2; &#123; let a = 3;&#125;console.log(a); babel转换成es5的文件内容为：1234var a = 2;&#123; var _a = 3;&#125;console.log(a); let的作用范围et声明只在区块内起作用，外部是不可以调用的。下面的代码执行时会报错。1234&#123; let a=3;&#125;console.log(a); let的作用是防止数据污染，在一个大型的项目中，使用let安全性会非常高。 const方式在程序开发中，有些变量是希望声明后在业务层就不再发生变化了，简单来说就是从声明开始，这个变量始终不变，就需要用const进行声明。123const a = &quot;JSPang&quot;;var a = &apos;技术胖&apos;;console.log(a); 上面的代码编译阶段就报错了，原因就是我们const声明的变量是不可以改变的。 变量的解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。解构赋值在实际开发中可以大量减少我们的代码量，并且让我们的程序结构更清晰。 数组的解构赋值简单的数组解构以前，为变量赋值，我们只能直接指定值。比如下面的代码：123let a = 0;let b = 1;let c = 2; 而现在我们可以用数组解构的方式来进行赋值。1let [a,b,c]=[1,2,3]; 上面的代码表示，可以从数组中提取值，按照位置的对象关系对变量赋值。 数组模式和赋值模式统一可以简单的理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。1let [a,[b,c],d]=[1,[2,3],4]; 解构的默认值解构赋值是允许你使用默认值的，先看一个最简单的默认是的例子。12let [foo = true] = [];console.log(foo); //控制台打印出true 上边的例子数组中只有一个值，可能你会多少有些疑惑，我们就来个多个值的数组，并给他一些默认值。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;]console.log(a+b); //控制台显示“技术胖JSPang” 现在我们对默认值有所了解，需要注意的是undefined和null的区别。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;,undefined];console.log(a+b); //控制台显示“技术胖JSPang” undefined相当于什么都没有，b是默认值。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;,null];console.log(a+b); //控制台显示“技术胖null” null相当于有值，但值为null。所以b并没有取默认值，而是解构成了null。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123let &#123; foo, bar &#125; = &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;console.log(foo)console.log(bar) 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 扩展运算符和rest运算符对象扩展运算符（…）当编写一个方法时，我们允许它传入的参数是不确定的。这时候可以使用对象扩展运算符来作参数，看一个简单的列子：12345678function jspang(...arg)&#123; console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]); &#125;jspang(1,2,3); 扩展运算符的用处 先用一个例子说明，我们声明两个数组arr1和arr2，然后我们把arr1赋值给arr2，然后我们改变arr2的值，你会发现arr1的值也改变了，因为我们这是对内存堆栈的引用，而不是真正的赋值。123456789 /**扩展运算符的用处-数组赋值 */let arr1 = [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;]let arr2 = arr1console.log(arr2)arr2.push(&quot;study&quot;)console.log(arr1)输出实例如下：[&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;][&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;, &quot;study&quot;] 利用扩展运算符可以解决数组深度构造的问题。12345678let arr3 = [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;]let arr4 = [...arr3]console.log(arr3)arr4.push(&quot;study&quot;)console.log(arr3)(3) [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;](3) [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;] 可见arr3并没有被改变，与arr4是各自独立占一块内存。 rest运算符 如果你已经很好的掌握了对象扩展运算符，那么理解rest运算符并不困难，它们有很多相似之处，甚至很多时候你不用特意去区分。它也用…（三个点）来表示，我们先来看一个例子。1234567 /**rest运算符 */function restOper(first, ...args) &#123; console.log(args.length)&#125;restOper(0, 1, 2, 3, 4, 5, 6, 7)打印出7 ，说明args中有7个元素。 for…of循环12345function restOperForOf(first, ...args) &#123; for (let val of args) console.log(val)&#125;restOperForOf(0, 1, 2, 3, 4, 5, 6, 7) for…of的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for…of循环。有的小伙伴会说了，反正最后要转换成ES5，没有什么差别，但是至少从代码量上我们少打了一些单词，这就是开发效率的提高。 字符串模板这节主要学习ES6对字符串新增的操作，最重要的就是字符串模版，字符串模版的出现让我们再也不用拼接变量了，而且支持在模板里有简单计算操作。 先看ES5下的字符串拼接实例123let username = &apos;jake1036&apos;let blog = &apos;欢迎大家来到&apos; + username + &apos;博客&apos;document.write(blog) ES5下必须用+username+这样的形式进行拼接，这样很麻烦而且很容易出错。ES6新增了字符串模版，可以很好的解决这个问题。字符串模版不再使用’xxx’这样的单引号，而是换成了xxx这种形式(可以看下面的代码)，也叫连接号。这时我们再引用jspang变量就需要用${username}这种形式了，我们对上边的代码进行改造。12345/**es6改造 */let username_es6 = &apos;jake1036&apos;let blog_es6 = `es6欢迎大家来到 $&#123;username&#125;博客`document.write(blog_es6) 还可以在字符串中增加html样式和代码12345 /**es6字符串添加html代码 */let username_es6_html = &apos;jake1036&apos;let blog_es6_html = `&lt;br/&gt;es6欢迎大家来到&lt;b&gt; $&#123;username&#125;&lt;/b&gt;博客`document.write(blog_es6_html) 对运算的支持 1234 /**对运算符的支持 */let a_es6 = 1let b_es6 = 2document.write(`&lt;br/&gt;a+b:$&#123;a_es6+b_es6&#125;`) 字符串函数 1234 /**字符串函数的应用 */let str_es6 = `测试es6字符串函数查找，支持汉字`console.log(str_es6.includes(&apos;es6&apos;))document.write(&apos;es6|&apos;.repeat(3)); //字符串重复 ES6数字操作二进制和八进制二进制和八进制数字的声明并不是ES6的特性，我们只是做一个常识性的回顾。 二进制声明二进制的英文单词是Binary,二进制的开始是0（零），然后第二个位置是b（注意这里大小写都可以实现），然后跟上二进制的值就可以了。12let binaryVal = 0B0110console.log(binaryVal) 控制台打印出6. 八进制声明八进制的英文单词是Octal，也是以0（零）开始的，然后第二个位置是O（欧），然后跟上八进制的值就可以了。12let b=0o666;console.log(b); 控制台打印出438。 数字判断和转换 数字验证Number.isFinite( xx )可以使用Number.isFinite( )来进行数字验证，只要是数字，不论是浮点型还是整形都会返回true，其他时候会返回false。 12345/**判断是否是数字 */let numberVal = 11 / 4console.log(Number.isFinite(numberVal)) //trueconsole.log(Number.isFinite(0.3434)) //trueconsole.log(Number.isFinite(&apos;test&apos;)) //false NaN验证NaN是特殊的非数字，可以使用Number.isNaN()来进行验证。下边的代码控制台返回了true。 1console.log(Number.isNaN(NaN)); 判断是否为整数Number.isInteger(xx) 1console.log(Number.isInteger(0.3434)) 参考jishupang老师博客","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路-01搭建环境","slug":"2018-04-23-ES6学习之路01","date":"2018-04-25T00:56:56.665Z","updated":"2018-04-25T00:58:01.993Z","comments":true,"path":"2018/04/25/2018-04-23-ES6学习之路01/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-23-ES6学习之路01/","excerpt":"","text":"ES6学习之路-01搭建环境继续跟着技术胖老师学习前端，接下来学习ES6，首先是搭建开发环境。本实例教程github地址：https://github.com/dumingcode/es6.git 搭建开发环境有些低版本的浏览器还是不支持ES6语法，需要我们把ES6的语法自动的转变成ES5的语法。webpack能实现此功能，Babel也可以，本文使用Babel将ES6编译成ES5。 建立工程目录es6，新建两个目录 src : 书写ES6代码的文件夹，写的js程序都放在这里 dist : 利用Babel编译成的ES5代码的文件夹，在HTML页面需要引入的时这里的js文件。 编写index.html页面（在工程根目录下）,html代码我就直接复制了，注意下面js的位置在dist中，我们的js文件写在src下，需要借助babel编译到dist目录下。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;script src=&quot;./dist/index.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello ECMA Script 6 &lt;/body&gt;&lt;/html&gt; 在src目录下编写index.js功能简单只作一个a变量的声明，并用console.log()打印出来。 12let a=1;console.log(a); let是ES6的一种声明方式，接下来我们需要把这个ES6的语法文件自动编程成ES5的语法文件。 初始化项目在安装Babel之前，需要用npm init先初始化我们的项目。npm init -y-y代表全部默认同意，就不用一次次按回车了。命令执行完成后，会在项目根目录下生产package.json文件。 123456789101112&#123; &quot;name&quot;: &quot;es6&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 全局安装Babel-clicnpm install -g babel-cli虽然已经安装了babel-cli，只是这样还不能成功进行转换，尝试输入命令babel src/index.js -o dist/index.js ， 显示结果如下 12let a = 1;console.log(a); 说明编译没有成功。 本地安装babel-preset-es2015 和 babel-clicnpm install --save-dev babel-preset-es2015 babel-cli 提示babel-preset-es2015过期，采用最新包继续安装cnpm install --save-dev babel-preset-env babel-cli。安装完成后打开package.json文件，发现新增配置如下： 12345&quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;&#125; 新建.babelrc在根目录下新建.babelrc文件，并打开录入下面的代码 123456&#123; &quot;presets&quot;:[ &quot;env&quot; ], &quot;plugins&quot;:[]&#125; 然后重新执行编译命令babel src/index.js -o dist/index.js。然后打开编译后的dist/index.js文件，源代码如下：1234&quot;use strict&quot;;var a = 1;console.log(a); 已经成功将ES6的语法编译成ES5。 编写转换script使用npm run build 直接利用webpack进行打包，在这里也希望利用这种方式完成转换。打开package.json文件，把文件修改成下面的样子。1234567891011121314151617&#123; &quot;name&quot;: &quot;es6&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;babel src/index.js -o dist/index.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot; &#125;&#125; 然后就可以使用npm run build打包了。 参考技术胖老师ES6","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"软技能-代码之外的生存指南读书心得","slug":"2018-04-22-软技能 代码之外的生存指南读书心得","date":"2018-04-22T08:44:19.053Z","updated":"2018-04-22T09:02:51.953Z","comments":true,"path":"2018/04/22/2018-04-22-软技能 代码之外的生存指南读书心得/","link":"","permalink":"http://yoursite.com/2018/04/22/2018-04-22-软技能 代码之外的生存指南读书心得/","excerpt":"","text":"软技能-代码之外的生存指南读后感花费半个月读完了John Z. Sonmez写的《软技能 代码之外的生存指南》一书。非常推荐广大程序员看一下此书，越早看受益越早。作者针对程序员职业生涯重点写到了如下几个方面： 如何学习技术 对待工作的态度，一周工作60小时以上是必要前提 程序员如何自我营销 节省时间提供工作效率的方法 建议程序员培养健身+理财的意识用思维导图把作者的主要观点表述如下 读后个人实践读完这本书，我具体实践了以下几个方面（已经在做，不是口号）： 建立了个人blog，养成每周至少发一篇高质量（尽量做到高质量）文章。 每周跑三次步（从14年就开始跑了） 理财意识（17年初开始关注股权投资） 每周工作60小时以上（公司工作） 日常工作使用番茄工作法，主要借助此方法评估每天的工作，每天10个番茄。 微信朋友圈消息提醒关闭。 每天7点前到公司，学习前端技术，vue、es6、nodejs，学习到9点。 作者推荐的书籍看一下，然后发表读书心得","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"hexo使用jenkins自动部署到阿里云","slug":"2018-04-21-hexo使用jenkins自动部署到阿里云","date":"2018-04-21T07:09:38.991Z","updated":"2018-04-21T07:35:34.530Z","comments":true,"path":"2018/04/21/2018-04-21-hexo使用jenkins自动部署到阿里云/","link":"","permalink":"http://yoursite.com/2018/04/21/2018-04-21-hexo使用jenkins自动部署到阿里云/","excerpt":"","text":"hexo使用jenkins自动部署到阿里云本地安装hexo12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 使用github pages服务部署hexo我们用来托管博客的服务叫做 Github Pages，它是 Github 用来提供给个人/组织或者项目的网页服务，只需要部署到你的 Github Repository，推送代码，便可以实时呈现。 首先，你需要有一个 Github 的账号。然后创建一个名称为 .github.io 的仓库来托管网页即可。 以我的 Github 为例，我的用户名是 dumingcode，所以创建一个名为 dumingcode.github.io 的仓库，创建的仓库地址便是：https://github.com/dumingcode/dumingcode.github.io.git 创建完后，我们可以暂时不用管它，不需要往仓库里面 push 任何的东西。 hexo部署配置接着，我们来配置一下本地的 Hexo。 在博客的根目录下有一个名为 _config.yml 的文件，这是博客的主配置文件。前面的其他部分我们先不理会，后文再谈，我们先看最后的 Deployment 配置项：1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 根据官方的文档显示，现在 Hexo 支持 Git、Heroku、Rsync、OpenShift、FTPSync 等部署方式，我们选择 Git 来部署的话，需要首先安装 hexo-deployer-git 插件：cnpm install hexo-deployer-git --save然后编辑上面的配置文件：12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 我们需要把刚才创建的仓库地址添加进来，branch 和 message 项可以不填，默认情况下推送到 master 分支，这里我建议使用 SSH 加密的仓库地址（参看 Github 官方文档配置 SSH 免密操作）。 保存配置文件之后，我们在博客的跟目录键入：hexo g -d便可以把博客部署到 Github 了。现在，所有人都可以通过 http://.github.io 来访问自己的博客。 hexo使用第三方模板找了半天发现hexo-theme-BlueLake主题很简洁，于是使用下面的命令安装（进入blog根目录执行）。 123git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLakecnpm install hexo-renderer-jade@0.3.0 --savecnpm install hexo-renderer-stylus --save 本人搭建好的github个人主页:https://dumingcode.github.io/，欢迎访问。 hexo部署到阿里云虽说利用github pages服务能够对外发布博客，但是作为一个码农还是希望有自己的域名博客，但是我比较懒，不想手动发布博客。我想自动化地既发布到github也能同时发布到个人网站。所以决定采用CICD的方法，CICD工具使用开源的jenkins，jenkins也搭建在阿里云个人服务器上。 下载并运行jenkins注意端口使用的是8081123mkdir /usr/local/jenkinswget http://mirrors.jenkins.io/war-stable/latest/jenkins.warnohup java -jar jenkins.war --ajp13Port=-1 --httpPort=8081 &amp; 安装nginx 安装nginx依赖 1234567891011yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-develwget http://nginx.org/download/nginx-1.13.10.tar.gztar xvf nginx-1.13.10.tar.gz./configure --prefix=/usr/local/nginxmakemake installcd /usr/local/nginx/sbin./nginx -s reloadnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or direc需要设置nginx.conf./nginx -c /usr/local/nginx/conf/nginx.conf nginx.conf配置 12345678910111213141516171819upstream jenkins &#123; server 127.0.0.1:8081; keepalive 64;&#125;server &#123; listen 80; server_name jenkins.buyasset.com; client_max_body_size 60M; client_body_buffer_size 512k; location / &#123; port_in_redirect on; proxy_pass http://jenkins/; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; &#125; 以上通过nginx 反向代理jenkins，在浏览器输入http://jenkins.buyasset.club就能够进入jenkins管理后台。 配置jenkins在jenkins页面提示目录中找到默认密码，输入jenkis域名，登陆jenkins。 安装jenkins社区推荐的插件 配置github获取sercret text登陆github网站，进入 github-&gt;Settings-&gt;Developer settings-&gt; Generate new token，点击生成完毕一定记录下下面的secret text。secret text一定要记住，忘记的话只能重新生成。 GitHub webhooks 设置进入GitHub上指定的项目（hexo 仓库） –&gt; setting –&gt; WebHooks&amp;Services –&gt; add webhook –&gt; 输入刚刚部署jenkins的服务器的IP图片中标红区域是变化的，后缀都是一样的为github-webhook。 jenkins中的github配置配置GitHub Plugin系统管理 –&gt; 系统设置 –&gt; GitHub –&gt; Add GitHub SeverAPI URL 输入 https://api.github.com，Credentials点击Add添加，Kind选择Secret Text,具体如下图所示。设置完成后，点击TestConnection,提示Credentials verified for user UUserName, rate limit: xxx,则表明有效。 创建一个freestyle任务 General 设置填写GitHub project URL, 也就是你的项目主页eg. https://github.com/your_name/your_repo_name 配置源码管理 构建触发器，构建环境 构建 构建脚本将上图的构建脚本替换如下： 1234cd /var/www/blog（hexo目录）git pullhexo cleanhexo g -d 构建后操作 构建前clone hexo将hexo初始代码拉取到/var/www/blog目录中，以后jenkins会监控github的push操作，一旦发现push会自动更新。cd /var/wwwgit clone https://github.com/dumingcode/dumingcode.github.io.git blog nginx反向代理hexohexo为静态网站，所以直接用nginx反向代理即可,nginx脚本如下：注意root指向的是hexo部署目录。12345678910111213141516171819202122232425server&#123; listen 80; server_name blog.buyasset.club; index index.html index.htm index.php default.html default.htm default.php; root /var/www/blog; #error_page 404 /404.html; location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$ &#123; access_log off; expires 1d; &#125; location ~ .*\\.(js|css|txt|xml)?$ &#123; access_log off; expires 12h; &#125; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 测试CICD效果进入本地hexo目录，修改发布的博客，然后执行hexo g -d，登陆jenkins发现jenkins已经获取到了push操作，并且执行了自动构建任务。以下为jenkins的变更记录1234Site updated: 2018-04-21 13:35:51 (commit: 76f3c53) (details)Commit 76f3c530d077782fd66a8ca375afaa17cd188286 by dumingSite updated: 2018-04-21 13:35:51 (commit: 76f3c53) 参考链接手把手教你搭建Jenkins+Github持续集成环境Jenkins+Github持续集成Jenkins最佳实践hexo自动部署基于 Hexo 的全自动博客构建部署系统","categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"}],"keywords":[]},{"title":"2018我的小目标","slug":"2018-04-15-我的小目标","date":"2018-04-15T08:43:27.901Z","updated":"2018-04-25T01:06:05.802Z","comments":true,"path":"2018/04/15/2018-04-15-我的小目标/","link":"","permalink":"http://yoursite.com/2018/04/15/2018-04-15-我的小目标/","excerpt":"","text":"技术方面学习知识 掌握vue框架，能使用vue实现功能。 学习使用ELK日志分析系统。 CICD-学习使用jenkins、Travis。 nginx open resty开发。 mongodb java8新特性比如lambda docker 阿里云部署实践docker java设计模式 nodejs学习并实践 按照前端开发栈学习es6 webpack等基础技术 实践知识学习-实践-教授-再学习，只学习效率会很低，学习技术必须学以致用，实践会加深理解。 大数整体仓位算下加权pb pe roe 股息率。 按申万一级，统计每个各行业符合大数的个股情况。 他山石现金流模型。 建立自己的专用域名blog，github和个人域名都写博客,坚持每周至少一篇blog。 每学习一种技术，写blog，然后录音频视频提供大家培训。 微信、app、都进行尝试 学会造轮子。","categories":[],"tags":[{"name":"规划","slug":"规划","permalink":"http://yoursite.com/tags/规划/"}],"keywords":[]},{"title":"2018北京长跑节半程马拉松","slug":"2018-04-15-北京长跑节半程马拉松","date":"2018-04-15T08:35:12.832Z","updated":"2018-04-15T08:38:56.882Z","comments":true,"path":"2018/04/15/2018-04-15-北京长跑节半程马拉松/","link":"","permalink":"http://yoursite.com/2018/04/15/2018-04-15-北京长跑节半程马拉松/","excerpt":"","text":"2018北京半程马拉松20180415忙里偷闲参加了北京长跑节半程马拉松，2:07跑完全程，创造个人最好成绩了。下面晒一些图，留下纪念。","categories":[],"tags":[{"name":"运动","slug":"运动","permalink":"http://yoursite.com/tags/运动/"}],"keywords":[]}]}