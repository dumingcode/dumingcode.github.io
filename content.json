{"meta":{"title":"学习之路","subtitle":"做只笨鸟","description":"记录技术学习以及读书心得","author":"DuMing","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-04-14T13:26:37.000Z","updated":"2018-04-14T13:26:37.678Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"我的常用git命令","slug":"2018-04-26-我的常用git命令","date":"2018-04-26T00:47:19.130Z","updated":"2018-04-26T00:49:03.892Z","comments":true,"path":"2018/04/26/2018-04-26-我的常用git命令/","link":"","permalink":"http://yoursite.com/2018/04/26/2018-04-26-我的常用git命令/","excerpt":"","text":"常用git命令回退到某次提交好吧，这个如此rude的操作，放在第一条有点不协调。 git reset –hard xxxxxxx push/pull 远程git clone xxx.git (本地目录)git push [远程名] [本地分支]:[远程分支] git pull [远程名] [本地分支]:[远程分支] git checkout -b [本地分支] [远程名]/[远程分支] checkout的本地分支和远程分支名可以不一样 git loggit log –oneline –graph –decorate使用上面命令打印出来的日志，比较美观直观。 git rebase 需要注意的第一点，如果是执行git rebase master，此处的master实际上是本地的master 。 所以在执行git rebase 。 master之前，最好保证本地的master是最新的。 rebase适用的黄金法则：最好是本地的feature，不需要同步到remote的，这样安全性是最高的，不会对他人的commit造成混乱。因为rebase实际上是将master分支的commit，压到最前面。rebase fix conflictrebase提示有冲突，可以按以下顺序解决： 修改程序代码，解决冲突。 git add fix后的代码文件 git rebase –continue 如果仍然有冲突继续解决，即重复1-3步骤，直至结束。 rebase –skip –abort git rebase –skip 高风险操作，是将本次提交的代码删除掉（慎用）。 git rebase –abort 将代码回退到 执行rebase之前的操作 查看远端分支 git branch -a 冷冻当前dev分支修复bug软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交 12345678910111213$ git stash //冷冻现在在dev分支上的工作状态 冻结吧！ $ git checkout master //这个bug发生在master主分支上,我们切回master分支$ git checkout -b issue-101 //创建代号101的修复bug分支修改你的bug$ git add readme.txt //提交到暂存区$ git commit -m &quot;fix bug 101&quot; //注意填写信息，以免日后查证$ git checkout master //切换回master分支$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 //合并分支，注意不使用fast forward模式$ git branch -d issue-101 //删除issue-101分支$ git checkout dev //bug 改完了，是时候回到dev继续写bug了$ git stash list //查看刚刚的冻结现场$ git stash pop //git stash pop，恢复的同时把stash内容也删了：//一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 参考链接掘金—bibi94","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"ES6学习之路-03","slug":"2018-04-25-ES6学习之路03","date":"2018-04-25T00:58:53.457Z","updated":"2018-04-25T00:59:32.052Z","comments":true,"path":"2018/04/25/2018-04-25-ES6学习之路03/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-25-ES6学习之路03/","excerpt":"","text":"ES6学习之路-03数组JSON数组格式转换JSON的数组格式就是为了前端快速的把JSON转换成数组的一种格式。1234567891011let json = &#123; &apos;0&apos;: &apos;test1&apos;, &apos;1&apos;: &apos;test2&apos;, &apos;2&apos;: &apos;test3&apos;, length: 3&#125;let arr = Array.from(json)console.log(arr)output:[&quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot;] 这就是一个标准的JSON数组格式，跟普通的JSON对比是在最后多了一个length属性。只要是这种特殊的json格式都可以轻松使用ES6的语法转变成数组。在ES6中绝大部分的Array操作都存在于Array对象里。我们就用Array.from(xxx)来进行转换。我们把上边的JSON代码转换成数组，并打印在控制台。 Array.of()方法它负责把一堆文本或者变量转换成数组。在开发中我们经常拿到了一个类似数组的字符串，需要使用eval来进行转换，d但是eval的效率是很低的，它会拖慢我们的程序。这时候我们就可以使用Array.of方法。我们看下边的代码把一堆数字转换成数组并打印在控制台上：12345678let arr2 = Array.of(3, 4, 5, 6)console.log(arr2)let arr3 = Array.of(&quot;1test&quot;, &quot;2test&quot;, &quot;3test&quot;)console.log(arr3)[3, 4, 5, 6][&quot;1test&quot;, &quot;2test&quot;, &quot;3test&quot;] find( )实例方法这里的find方法是从数组中查找。在find方法中我们需要传入一个匿名函数，函数需要传入三个参数： value：表示当前查找的值。 index：表示当前查找的数组索引。 arr：表示当前数组。在函数中如果找到符合条件的数组元素就进行return，并停止查找。你可以拷贝下边的代码进行测试，就会知道find作用。1234let arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr4.find(function(value, index, arr) &#123; return value &gt; 6;&#125;)) fill( )实例方法fill()也是一个实例方法，它的作用是把数组进行填充，它接收三个参数，第一个参数是填充的变量，第二个是开始填充的位置，第三个是填充到的位置。12345678let arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr4.find(function(value, index, arr) &#123; return value &gt; 6;&#125;))arr4.fill(&quot;es6&quot;, 3, 5)[1, 2, 3, &quot;es6&quot;, &quot;es6&quot;, 6, 7, 8, 9] 数组的遍历for…of循环先来一个最简单的for of循环1234let arr5 = [1, 2, 3, 4, 5, 6, 7, 8, 9];for (let item of arr5) &#123; console.log(item)&#125; for…of数组索引1234let arr5 = [1, 2, 3, 4, 5, 6, 7, 8, 9]for (let index of arr5.keys()) &#123; console.log(index)&#125; for…of 值和索引同时访问用entries()这个实例方法，配合我们的for…of循环就可以同时输出内容和索引了。123for (let [index, value] of arr4.entries()) &#123; console.log(index + &apos;:&apos; + value)&#125; entries()实例方式生成的是Iterator形式的数组，那这种形式的好处就是可以让我们在需要时用next()手动跳转到下一个值。 箭头函数和扩展默认值1234function add(a, b = 1) &#123; return a + b;&#125;console.log(add(1)); 主动抛出错误ES6中我们直接用throw new Error( xxxx ),就可以抛出错误。123456789/**函数抛出异常 */function addExp(a, b = 1) &#123; if (a == 0) &#123; throw new Error(&apos;This is error&apos;) &#125; return a + b;&#125;console.log(addExp(0));console.log(addExp.length); 注意上面代码最后一行，可以打印出函数的参数（必传参数）个数。 箭头函数感觉有点像java的lambda表达式，语言果然像融合的方向发展。12let add1 = (a, b = 1) =&gt; a + bconsole.log(add1(3, 4)) {}的使用括号右侧如果是两句话，就需要使用{}。12345let add2 = (a, b = 1) =&gt; &#123; console.log(&quot;function&quot;) return a + b&#125;console.log(add2(6, 7)) 箭头函数中不可加new，也就是说箭头函数不能当构造函数进行使用。 对象的函数解构在前后端分离时，后端经常返回来JSON格式的数据，前端的美好愿望是直接把这个JSON格式数据当作参数，传递到函数内部进行处理。ES6就为我们提供了这样的解构赋值。123456let json = &#123; a: &apos;es6&apos;, b: &apos;study&apos;&#125;let foo = (&#123; a, b = &apos;study&apos; &#125;) =&gt; console.log(a, b)foo(json) in的用法in是用来判断对象或者数组中是否存在某个值的。我们先来看一下用in如何判断对象里是否有某个值。 对象判断12345let ajson = &#123; a: &apos;es6&apos;, b: &apos;study&apos;&#125;console.log(&apos;a&apos; in ajson); //true 数组判断先来看一下ES5判断的弊端，以前会使用length属性进行判断，为0表示没有数组元素。但是这并不准确，或者说真实开发中有弊端。1234/**in的用法 判断数组是否为空 */let arr11 = [, , , , , ];console.log(arr11.length); //5console.log(0 in arr11); //false 数组的遍历方法下面的代码包含了forEach，filter,some，map，这四个方法的参数本质上也是个函数，函数参数使用了匿名箭头函数。1234567891011/**数组循环 */let arrs = [&quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w5&quot;]arrs.forEach((value, index) =&gt; console.log(index + &quot;:&quot; + value))arrs.filter(x =&gt; console.log(x))arrs.some(x =&gt; console.log(x))let arrs1 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]arrs1.map(x =&gt; &#123; &apos;web&apos;; console.log(x)&#125;) 数组转换字符串 join()方法 12let arrs22 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]console.log(arrs22.join(&apos;|&apos;)); toString方法 123let arrs22 = [&quot;w11&quot;, &quot;w21&quot;, &quot;w31&quot;, &quot;w41&quot;, &quot;w51&quot;]console.log(arrs22.join(&apos;|&apos;));console.log(arrs22.toString()); 参考链接技术胖老师es6学习blog","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路-02","slug":"2018-04-24-ES6学习之路02","date":"2018-04-25T00:58:08.074Z","updated":"2018-04-25T00:58:47.726Z","comments":true,"path":"2018/04/25/2018-04-24-ES6学习之路02/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-24-ES6学习之路02/","excerpt":"","text":"ES6学习之路-02ES6声明变量的方式var方式var在ES6里是用来升级全局变量的，我们可以先作一个最简单的实例，用var声明一个变量a,然后用console.log进行输出。如何理解它的作用是声明全局变量那？我们用匿名函数给他进行一个包裹，然后在匿名函数中调用这个a变量，看看能不能调用到。12345var a=2;&#123; var a=3;&#125;console.log(a); 上述代码打印出3，可见var 声明变量的范围是全局的。 let方式通过上面简单的例子，我们对var的全局声明有了一定了解。那跟var向对应的是let，它是局部变量声明。还是上面的例子，我们试着在区块里用let声明。1234let a = 2; &#123; let a = 3;&#125;console.log(a); babel转换成es5的文件内容为：1234var a = 2;&#123; var _a = 3;&#125;console.log(a); let的作用范围et声明只在区块内起作用，外部是不可以调用的。下面的代码执行时会报错。1234&#123; let a=3;&#125;console.log(a); let的作用是防止数据污染，在一个大型的项目中，使用let安全性会非常高。 const方式在程序开发中，有些变量是希望声明后在业务层就不再发生变化了，简单来说就是从声明开始，这个变量始终不变，就需要用const进行声明。123const a = &quot;JSPang&quot;;var a = &apos;技术胖&apos;;console.log(a); 上面的代码编译阶段就报错了，原因就是我们const声明的变量是不可以改变的。 变量的解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。解构赋值在实际开发中可以大量减少我们的代码量，并且让我们的程序结构更清晰。 数组的解构赋值简单的数组解构以前，为变量赋值，我们只能直接指定值。比如下面的代码：123let a = 0;let b = 1;let c = 2; 而现在我们可以用数组解构的方式来进行赋值。1let [a,b,c]=[1,2,3]; 上面的代码表示，可以从数组中提取值，按照位置的对象关系对变量赋值。 数组模式和赋值模式统一可以简单的理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。1let [a,[b,c],d]=[1,[2,3],4]; 解构的默认值解构赋值是允许你使用默认值的，先看一个最简单的默认是的例子。12let [foo = true] = [];console.log(foo); //控制台打印出true 上边的例子数组中只有一个值，可能你会多少有些疑惑，我们就来个多个值的数组，并给他一些默认值。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;]console.log(a+b); //控制台显示“技术胖JSPang” 现在我们对默认值有所了解，需要注意的是undefined和null的区别。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;,undefined];console.log(a+b); //控制台显示“技术胖JSPang” undefined相当于什么都没有，b是默认值。12let [a,b=&quot;JSPang&quot;]=[&apos;技术胖&apos;,null];console.log(a+b); //控制台显示“技术胖null” null相当于有值，但值为null。所以b并没有取默认值，而是解构成了null。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123let &#123; foo, bar &#125; = &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;console.log(foo)console.log(bar) 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 扩展运算符和rest运算符对象扩展运算符（…）当编写一个方法时，我们允许它传入的参数是不确定的。这时候可以使用对象扩展运算符来作参数，看一个简单的列子：12345678function jspang(...arg)&#123; console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]); &#125;jspang(1,2,3); 扩展运算符的用处 先用一个例子说明，我们声明两个数组arr1和arr2，然后我们把arr1赋值给arr2，然后我们改变arr2的值，你会发现arr1的值也改变了，因为我们这是对内存堆栈的引用，而不是真正的赋值。123456789 /**扩展运算符的用处-数组赋值 */let arr1 = [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;]let arr2 = arr1console.log(arr2)arr2.push(&quot;study&quot;)console.log(arr1)输出实例如下：[&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;][&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;, &quot;study&quot;] 利用扩展运算符可以解决数组深度构造的问题。12345678let arr3 = [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;]let arr4 = [...arr3]console.log(arr3)arr4.push(&quot;study&quot;)console.log(arr3)(3) [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;](3) [&quot;du&quot;, &quot;ming&quot;, &quot;es6&quot;] 可见arr3并没有被改变，与arr4是各自独立占一块内存。 rest运算符 如果你已经很好的掌握了对象扩展运算符，那么理解rest运算符并不困难，它们有很多相似之处，甚至很多时候你不用特意去区分。它也用…（三个点）来表示，我们先来看一个例子。1234567 /**rest运算符 */function restOper(first, ...args) &#123; console.log(args.length)&#125;restOper(0, 1, 2, 3, 4, 5, 6, 7)打印出7 ，说明args中有7个元素。 for…of循环12345function restOperForOf(first, ...args) &#123; for (let val of args) console.log(val)&#125;restOperForOf(0, 1, 2, 3, 4, 5, 6, 7) for…of的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for…of循环。有的小伙伴会说了，反正最后要转换成ES5，没有什么差别，但是至少从代码量上我们少打了一些单词，这就是开发效率的提高。 字符串模板这节主要学习ES6对字符串新增的操作，最重要的就是字符串模版，字符串模版的出现让我们再也不用拼接变量了，而且支持在模板里有简单计算操作。 先看ES5下的字符串拼接实例123let username = &apos;jake1036&apos;let blog = &apos;欢迎大家来到&apos; + username + &apos;博客&apos;document.write(blog) ES5下必须用+username+这样的形式进行拼接，这样很麻烦而且很容易出错。ES6新增了字符串模版，可以很好的解决这个问题。字符串模版不再使用’xxx’这样的单引号，而是换成了xxx这种形式(可以看下面的代码)，也叫连接号。这时我们再引用jspang变量就需要用${username}这种形式了，我们对上边的代码进行改造。12345/**es6改造 */let username_es6 = &apos;jake1036&apos;let blog_es6 = `es6欢迎大家来到 $&#123;username&#125;博客`document.write(blog_es6) 还可以在字符串中增加html样式和代码12345 /**es6字符串添加html代码 */let username_es6_html = &apos;jake1036&apos;let blog_es6_html = `&lt;br/&gt;es6欢迎大家来到&lt;b&gt; $&#123;username&#125;&lt;/b&gt;博客`document.write(blog_es6_html) 对运算的支持 1234 /**对运算符的支持 */let a_es6 = 1let b_es6 = 2document.write(`&lt;br/&gt;a+b:$&#123;a_es6+b_es6&#125;`) 字符串函数 1234 /**字符串函数的应用 */let str_es6 = `测试es6字符串函数查找，支持汉字`console.log(str_es6.includes(&apos;es6&apos;))document.write(&apos;es6|&apos;.repeat(3)); //字符串重复 ES6数字操作二进制和八进制二进制和八进制数字的声明并不是ES6的特性，我们只是做一个常识性的回顾。 二进制声明二进制的英文单词是Binary,二进制的开始是0（零），然后第二个位置是b（注意这里大小写都可以实现），然后跟上二进制的值就可以了。12let binaryVal = 0B0110console.log(binaryVal) 控制台打印出6. 八进制声明八进制的英文单词是Octal，也是以0（零）开始的，然后第二个位置是O（欧），然后跟上八进制的值就可以了。12let b=0o666;console.log(b); 控制台打印出438。 数字判断和转换 数字验证Number.isFinite( xx )可以使用Number.isFinite( )来进行数字验证，只要是数字，不论是浮点型还是整形都会返回true，其他时候会返回false。 12345/**判断是否是数字 */let numberVal = 11 / 4console.log(Number.isFinite(numberVal)) //trueconsole.log(Number.isFinite(0.3434)) //trueconsole.log(Number.isFinite(&apos;test&apos;)) //false NaN验证NaN是特殊的非数字，可以使用Number.isNaN()来进行验证。下边的代码控制台返回了true。 1console.log(Number.isNaN(NaN)); 判断是否为整数Number.isInteger(xx) 1console.log(Number.isInteger(0.3434)) 参考jishupang老师博客","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"ES6学习之路-01搭建环境","slug":"2018-04-23-ES6学习之路01","date":"2018-04-25T00:56:56.665Z","updated":"2018-04-25T00:58:01.993Z","comments":true,"path":"2018/04/25/2018-04-23-ES6学习之路01/","link":"","permalink":"http://yoursite.com/2018/04/25/2018-04-23-ES6学习之路01/","excerpt":"","text":"ES6学习之路-01搭建环境继续跟着技术胖老师学习前端，接下来学习ES6，首先是搭建开发环境。本实例教程github地址：https://github.com/dumingcode/es6.git 搭建开发环境有些低版本的浏览器还是不支持ES6语法，需要我们把ES6的语法自动的转变成ES5的语法。webpack能实现此功能，Babel也可以，本文使用Babel将ES6编译成ES5。 建立工程目录es6，新建两个目录 src : 书写ES6代码的文件夹，写的js程序都放在这里 dist : 利用Babel编译成的ES5代码的文件夹，在HTML页面需要引入的时这里的js文件。 编写index.html页面（在工程根目录下）,html代码我就直接复制了，注意下面js的位置在dist中，我们的js文件写在src下，需要借助babel编译到dist目录下。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;script src=&quot;./dist/index.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Hello ECMA Script 6 &lt;/body&gt;&lt;/html&gt; 在src目录下编写index.js功能简单只作一个a变量的声明，并用console.log()打印出来。 12let a=1;console.log(a); let是ES6的一种声明方式，接下来我们需要把这个ES6的语法文件自动编程成ES5的语法文件。 初始化项目在安装Babel之前，需要用npm init先初始化我们的项目。npm init -y-y代表全部默认同意，就不用一次次按回车了。命令执行完成后，会在项目根目录下生产package.json文件。 123456789101112&#123; &quot;name&quot;: &quot;es6&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 全局安装Babel-clicnpm install -g babel-cli虽然已经安装了babel-cli，只是这样还不能成功进行转换，尝试输入命令babel src/index.js -o dist/index.js ， 显示结果如下 12let a = 1;console.log(a); 说明编译没有成功。 本地安装babel-preset-es2015 和 babel-clicnpm install --save-dev babel-preset-es2015 babel-cli 提示babel-preset-es2015过期，采用最新包继续安装cnpm install --save-dev babel-preset-env babel-cli。安装完成后打开package.json文件，发现新增配置如下： 12345&quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;&#125; 新建.babelrc在根目录下新建.babelrc文件，并打开录入下面的代码 123456&#123; &quot;presets&quot;:[ &quot;env&quot; ], &quot;plugins&quot;:[]&#125; 然后重新执行编译命令babel src/index.js -o dist/index.js。然后打开编译后的dist/index.js文件，源代码如下：1234&quot;use strict&quot;;var a = 1;console.log(a); 已经成功将ES6的语法编译成ES5。 编写转换script使用npm run build 直接利用webpack进行打包，在这里也希望利用这种方式完成转换。打开package.json文件，把文件修改成下面的样子。1234567891011121314151617&#123; &quot;name&quot;: &quot;es6&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;babel src/index.js -o dist/index.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot; &#125;&#125; 然后就可以使用npm run build打包了。 参考技术胖老师ES6","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[]},{"title":"软技能-代码之外的生存指南读书心得","slug":"2018-04-22-软技能 代码之外的生存指南读书心得","date":"2018-04-22T08:44:19.053Z","updated":"2018-04-22T09:02:51.953Z","comments":true,"path":"2018/04/22/2018-04-22-软技能 代码之外的生存指南读书心得/","link":"","permalink":"http://yoursite.com/2018/04/22/2018-04-22-软技能 代码之外的生存指南读书心得/","excerpt":"","text":"软技能-代码之外的生存指南读后感花费半个月读完了John Z. Sonmez写的《软技能 代码之外的生存指南》一书。非常推荐广大程序员看一下此书，越早看受益越早。作者针对程序员职业生涯重点写到了如下几个方面： 如何学习技术 对待工作的态度，一周工作60小时以上是必要前提 程序员如何自我营销 节省时间提供工作效率的方法 建议程序员培养健身+理财的意识用思维导图把作者的主要观点表述如下 读后个人实践读完这本书，我具体实践了以下几个方面（已经在做，不是口号）： 建立了个人blog，养成每周至少发一篇高质量（尽量做到高质量）文章。 每周跑三次步（从14年就开始跑了） 理财意识（17年初开始关注股权投资） 每周工作60小时以上（公司工作） 日常工作使用番茄工作法，主要借助此方法评估每天的工作，每天10个番茄。 微信朋友圈消息提醒关闭。 每天7点前到公司，学习前端技术，vue、es6、nodejs，学习到9点。 作者推荐的书籍看一下，然后发表读书心得","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}],"keywords":[]},{"title":"hexo使用jenkins自动部署到阿里云","slug":"2018-04-21-hexo使用jenkins自动部署到阿里云","date":"2018-04-21T07:09:38.991Z","updated":"2018-04-21T07:35:34.530Z","comments":true,"path":"2018/04/21/2018-04-21-hexo使用jenkins自动部署到阿里云/","link":"","permalink":"http://yoursite.com/2018/04/21/2018-04-21-hexo使用jenkins自动部署到阿里云/","excerpt":"","text":"hexo使用jenkins自动部署到阿里云本地安装hexo12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 使用github pages服务部署hexo我们用来托管博客的服务叫做 Github Pages，它是 Github 用来提供给个人/组织或者项目的网页服务，只需要部署到你的 Github Repository，推送代码，便可以实时呈现。 首先，你需要有一个 Github 的账号。然后创建一个名称为 .github.io 的仓库来托管网页即可。 以我的 Github 为例，我的用户名是 dumingcode，所以创建一个名为 dumingcode.github.io 的仓库，创建的仓库地址便是：https://github.com/dumingcode/dumingcode.github.io.git 创建完后，我们可以暂时不用管它，不需要往仓库里面 push 任何的东西。 hexo部署配置接着，我们来配置一下本地的 Hexo。 在博客的根目录下有一个名为 _config.yml 的文件，这是博客的主配置文件。前面的其他部分我们先不理会，后文再谈，我们先看最后的 Deployment 配置项：1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 根据官方的文档显示，现在 Hexo 支持 Git、Heroku、Rsync、OpenShift、FTPSync 等部署方式，我们选择 Git 来部署的话，需要首先安装 hexo-deployer-git 插件：cnpm install hexo-deployer-git --save然后编辑上面的配置文件：12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 我们需要把刚才创建的仓库地址添加进来，branch 和 message 项可以不填，默认情况下推送到 master 分支，这里我建议使用 SSH 加密的仓库地址（参看 Github 官方文档配置 SSH 免密操作）。 保存配置文件之后，我们在博客的跟目录键入：hexo g -d便可以把博客部署到 Github 了。现在，所有人都可以通过 http://.github.io 来访问自己的博客。 hexo使用第三方模板找了半天发现hexo-theme-BlueLake主题很简洁，于是使用下面的命令安装（进入blog根目录执行）。 123git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLakecnpm install hexo-renderer-jade@0.3.0 --savecnpm install hexo-renderer-stylus --save 本人搭建好的github个人主页:https://dumingcode.github.io/，欢迎访问。 hexo部署到阿里云虽说利用github pages服务能够对外发布博客，但是作为一个码农还是希望有自己的域名博客，但是我比较懒，不想手动发布博客。我想自动化地既发布到github也能同时发布到个人网站。所以决定采用CICD的方法，CICD工具使用开源的jenkins，jenkins也搭建在阿里云个人服务器上。 下载并运行jenkins注意端口使用的是8081123mkdir /usr/local/jenkinswget http://mirrors.jenkins.io/war-stable/latest/jenkins.warnohup java -jar jenkins.war --ajp13Port=-1 --httpPort=8081 &amp; 安装nginx 安装nginx依赖 1234567891011yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-develwget http://nginx.org/download/nginx-1.13.10.tar.gztar xvf nginx-1.13.10.tar.gz./configure --prefix=/usr/local/nginxmakemake installcd /usr/local/nginx/sbin./nginx -s reloadnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or direc需要设置nginx.conf./nginx -c /usr/local/nginx/conf/nginx.conf nginx.conf配置 12345678910111213141516171819upstream jenkins &#123; server 127.0.0.1:8081; keepalive 64;&#125;server &#123; listen 80; server_name jenkins.buyasset.com; client_max_body_size 60M; client_body_buffer_size 512k; location / &#123; port_in_redirect on; proxy_pass http://jenkins/; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; &#125; 以上通过nginx 反向代理jenkins，在浏览器输入http://jenkins.buyasset.club就能够进入jenkins管理后台。 配置jenkins在jenkins页面提示目录中找到默认密码，输入jenkis域名，登陆jenkins。 安装jenkins社区推荐的插件 配置github获取sercret text登陆github网站，进入 github-&gt;Settings-&gt;Developer settings-&gt; Generate new token，点击生成完毕一定记录下下面的secret text。secret text一定要记住，忘记的话只能重新生成。 GitHub webhooks 设置进入GitHub上指定的项目（hexo 仓库） –&gt; setting –&gt; WebHooks&amp;Services –&gt; add webhook –&gt; 输入刚刚部署jenkins的服务器的IP图片中标红区域是变化的，后缀都是一样的为github-webhook。 jenkins中的github配置配置GitHub Plugin系统管理 –&gt; 系统设置 –&gt; GitHub –&gt; Add GitHub SeverAPI URL 输入 https://api.github.com，Credentials点击Add添加，Kind选择Secret Text,具体如下图所示。设置完成后，点击TestConnection,提示Credentials verified for user UUserName, rate limit: xxx,则表明有效。 创建一个freestyle任务 General 设置填写GitHub project URL, 也就是你的项目主页eg. https://github.com/your_name/your_repo_name 配置源码管理 构建触发器，构建环境 构建 构建脚本将上图的构建脚本替换如下： 1234cd /var/www/blog（hexo目录）git pullhexo cleanhexo g -d 构建后操作 构建前clone hexo将hexo初始代码拉取到/var/www/blog目录中，以后jenkins会监控github的push操作，一旦发现push会自动更新。cd /var/wwwgit clone https://github.com/dumingcode/dumingcode.github.io.git blog nginx反向代理hexohexo为静态网站，所以直接用nginx反向代理即可,nginx脚本如下：注意root指向的是hexo部署目录。12345678910111213141516171819202122232425server&#123; listen 80; server_name blog.buyasset.club; index index.html index.htm index.php default.html default.htm default.php; root /var/www/blog; #error_page 404 /404.html; location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$ &#123; access_log off; expires 1d; &#125; location ~ .*\\.(js|css|txt|xml)?$ &#123; access_log off; expires 12h; &#125; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 测试CICD效果进入本地hexo目录，修改发布的博客，然后执行hexo g -d，登陆jenkins发现jenkins已经获取到了push操作，并且执行了自动构建任务。以下为jenkins的变更记录1234Site updated: 2018-04-21 13:35:51 (commit: 76f3c53) (details)Commit 76f3c530d077782fd66a8ca375afaa17cd188286 by dumingSite updated: 2018-04-21 13:35:51 (commit: 76f3c53) 参考链接手把手教你搭建Jenkins+Github持续集成环境Jenkins+Github持续集成Jenkins最佳实践hexo自动部署基于 Hexo 的全自动博客构建部署系统","categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"}],"keywords":[]},{"title":"2018我的小目标","slug":"2018-04-15-我的小目标","date":"2018-04-15T08:43:27.901Z","updated":"2018-04-25T01:06:05.802Z","comments":true,"path":"2018/04/15/2018-04-15-我的小目标/","link":"","permalink":"http://yoursite.com/2018/04/15/2018-04-15-我的小目标/","excerpt":"","text":"技术方面学习知识 掌握vue框架，能使用vue实现功能。 学习使用ELK日志分析系统。 CICD-学习使用jenkins、Travis。 nginx open resty开发。 mongodb java8新特性比如lambda docker 阿里云部署实践docker java设计模式 nodejs学习并实践 按照前端开发栈学习es6 webpack等基础技术 实践知识学习-实践-教授-再学习，只学习效率会很低，学习技术必须学以致用，实践会加深理解。 大数整体仓位算下加权pb pe roe 股息率。 按申万一级，统计每个各行业符合大数的个股情况。 他山石现金流模型。 建立自己的专用域名blog，github和个人域名都写博客,坚持每周至少一篇blog。 每学习一种技术，写blog，然后录音频视频提供大家培训。 微信、app、都进行尝试 学会造轮子。","categories":[],"tags":[{"name":"规划","slug":"规划","permalink":"http://yoursite.com/tags/规划/"}],"keywords":[]},{"title":"2018北京长跑节半程马拉松","slug":"2018-04-15-北京长跑节半程马拉松","date":"2018-04-15T08:35:12.832Z","updated":"2018-04-15T08:38:56.882Z","comments":true,"path":"2018/04/15/2018-04-15-北京长跑节半程马拉松/","link":"","permalink":"http://yoursite.com/2018/04/15/2018-04-15-北京长跑节半程马拉松/","excerpt":"","text":"2018北京半程马拉松20180415忙里偷闲参加了北京长跑节半程马拉松，2:07跑完全程，创造个人最好成绩了。下面晒一些图，留下纪念。","categories":[],"tags":[{"name":"运动","slug":"运动","permalink":"http://yoursite.com/tags/运动/"}],"keywords":[]}]}