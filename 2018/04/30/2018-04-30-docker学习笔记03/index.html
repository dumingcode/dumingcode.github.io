<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录技术学习以及读书心得"><meta name="keywords" content="study"><title>docker学习笔记03-Dockerfile指令详解 | 学习之路</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">docker学习笔记03-Dockerfile指令详解</h1><a id="logo" href="/.">学习之路</a><p class="description">做只笨鸟</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">docker学习笔记03-Dockerfile指令详解</h1><div class="post-meta"><a href="/2018/04/30/2018-04-30-docker学习笔记03/#comments" class="comment-count"></a><p><span class="date">Apr 30, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="docker学习笔记03-Dockerfile指令详解"><a href="#docker学习笔记03-Dockerfile指令详解" class="headerlink" title="docker学习笔记03-Dockerfile指令详解"></a>docker学习笔记03-Dockerfile指令详解</h1><h2 id="COPY复制文件"><a href="#COPY复制文件" class="headerlink" title="COPY复制文件"></a>COPY复制文件</h2><p>命令格式如下： </p>
<ul>
<li>COPY &lt;源路径&gt;… &lt;目标路径&gt;</li>
<li>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]<br>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路<br>径&gt; 位置。比如：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规<br>则，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure></p>
<p>&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以<br>用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行<br>创建缺失目录。   </p>
<h2 id="CMD容器启动命令"><a href="#CMD容器启动命令" class="headerlink" title="CMD容器启动命令"></a>CMD容器启动命令</h2><p>CMD 指令的格式和 RUN 相似，也是两种格式：   </p>
<ul>
<li>shell 格式： CMD &lt;命令&gt;</li>
<li>exec 格式： CMD [“可执行文件”, “参数1”, “参数2”…]<br>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启<br>动容器的时候，需要指定所运行的程序及参数。 CMD 指令就是用于指定默认的容器主进程的<br>启动命令的。   </li>
</ul>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如， ubuntu 镜像默认的<br>CMD 是 /bin/bash ，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash 。我们<br>也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release 。这就是<br>用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。   </p>
<p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此<br>一定要使用双引号 “ ，而不要使用单引号。  </p>
<p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混<br>淆。<br>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，<br>用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。<br>一些初学者将 CMD 写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure></p>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执<br>行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在<br>以传统虚拟机的角度去理解容器。 </p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退<br>出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。  </p>
<p>而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服<br>务。而刚才说了 CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginx<br>start”] ，因此主进程实际上是 sh 。那么当 service nginx start 命令结束后， sh 也就结<br>束了， sh 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure></p>
<h2 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h2><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。  </p>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。 ENTRYPOINT 在运行时<br>也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指<br>定。  </p>
<p>当指定了 ENTRYPOINT 后， CMD 的含义就发生了改变，不再是直接的运行其命令，而是将<br>CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h3><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y curl \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只<br>需要执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz myubuntu]$ docker run myip</span><br><span class="line">当前 IP：39.107.119.46 来自：广东省深圳市 阿里云</span><br></pre></td></tr></table></figure></p>
<p>这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加<br>参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl ，那么如果我们希望显示 HTTP<br>头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz myubuntu]$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \&quot;-i\&quot;: executable file not found in $PATH&quot;: unknown.</span><br><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz myubuntu]$</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到可执行文件找不到的报错， executable file not found 。之前我们说过，跟在<br>镜像名后面的是 command ，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的<br>CMD ，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 -i 根本不是命令，所以自然<br>找不到。<br>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip curl -s http://ip.cn -i</span><br></pre></td></tr></table></figure></p>
<p>这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用<br>ENTRYPOINT 来实现这个镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y curl \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>重新build然后再次运行<code>docker run myip -t</code><br>可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后， CMD 的内容将会作为参数传给<br>ENTRYPOINT ，而这里 -i 就是新的 CMD ，因此会作为参数传给 curl ，从而达到了我们预<br>期的效果。  </p>
<h3 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h3><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的mysql 服务器运行之前解决。   </p>
<p>此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要<br>以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务<br>外，其它命令依旧可以使用 root 身份执行，方便调试等。   </p>
<p>这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工<br>作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到<br>的参数（也就是 <cmd> ）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做<br>的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure></cmd></p>
<h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><p>格式有两种：</p>
<ul>
<li>ENV <key> <value></value></key></li>
<li>ENV <key1>=<value1> <key2>=<value2>…<br>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN ，还是运行时的<br>应用，都可以直接使用这里定义的环境变量。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure>
</value2></key2></value1></key1></li>
</ul>
<h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><p>构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是， ARG 所设置的构建环境的<br>环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密<br>码之类的信息，因为 docker history 还是可以看到所有值的。<br>Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令<br>docker build 中用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。   </p>
<h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><p>格式为：</p>
<ul>
<li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]</li>
<li>VOLUME &lt;路径&gt;<br>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存<br>动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍<br>Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在<br>Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂<br>载，其应用也可以正常运行，不会向容器存储层写入大量数据。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记<br>录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设<br>置。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure></p>
<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了<br>Dockerfile 中定义的匿名卷的挂载配置。  </p>
<h2 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h2><p>格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]<br>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声<br>明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助<br>镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用<br>随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。<br>要将 EXPOSE 和在运格式为 WORKDIR &lt;工作目录路径&gt;行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。 -p ，是映射宿主端口和<br>容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明<br>容器打算使用什么端口而已，并不会自动在宿主进行端口映射。  </p>
<h2 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h2><p>格式为 WORKDIR &lt;工作目录路径&gt;<br>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改<br>为指定的目录，如该目录不存在， WORKDIR 会帮你建立目录。  </p>
<p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解<br>还可能会导致出现下面这样的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd /app</span><br><span class="line">RUN echo &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure></p>
<p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其<br>内容不是 hello 。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前<br>一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令<br>的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念<br>不了解所导致的错误。    </p>
<p>之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN<br>cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任<br>何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关<br>系，自然不可能继承前一层构建过程中的内存变化。   </p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。</p>
<h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><p>格式： USER &lt;用户名&gt;<br>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。 WORKDIR 是改变工作目<br>录， USER 则是改变之后层的执行 RUN , CMD 以及 ENTRYPOINT 这类命令的身份。   </p>
<p>当然，和 WORKDIR 一样， USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立<br>好的，否则无法切换。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">USER redis</span><br><span class="line">RUN [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure>
<p>如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来<br>运行某个服务进程，不要使用 su 或者 sudo ，这些都需要比较麻烦的配置，而且在 TTY 缺<br>失的环境下经常出错。建议使用 gosu 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"># 下载 gosu</span><br><span class="line">RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/</span><br><span class="line">gosu-amd64&quot; \</span><br><span class="line">&amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">&amp;&amp; gosu nobody true</span><br><span class="line"># 设置 CMD，并以另外的用户执行</span><br><span class="line">CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure></p>
<h2 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h2><p>格式：</p>
<ul>
<li>HEALTHCHECK [选项] CMD &lt;命令&gt; ：设置检查容器健康状况的命令</li>
<li>HEALTHCHECK NONE ：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br>HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12<br>引入的新指令。   </li>
</ul>
<p>HEALTHCHECK 支持下列选项：</p>
<ul>
<li>–interval=&lt;间隔&gt; ：两次健康检查的间隔，默认为 30 秒；</li>
<li>–timeout=&lt;时长&gt; ：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被<br>视为失败，默认 30 秒；</li>
<li>–retries=&lt;次数&gt; ：当连续失败指定次数后，则将容器状态视为 unhealthy ，默认 3<br>次。   </li>
</ul>
<p>和 CMD , ENTRYPOINT 一样， HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。<br>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否<br>在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s \</span><br><span class="line">CMD curl -fs http://localhost/ || exit 1</span><br></pre></td></tr></table></figure></p>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如<br>果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit<br>1 作为健康检查命令。<br>使用 docker build 来构建这个镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure></p>
<p>构建好了后，我们启动一个容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name web -p 82:80 myweb:v1</span><br></pre></td></tr></table></figure></p>
<p>执行docker container ls:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS                NAMES</span><br><span class="line">6519b8beac6f        myweb:v1            &quot;nginx -g &apos;daemon of…&quot;   23 seconds ago      Up 22 seconds (healthy)   0.0.0.0:82-&gt;80/tcp   web</span><br></pre></td></tr></table></figure></p>
<h2 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h2><p>格式： ONBUILD &lt;其它指令&gt;<br>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN , COPY 等，而这些指令，<br>在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候<br>才会被执行。<br>Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人<br>定制自己而准备的。<br>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所<br>有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行<br>npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，<br>一般来说会这样写 Dockerfile ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY ./package.json /app</span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</span><br><span class="line">COPY . /app/</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运<br>行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复<br>制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困<br>难，让我们继续看这样的场景维护的问题。   </p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、<br>或者需要安装额外的包，然后开发人员修复了这个 Dockerfile ，再次构建，问题解决。第一<br>个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目<br>的，但是并不会因为第一个项目修复了他们的 Dockerfile ，而第二个项目的 Dockerfile 就<br>会被自动修复。   </p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更<br>新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，<br>可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">ONBUILD COPY ./package.json /app</span><br><span class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]</span><br><span class="line">ONBUILD COPY . /app/</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>这次我们回到原始的 Dockerfile ，但是这次将项目相关的指令加上 ONBUILD ，这样在构建<br>基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure></p>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，<br>之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且<br>针对本项目执行 npm install ，生成应用镜像。   </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">dockerFile最佳实践</a><br><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">github yeasy/docker_practice</a></p>
</div><div class="tags"><a href="/tags/docker/">docker</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/05/01/2018-05-01-nodejs学习之路01/" class="pre">nodejs学习之路01-异步调用与net fs核心类库</a><a href="/2018/04/29/2018-04-29-指数基金投资指南/" class="next">指数基金投资指南-银行螺丝钉</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNTcyNC8xMjI2MA"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#docker学习笔记03-Dockerfile指令详解"><span class="toc-text">docker学习笔记03-Dockerfile指令详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#COPY复制文件"><span class="toc-text">COPY复制文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMD容器启动命令"><span class="toc-text">CMD容器启动命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ENTRYPOINT-入口点"><span class="toc-text">ENTRYPOINT 入口点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#场景一：让镜像变成像命令一样使用"><span class="toc-text">场景一：让镜像变成像命令一样使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景二：应用运行前的准备工作"><span class="toc-text">场景二：应用运行前的准备工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ENV-设置环境变量"><span class="toc-text">ENV 设置环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARG-构建参数"><span class="toc-text">ARG 构建参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VOLUME-定义匿名卷"><span class="toc-text">VOLUME 定义匿名卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXPOSE-声明端口"><span class="toc-text">EXPOSE 声明端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WORKDIR-指定工作目录"><span class="toc-text">WORKDIR 指定工作目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USER-指定当前用户"><span class="toc-text">USER 指定当前用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HEALTHCHECK-健康检查"><span class="toc-text">HEALTHCHECK 健康检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ONBUILD-为他人做嫁衣裳"><span class="toc-text">ONBUILD 为他人做嫁衣裳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/2018-08-09-微服务设计笔记05/">微服务设计笔记05</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/2018-08-08-微服务设计笔记04/">微服务设计笔记04</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/2018-08-04-promise学习04/">Promise学习04</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/2018-08-04-promise学习03/">Promise学习03</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/2018-08-04-promise学习02/">Promise学习02</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/2018-08-04-promise学习01/">Promise学习01</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/03/2018-08-03-微服务设计笔记03/">微服务设计笔记03</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/02/2018-08-02-微服务设计笔记02/">微服务设计笔记02</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/02/2018-08-01-微服务设计笔记01/">微服务设计笔记01</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/30/2018-07-30-微服务限流/">微服务限流</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/规划/" style="font-size: 15px;">规划</a> <a href="/tags/运动/" style="font-size: 15px;">运动</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/CICD/" style="font-size: 15px;">CICD</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/dumingcode" title="github" target="_blank">github</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">DuMing.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>