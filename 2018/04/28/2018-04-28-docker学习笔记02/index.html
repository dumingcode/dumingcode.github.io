<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录技术学习以及读书心得"><meta name="keywords" content="study"><title>docker学习笔记02-镜像 | 学习之路</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">docker学习笔记02-镜像</h1><a id="logo" href="/.">学习之路</a><p class="description">做只笨鸟</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">docker学习笔记02-镜像</h1><div class="post-meta"><a href="/2018/04/28/2018-04-28-docker学习笔记02/#comments" class="comment-count"></a><p><span class="date">Apr 28, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="docker学习笔记02-镜像"><a href="#docker学习笔记02-镜像" class="headerlink" title="docker学习笔记02-镜像"></a>docker学习笔记02-镜像</h2><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 docker pull 。其命令格式为：<br><code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code>   </p>
<p>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 Docker<br>Hub。<br>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt; 。对于 Docker<br>Hub，如果不给出用户名，则默认为 library ，也就是官方镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line">297061f60c36: Pull complete </span><br><span class="line">e9ccef17b516: Pull complete </span><br><span class="line">dbc33716854d: Pull complete </span><br><span class="line">8fe36b178d25: Pull complete </span><br><span class="line">686596545a94: Pull complete </span><br><span class="line">Digest: sha256:15f721c027e007887ba6cb071a65628c81122cb2b406e341d07cf2c180f7d759</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br></pre></td></tr></table></figure></p>
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的sha256的摘要，以确保下载一致性。</p>
<h3 id="运行image"><a href="#运行image" class="headerlink" title="运行image"></a>运行image</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的ubuntu:16.04为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm \</span><br><span class="line">ubuntu:16.04 \</span><br><span class="line">bash</span><br><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker run -it --rm \</span><br><span class="line">&gt; ubuntu:16.04 \</span><br><span class="line">&gt; bash</span><br><span class="line">root@aee0271f7ebc:/# cat /etc/os-release</span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;16.04.4 LTS (Xenial Xerus)&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 16.04.4 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;16.04&quot;</span><br><span class="line">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br></pre></td></tr></table></figure></p>
<p>docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简<br>要的说明一下上面用到的参数。  </p>
<ul>
<li>-it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们这里打算进入<br>bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li>–rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容<br>器并不会立即删除，除非手动 docker rm 。我们这里只是随便执行个命令，看看结果，<br>不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li>
<li>ubuntu:16.04 ：这是指用 ubuntu:16.04 镜像为基础来启动容器。</li>
<li>bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 。  </li>
</ul>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat
/etc/os-release</code> ，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。<br>最后我们通过 exit 退出了这个容器。</p>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               0b1edfbffd27        4 hours ago         113MB</span><br><span class="line">hello-world         latest              e38bc07ac18e        2 weeks ago         1.85kB</span><br></pre></td></tr></table></figure></p>
<p>可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              2                   1                   113MB               113MB (99%)</span><br><span class="line">Containers          1                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache                                                 0B                  0B</span><br></pre></td></tr></table></figure></p>
<h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可<br>能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果<br>希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p>
<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz ~]$ docker image rm 0b1edfbffd27</span><br><span class="line">Untagged: ubuntu:16.04</span><br><span class="line">Untagged: ubuntu@sha256:15f721c027e007887ba6cb071a65628c81122cb2b406e341d07cf2c180f7d759</span><br><span class="line">Deleted: sha256:0b1edfbffd27c935a666e233a0042ed634205f6f754dbe20769a60369c614f85</span><br><span class="line">Deleted: sha256:a606d2db36205a11036adff8d9556e7180c26639eede2466a128d0de9b3e1b2d</span><br><span class="line">Deleted: sha256:fc07fc8491e0f830ebdd30de1c1b683cb2456051d17401351948ed34fe64d4af</span><br><span class="line">Deleted: sha256:9ddf57d8cd7fe42a9c547584549ede3dac5990b4c78ddec319ffae2cde20a496</span><br><span class="line">Deleted: sha256:349f8ed4d525976a9549088aa1979bc36a79f8209f89024c3cd127399914f46b</span><br><span class="line">Deleted: sha256:c8aa3ff3c3d351787cc5f84d960870fad16c9615aab7aa47ab343906fc8cfc24</span><br><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz ~]$</span><br></pre></td></tr></table></figure></p>
<h4 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h4><p>删除所有仓库名为 redis 的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure></p>
<h3 id="使用docker-file定制镜像"><a href="#使用docker-file定制镜像" class="headerlink" title="使用docker file定制镜像"></a>使用docker file定制镜像</h3><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。这个脚本就叫做Dockerfile。   </p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。<br>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ cd mynginx</span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure></p>
<p>其内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p>
<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令， FROM 和 RUN 。</p>
<h4 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h4><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个<br>nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜<br>像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。   </p>
<p>在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如<br>nginx 、 redis 、 mongo 、 mysql 、 httpd 、 php 、 tomcat 等；也有一些方便开发、构<br>建、运行各种语言应用的镜像，如 node 、 openjdk 、 python 、 ruby 、 golang 等。可以<br>在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。   </p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如<br>ubuntu 、 debian 、 centos 、 fedora 、 alpine 等，这些操作系统的软件库为我们提供了<br>更广阔的扩展空间。   </p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch 。这个镜像<br>是虚拟的概念，并不实际存在，它表示一个空白的镜像。<br>使用 Dockerfile 定制镜像。</p>
<h4 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h4><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力， RUN 指令在定制镜像时是最<br>常用的指令之一。其格式有两种：   </p>
<ul>
<li>shell 格式： RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中<br>的 RUN 指令就是这种格式。</li>
<li>exec 格式： RUN [“可执行文件”, “参数1”, “参数2”] ，这更像是函数调用中的格式。<br>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个<br>命令对应一个 RUN 呢？比如这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东<br>西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常<br>多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。<br>正确的写法应该是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</span><br><span class="line">&amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">&amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">&amp;&amp; make -C /usr/src/redis \</span><br><span class="line">&amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">&amp;&amp; rm redis.tar.gz \</span><br><span class="line">&amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure></p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>进入之前创建的 Dockerfile所在目录</p>
<p><pre><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">2a72cbf407d6: Pull complete </span><br><span class="line">04b2d3302d48: Pull complete </span><br><span class="line">e7f619103861: Pull complete </span><br><span class="line">Digest: sha256:18156dcd747677b03968621b2729d46021ce83a5bc15118e5bcced925fb4ebb9</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line"> ---&gt; b175e7467d66</span><br><span class="line">Step 2/2 : RUN echo Hello, Docker! &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running in 332935fd6a32</span><br><span class="line">Removing intermediate container 332935fd6a32</span><br><span class="line"> ---&gt; c08e23705638</span><br><span class="line">Successfully built c08e23705638</span><br><span class="line">Successfully tagged nginx:v3</span><br></pre></td></tr></table></figure></pre></p>
<p><br>运行nginx:v3镜像  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run --name web2 -d -p 81:80 nginx:v3</span><br><span class="line"></span><br><span class="line">[docker@iz2ze1fd7d8ota0f9ysaazz mynginx]$ docker run --name web2 -d -p 81:80 nginx:v3</span><br><span class="line">72a659ee4374df18579dbe2a662ddc1927cfce5b507fe79a158409934e851aad    </span><br><span class="line"></span><br><span class="line">在shell中运行 links 127.0.0.1:81</span><br><span class="line">```   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">#### 镜像构建上下文（Context）    </span><br><span class="line"></span><br><span class="line">如果注意，会看到 docker build 命令最后有一个 . 。 . 表示当前目录，而 Dockerfile</span><br><span class="line">就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其</span><br><span class="line">实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什</span><br><span class="line">么是上下文呢？   </span><br><span class="line">首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服</span><br><span class="line">务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker</span><br><span class="line">Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交</span><br><span class="line">互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实</span><br><span class="line">际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，</span><br><span class="line">让我们操作远程服务器的 Docker 引擎变得轻而易举。   </span><br><span class="line"></span><br><span class="line">当构建的时候，用户会指定构建镜像上下文的路径， docker</span><br><span class="line">build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样</span><br><span class="line">Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。   </span><br><span class="line"></span><br><span class="line">如果在 Dockerfile 中这么写：</span><br></pre></td></tr></table></figure>
<p>COPY ./package.json /app/<br><code>`</code><br>这并不是要复制执行 docker build 命令所在的目录下的 package.json ，也不是复制<br>Dockerfile 所在目录下的 package.json ，而是复制 上下文（context） 目录下的<br>package.json 。      </p>
<p>因此， COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么<br>COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经<br>超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没<br>有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传<br>给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore ，该文件是用于<br>剔除不需要作为上下文传递给 Docker 引擎的。   </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">github yeasy/docker_practice</a></p>
</div><div class="tags"><a href="/tags/docker/">docker</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/04/29/2018-04-29-指数基金投资指南/" class="pre">指数基金投资指南-银行螺丝钉</a><a href="/2018/04/28/2018-04-28-docker学习笔记01/" class="next">docker学习笔记01-docker介绍与安装</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNTcyNC8xMjI2MA"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker学习笔记02-镜像"><span class="toc-text">docker学习笔记02-镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获取镜像"><span class="toc-text">获取镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行image"><span class="toc-text">运行image</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列出镜像"><span class="toc-text">列出镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中间层镜像"><span class="toc-text">中间层镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除本地镜像"><span class="toc-text">删除本地镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用-docker-image-ls-命令来配合"><span class="toc-text">用 docker image ls 命令来配合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用docker-file定制镜像"><span class="toc-text">使用docker file定制镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FROM-指定基础镜像"><span class="toc-text">FROM 指定基础镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RUN-执行命令"><span class="toc-text">RUN 执行命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建镜像"><span class="toc-text">构建镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考链接"><span class="toc-text">参考链接</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/2018-05-08-ES6学习之路06_Promise深入/">ES6-学习之路-06promise-async</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/2018-05-07-nodejs学习之路03/">nodejs学习之路03-express webscoket</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/2018-05-06-nodejs学习之路02/">nodejs学习之路02</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/2018-05-03-ES6学习之路05/">ES6学习之路05</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/02/2018-05-02-ES6学习之路04/">ES6学习之路04</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/01/2018-05-01-nodejs学习之路01/">nodejs学习之路01-异步调用与net fs核心类库</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/30/2018-04-30-docker学习笔记03/">docker学习笔记03-Dockerfile指令详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/29/2018-04-29-指数基金投资指南/">指数基金投资指南-银行螺丝钉</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/2018-04-28-docker学习笔记02/">docker学习笔记02-镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/2018-04-28-docker学习笔记01/">docker学习笔记01-docker介绍与安装</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/CICD/" style="font-size: 15px;">CICD</a> <a href="/tags/规划/" style="font-size: 15px;">规划</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/运动/" style="font-size: 15px;">运动</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/dumingcode" title="github" target="_blank">github</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">DuMing.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>